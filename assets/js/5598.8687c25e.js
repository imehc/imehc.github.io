"use strict";(self.webpackChunkanch=self.webpackChunkanch||[]).push([["5598"],{9005(e,t,n){let o,i;n.d(t,{A:()=>ex});var s=n(61586),r=n(99905),a=n(29242),l=n(99600),c=n(12211),u=n(6963),d=n(74325);let f={CUMULUS:0};f.validate=function(e){return e===f.CUMULUS};let h=Object.freeze(f);var p=n(92920),v=n(23751),_=n(24089),x=n(89466);function m(e,t){if(e=e??_.A.EMPTY_OBJECT,this._show=e.show??!0,this._position=l.A.clone(e.position??l.A.ZERO),!(0,x.A)(e.scale)&&(0,x.A)(e.maximumSize))this._maximumSize=l.A.clone(e.maximumSize),this._scale=new v.A(this._maximumSize.x,this._maximumSize.y);else{this._scale=v.A.clone(e.scale??new v.A(20,12));let t=new l.A(this._scale.x,this._scale.y,Math.min(this._scale.x,this._scale.y)/1.5);this._maximumSize=l.A.clone(e.maximumSize??t)}this._slice=e.slice??-1,this._color=u.A.clone(e.color??u.A.WHITE),this._brightness=e.brightness??1,this._cloudCollection=t,this._index=-1}let A=m.SHOW_INDEX=0,y=m.POSITION_INDEX=1,g=m.SCALE_INDEX=2,T=m.MAXIMUM_SIZE_INDEX=3,S=m.SLICE_INDEX=4,w=m.BRIGHTNESS_INDEX=5,b=m.COLOR_INDEX=6;function D(e,t){let n=e._cloudCollection;(0,x.A)(n)&&(n._updateCloud(e,t),e._dirty=!0)}m.NUMBER_OF_PROPERTIES=7,Object.defineProperties(m.prototype,{show:{get:function(){return this._show},set:function(e){c.A.typeOf.bool("value",e),this._show!==e&&(this._show=e,D(this,A))}},position:{get:function(){return this._position},set:function(e){c.A.typeOf.object("value",e);let t=this._position;l.A.equals(t,e)||(l.A.clone(e,t),D(this,y))}},scale:{get:function(){return this._scale},set:function(e){c.A.typeOf.object("value",e);let t=this._scale;v.A.equals(t,e)||(v.A.clone(e,t),D(this,g))}},maximumSize:{get:function(){return this._maximumSize},set:function(e){c.A.typeOf.object("value",e);let t=this._maximumSize;l.A.equals(t,e)||(l.A.clone(e,t),D(this,T))}},color:{get:function(){return this._color},set:function(e){c.A.typeOf.object("value",e);let t=this._color;u.A.equals(t,e)||(u.A.clone(e,t),D(this,b))}},slice:{get:function(){return this._slice},set:function(e){c.A.typeOf.number("value",e),this._slice!==e&&(this._slice=e,D(this,S))}},brightness:{get:function(){return this._brightness},set:function(e){c.A.typeOf.number("value",e),this._brightness!==e&&(this._brightness=e,D(this,w))}}}),m.prototype._destroy=function(){this._cloudCollection=void 0};var I=n(87606),C=n(4599),E=n(49452),z=n(31266),L=n(895),N=n(57014),R=n(63067),B=n(85452),O=n(4527),W=n(66707),P=n(29333),U=n(74183),X=n(27636),F=n(90485),V=n(50466),k=n(24260),M=n(74664),q=n(47522),Y=n(48905);let H=new l.A,G={positionHighAndScaleX:0,positionLowAndScaleY:1,packedAttribute0:2,packedAttribute1:3,color:4},j={direction:0,positionHighAndScaleX:1,positionLowAndScaleY:2,packedAttribute0:3,packedAttribute1:4,color:5},Z=m.SHOW_INDEX,J=m.POSITION_INDEX,K=m.SCALE_INDEX,Q=m.MAXIMUM_SIZE_INDEX,$=m.SLICE_INDEX,ee=m.BRIGHTNESS_INDEX,et=m.NUMBER_OF_PROPERTIES,en=m.COLOR_INDEX;function eo(e){e=e??_.A.EMPTY_OBJECT,this._clouds=[],this._cloudsToUpdate=[],this._cloudsToUpdateIndex=0,this._cloudsRemoved=!1,this._createVertexArray=!1,this._propertiesChanged=new Uint32Array(et),this._noiseTexture=void 0,this._textureSliceWidth=128,this._noiseTextureRows=4,this.noiseDetail=e.noiseDetail??16,this.noiseOffset=l.A.clone(e.noiseOffset??l.A.ZERO),this._loading=!1,this._ready=!1;let t=this;this._uniforms={u_noiseTexture:function(){return t._noiseTexture},u_noiseTextureDimensions:ei(t),u_noiseDetail:function(){return t.noiseDetail}},this._vaNoise=void 0,this._spNoise=void 0,this._spCreated=!1,this._sp=void 0,this._rs=void 0,this.show=e.show??!0,this._colorCommands=[],this.debugBillboards=e.debugBillboards??!1,this._compiledDebugBillboards=!1,this.debugEllipsoids=e.debugEllipsoids??!1,this._compiledDebugEllipsoids=!1}function ei(e){return function(){return H.x=e._textureSliceWidth,H.y=e._noiseTextureRows,H.z=1/e._noiseTextureRows,H}}function es(e){let t=e.length;for(let n=0;n<t;++n)e[n]&&e[n]._destroy()}function er(e){if(e._cloudsRemoved){e._cloudsRemoved=!1;let t=[],n=e._clouds,o=n.length;for(let e=0,i=0;e<o;++e){let o=n[e];(0,x.A)(o)&&(n._index=i++,t.push(o))}e._clouds=t}}Object.defineProperties(eo.prototype,{length:{get:function(){return er(this),this._clouds.length}}}),eo.prototype.add=function(e){let t,n=(e=e??_.A.EMPTY_OBJECT).cloudType??h.CUMULUS;if(!h.validate(n))throw new C.A("invalid cloud type");return n===h.CUMULUS&&((t=new m(e,this))._index=this._clouds.length,this._clouds.push(t),this._createVertexArray=!0),t},eo.prototype.remove=function(e){return!!this.contains(e)&&(this._clouds[e._index]=void 0,this._cloudsRemoved=!0,this._createVertexArray=!0,e._destroy(),!0)},eo.prototype.removeAll=function(){es(this._clouds),this._clouds=[],this._cloudsToUpdate=[],this._cloudsToUpdateIndex=0,this._cloudsRemoved=!1,this._createVertexArray=!0},eo.prototype._updateCloud=function(e,t){e._dirty||(this._cloudsToUpdate[this._cloudsToUpdateIndex++]=e),++this._propertiesChanged[t]},eo.prototype.contains=function(e){return(0,x.A)(e)&&e._cloudCollection===this},eo.prototype.get=function(e){return c.A.typeOf.number("index",e),er(this),this._clouds[e]};let ea=new Float32Array([-1,-1,1,-1,1,1,-1,1]),el=new Uint16Array([0,1,2,0,2,3]);function ec(e){let t=e.cache.cloudCollection_indexBufferBatched;if((0,x.A)(t))return t;let n=new Uint16Array(98298);for(let e=0,t=0;e<98298;e+=6,t+=4)n[e]=t,n[e+1]=t+1,n[e+2]=t+2,n[e+3]=t,n[e+4]=t+2,n[e+5]=t+3;return(t=r.A.createIndexBuffer({context:e,typedArray:n,usage:a.A.STATIC_DRAW,indexDatatype:L.A.UNSIGNED_SHORT})).vertexArrayDestroyable=!1,e.cache.cloudCollection_indexBufferBatched=t,t}function eu(e){let t=e.cache.cloudCollection_indexBufferInstanced;return(0,x.A)(t)||((t=r.A.createIndexBuffer({context:e,typedArray:new Uint16Array([0,1,2,0,2,3]),usage:a.A.STATIC_DRAW,indexDatatype:L.A.UNSIGNED_SHORT})).vertexArrayDestroyable=!1,e.cache.cloudCollection_indexBufferInstanced=t),t}let ed=new z.A;function ef(e,t,n,i){let s,r=n[o.positionHighAndScaleX],a=n[o.positionLowAndScaleY],l=i.position;z.A.fromCartesian(l,ed);let c=i.scale,u=ed.high,d=ed.low;e._instanced?(r(s=i._index,u.x,u.y,u.z,c.x),a(s,d.x,d.y,d.z,c.y)):(r((s=4*i._index)+0,u.x,u.y,u.z,c.x),r(s+1,u.x,u.y,u.z,c.x),r(s+2,u.x,u.y,u.z,c.x),r(s+3,u.x,u.y,u.z,c.x),a(s+0,d.x,d.y,d.z,c.y),a(s+1,d.x,d.y,d.z,c.y),a(s+2,d.x,d.y,d.z,c.y),a(s+3,d.x,d.y,d.z,c.y))}function eh(e,t,n,i){let s,r=n[o.packedAttribute0],a=i.show,l=i.brightness;e._instanced?r(s=i._index,a,l,0,0):(r((s=4*i._index)+0,a,l,0,0),r(s+1,a,l,1,0),r(s+2,a,l,1,1),r(s+3,a,l,0,1))}function ep(e,t,n,i){let s,r=n[o.packedAttribute1],a=i.maximumSize,l=i.slice;e._instanced?r(s=i._index,a.x,a.y,a.z,l):(r((s=4*i._index)+0,a.x,a.y,a.z,l),r(s+1,a.x,a.y,a.z,l),r(s+2,a.x,a.y,a.z,l),r(s+3,a.x,a.y,a.z,l))}function ev(e,t,n,i){let s,r=n[o.color],a=i.color,l=u.A.floatToByte(a.red),c=u.A.floatToByte(a.green),d=u.A.floatToByte(a.blue),f=u.A.floatToByte(a.alpha);e._instanced?r(s=i._index,l,c,d,f):(r((s=4*i._index)+0,l,c,d,f),r(s+1,l,c,d,f),r(s+2,l,c,d,f),r(s+3,l,c,d,f))}let e_=[];eo.prototype.update=function(e){if(er(this),!this.show)return;let t=this.debugBillboards||this.debugEllipsoids;this._ready=!!t||(0,x.A)(this._noiseTexture),this._ready||this._loading||t||function(e,t,n,o){let i,s,l,c=e._textureSliceWidth,u=e._noiseTextureRows;if(c/u<1||c%u!=0)throw new C.A("noiseTextureRows must evenly divide textureSliceWidth");let f=t.context;i=r.A.createVertexBuffer({context:f,typedArray:ea,usage:a.A.STATIC_DRAW}),s=r.A.createIndexBuffer({context:f,typedArray:el,usage:a.A.STATIC_DRAW,indexDatatype:L.A.UNSIGNED_SHORT}),l=[{index:0,vertexBuffer:i,componentsPerAttribute:2,componentDatatype:p.A.FLOAT}],e._vaNoise=new M.A({context:f,attributes:l,indexBuffer:s}),e._spNoise=U.A.fromCache({context:f,vertexShaderSource:n,fragmentShaderSource:o,attributeLocations:{position:0}});let h=e.noiseDetail,v=e.noiseOffset;e._noiseTexture=new X.A({context:f,width:c*c/u,height:c*u,pixelDatatype:R.A.UNSIGNED_BYTE,pixelFormat:B.A.RGBA,sampler:new W.A({wrapS:k.A.REPEAT,wrapT:k.A.REPEAT,minificationFilter:V.A.NEAREST,magnificationFilter:F.A.NEAREST})});let _=new d.A({vertexArray:e._vaNoise,shaderProgram:e._spNoise,outputTexture:e._noiseTexture,uniformMap:{u_noiseTextureDimensions:ei(e),u_noiseDetail:function(){return h},u_noiseOffset:function(){return v}},persists:!1,owner:e,postExecute:function(t){e._ready=!0,e._loading=!1}});t.commandList.push(_),e._loading=!0}(this,e,"uniform vec3 u_noiseTextureDimensions;\nin vec2 position;\n\nout vec2 v_position;\n\nvoid main()\n{\n    gl_Position = vec4(position, 0.1, 1.0);\n\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    float noiseTextureRows = u_noiseTextureDimensions.y;\n    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n    vec2 transformedPos = (position * 0.5) + vec2(0.5);\n    transformedPos *= textureSliceWidth;\n    transformedPos.x *= textureSliceWidth * inverseNoiseTextureRows;\n    transformedPos.y *= noiseTextureRows;\n    v_position = transformedPos;\n}\n","uniform vec3 u_noiseTextureDimensions;\nuniform float u_noiseDetail;\nuniform vec3 u_noiseOffset;\nin vec2 v_position;\n\nfloat wrap(float value, float rangeLength) {\n    if(value < 0.0) {\n        float absValue = abs(value);\n        float modValue = mod(absValue, rangeLength);\n        return mod(rangeLength - modValue, rangeLength);\n    }\n    return mod(value, rangeLength);\n}\n\nvec3 wrapVec(vec3 value, float rangeLength) {\n    return vec3(wrap(value.x, rangeLength),\n                wrap(value.y, rangeLength),\n                wrap(value.z, rangeLength));\n}\n\nvec3 random3(vec3 p) {\n    float dot1 = dot(p, vec3(127.1, 311.7, 932.8));\n    float dot2 = dot(p, vec3(269.5, 183.3, 421.4));\n    return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2));\n}\n\n// Frequency corresponds to cell size.\n// The higher the frequency, the smaller the cell size.\nvec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) {\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    vec3 cell = centerCell + offset;\n    cell = wrapVec(cell, textureSliceWidth / u_noiseDetail);\n    cell += floor(u_noiseOffset / u_noiseDetail);\n    vec3 p = offset + random3(cell);\n    return p;\n}\n\nfloat worleyNoise(vec3 p, float freq) {\n    vec3 centerCell = floor(p * freq);\n    vec3 pointInCell = fract(p * freq);\n    float shortestDistance = 1000.0;\n\n    for(float z = -1.0; z <= 1.0; z++) {\n        for(float y = -1.0; y <= 1.0; y++) {\n            for(float x = -1.0; x <= 1.0; x++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 point = getWorleyCellPoint(centerCell, offset, freq);\n\n                float distance = length(pointInCell - point);\n                if(distance < shortestDistance) {\n                    shortestDistance = distance;\n                }\n            }\n        }\n    }\n\n    return shortestDistance;\n}\n\nconst float MAX_FBM_ITERATIONS = 10.0;\n\nfloat worleyFBMNoise(vec3 p, float octaves, float scale) {\n    float noise = 0.0;\n    float freq = 1.0;\n    float persistence = 0.625;\n    for(float i = 0.0; i < MAX_FBM_ITERATIONS; i++) {\n        if(i >= octaves) {\n            break;\n        }\n\n        noise += worleyNoise(p * scale, freq * scale) * persistence;\n        persistence *= 0.5;\n        freq *= 2.0;\n    }\n    return noise;\n}\n\nvoid main() {\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n    float x = mod(v_position.x, textureSliceWidth);\n    float y = mod(v_position.y, textureSliceWidth);\n    float sliceRow = floor(v_position.y / textureSliceWidth);\n    float z = floor(v_position.x / textureSliceWidth) + sliceRow * inverseNoiseTextureRows * textureSliceWidth;\n\n    vec3 position = vec3(x, y, z);\n    position /= u_noiseDetail;\n    float worley0 = clamp(worleyFBMNoise(position, 3.0, 1.0), 0.0, 1.0);\n    float worley1 = clamp(worleyFBMNoise(position, 3.0, 2.0), 0.0, 1.0);\n    float worley2 = clamp(worleyFBMNoise(position, 3.0, 3.0), 0.0, 1.0);\n    out_FragColor = vec4(worley0, worley1, worley2, 1.0);\n}\n"),this._instanced=e.context.instancedArrays,o=this._instanced?j:G,i=this._instanced?eu:ec;let n=this._clouds.length,l=this._cloudsToUpdate,c=this._cloudsToUpdateIndex;if(this._createVertexArray?!function(e,t){let n=t.context;e._createVertexArray=!1,e._vaf=e._vaf&&e._vaf.destroy();let s=e._clouds,l=s.length;if(l>0){var c;let u,d,f;c=e._instanced,d=[{index:o.positionHighAndScaleX,componentsPerAttribute:4,componentDatatype:p.A.FLOAT,usage:a.A.STATIC_DRAW},{index:o.positionLowAndScaleY,componentsPerAttribute:4,componentDatatype:p.A.FLOAT,usage:a.A.STATIC_DRAW},{index:o.packedAttribute0,componentsPerAttribute:4,componentDatatype:p.A.FLOAT,usage:a.A.STATIC_DRAW},{index:o.packedAttribute1,componentsPerAttribute:4,componentDatatype:p.A.FLOAT,usage:a.A.STATIC_DRAW},{index:o.color,componentsPerAttribute:4,componentDatatype:p.A.UNSIGNED_BYTE,normalize:!0,usage:a.A.STATIC_DRAW}],c&&d.push({index:o.direction,componentsPerAttribute:2,componentDatatype:p.A.FLOAT,vertexBuffer:(f=n.cache.cloudCollection_vertexBufferInstanced,(0,x.A)(f)||((f=r.A.createVertexBuffer({context:n,typedArray:new Float32Array([0,0,1,0,1,1,0,1]),usage:a.A.STATIC_DRAW})).vertexArrayDestroyable=!1,n.cache.cloudCollection_vertexBufferInstanced=f),f)}),e._vaf=new q.A(n,d,c?l:4*l,c);let h=e._vaf.writers;for(u=0;u<l;++u){let n=s[u];ef(e,t,h,n),eh(e,t,h,n),ep(e,t,h,n),ev(e,t,h,n)}e._vaf.commit(i(n))}}(this,e):c>0&&function(e,t){let n,o,s,r=t.context,a=e._clouds.length,l=e._cloudsToUpdate,c=e._cloudsToUpdateIndex,u=e._propertiesChanged;e_.length=0,(u[J]||u[K])&&e_.push(ef),(u[Z]||u[ee])&&e_.push(eh),(u[Q]||u[$])&&e_.push(ep),u[en]&&e_.push(ev);let d=e_.length,f=e._vaf.writers;if(c/a>.1){for(n=0;n<c;++n)for(s=0,(o=l[n])._dirty=!1;s<d;++s)e_[s](e,t,f,o);e._vaf.commit(i(r))}else{for(n=0;n<c;++n){for(s=0,(o=l[n])._dirty=!1;s<d;++s)e_[s](e,t,f,o);e._instanced?e._vaf.subCommit(o._index,1):e._vaf.subCommit(4*o._index,4)}e._vaf.endSubCommits()}e._cloudsToUpdateIndex=0}(this,e),c>1.5*n&&(l.length=n),(0,x.A)(this._vaf)&&(0,x.A)(this._vaf.va)&&!(!this._ready&!t)){let t,n,i;this._spCreated&&this.debugBillboards===this._compiledDebugBillboards&&this.debugEllipsoids===this._compiledDebugEllipsoids||(t=e.context,n=new P.A({defines:[],sources:["#ifdef INSTANCED\nin vec2 direction;\n#endif\nin vec4 positionHighAndScaleX;\nin vec4 positionLowAndScaleY;\nin vec4 packedAttribute0;\nin vec4 packedAttribute1;\nin vec4 color;\n\nout vec2 v_offset;\nout vec3 v_maximumSize;\nout vec4 v_color;\nout float v_slice;\nout float v_brightness;\n\nvoid main() {\n    // Unpack attributes.\n    vec3 positionHigh = positionHighAndScaleX.xyz;\n    vec3 positionLow = positionLowAndScaleY.xyz;\n    vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w);\n\n    float show = packedAttribute0.x;\n    float brightness = packedAttribute0.y;\n    vec2 coordinates = packedAttribute0.wz;\n    vec3 maximumSize = packedAttribute1.xyz;\n    float slice = packedAttribute1.w;\n\n#ifdef INSTANCED\n    vec2 dir = direction;\n#else\n    vec2 dir = coordinates;\n#endif\n\n    vec2 offset = dir - vec2(0.5, 0.5);\n    vec2 scaledOffset = scale * offset;\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n    positionEC.xy += scaledOffset;\n    \n    positionEC.xyz *= show;\n    gl_Position = czm_projection * positionEC;\n\n    v_offset = offset;\n    v_maximumSize = maximumSize;\n    v_color = color;\n    v_slice = slice;\n    v_brightness = brightness;\n}\n"]}),this._instanced&&n.defines.push("INSTANCED"),i=new P.A({defines:[],sources:["uniform sampler2D u_noiseTexture;\nuniform vec3 u_noiseTextureDimensions;\nuniform float u_noiseDetail;\nin vec2 v_offset;\nin vec3 v_maximumSize;\nin vec4 v_color;\nin float v_slice;\nin float v_brightness;\n\nfloat wrap(float value, float rangeLength) {\n    if(value < 0.0) {\n        float absValue = abs(value);\n        float modValue = mod(absValue, rangeLength);\n        return mod(rangeLength - modValue, rangeLength);\n    }\n    return mod(value, rangeLength);\n}\n\nvec3 wrapVec(vec3 value, float rangeLength) {\n    return vec3(wrap(value.x, rangeLength),\n                wrap(value.y, rangeLength),\n                wrap(value.z, rangeLength));\n}\n\nvec2 voxelToUV(vec3 voxelIndex) {\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    float noiseTextureRows = u_noiseTextureDimensions.y;\n    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n\n    float textureSliceWidthSquared = textureSliceWidth * textureSliceWidth;\n    vec2 inverseNoiseTextureDimensions = vec2(noiseTextureRows / textureSliceWidthSquared,\n                                            inverseNoiseTextureRows / textureSliceWidth);\n    vec3 wrappedIndex = wrapVec(voxelIndex, textureSliceWidth);\n    float column = mod(wrappedIndex.z, textureSliceWidth * inverseNoiseTextureRows);\n    float row = floor(wrappedIndex.z / textureSliceWidth * noiseTextureRows);\n\n    float xPixelCoord = wrappedIndex.x + column * textureSliceWidth;\n    float yPixelCoord = wrappedIndex.y + row * textureSliceWidth;\n    return vec2(xPixelCoord, yPixelCoord) * inverseNoiseTextureDimensions;\n}\n\n// Interpolate a voxel with its neighbor (along the positive X-axis)\nvec4 lerpSamplesX(vec3 voxelIndex, float x) {\n    vec2 uv0 = voxelToUV(voxelIndex);\n    vec2 uv1 = voxelToUV(voxelIndex + vec3(1.0, 0.0, 0.0));\n    vec4 sample0 = texture(u_noiseTexture, uv0);\n    vec4 sample1 = texture(u_noiseTexture, uv1);\n    return mix(sample0, sample1, x);\n}\n\nvec4 sampleNoiseTexture(vec3 position) {\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    vec3 recenteredPos = position + vec3(textureSliceWidth / 2.0);\n    vec3 lerpValue = fract(recenteredPos);\n    vec3 voxelIndex = floor(recenteredPos);\n\n    vec4 xLerp00 = lerpSamplesX(voxelIndex, lerpValue.x);\n    vec4 xLerp01 = lerpSamplesX(voxelIndex + vec3(0.0, 0.0, 1.0), lerpValue.x);\n    vec4 xLerp10 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 0.0), lerpValue.x);\n    vec4 xLerp11 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 1.0), lerpValue.x);\n\n    vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y);\n    vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y);\n    return mix(yLerp0, yLerp1, lerpValue.z);\n}\n\n// Intersection with a unit sphere with radius 0.5 at center (0, 0, 0).\nbool intersectSphere(vec3 origin, vec3 dir, float slice,\n                     out vec3 point, out vec3 normal) {\n    float A = dot(dir, dir);\n    float B = dot(origin, dir);\n    float C = dot(origin, origin) - 0.25;\n    float discriminant = (B * B) - (A * C);\n    if(discriminant < 0.0) {\n        return false;\n    }\n    float root = sqrt(discriminant);\n    float t = (-B - root) / A;\n    if(t < 0.0) {\n        t = (-B + root) / A;\n    }\n    point = origin + t * dir;\n\n    if(slice >= 0.0) {\n        point.z = (slice / 2.0) - 0.5;\n        if(length(point) > 0.5) {\n            return false;\n        }\n    }\n\n    normal = normalize(point);\n    point -= czm_epsilon2 * normal;\n    return true;\n}\n\n// Transforms the ray origin and direction into unit sphere space,\n// then transforms the result back into the ellipsoid's space.\nbool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice,\n                        out vec3 point, out vec3 normal) {\n    if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) {\n        return false;\n    }\n\n    vec3 o = (origin - center) / scale;\n    vec3 d = dir / scale;\n    vec3 p, n;\n    bool intersected = intersectSphere(o, d, slice, p, n);\n    if(intersected) {\n        point = (p * scale) + center;\n        normal = n;\n    }\n    return intersected;\n}\n\n// Assume that if phase shift is being called for octave i,\n// the frequency is of i - 1. This saves us from doing extra\n// division / multiplication operations.\nvec2 phaseShift2D(vec2 p, vec2 freq) {\n    return (czm_pi / 2.0) * sin(freq.yx * p.yx);\n}\n\nvec2 phaseShift3D(vec3 p, vec2 freq) {\n    return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z));\n}\n\n// The cloud texture function derived from Gardner's 1985 paper,\n// \"Visual Simulation of Clouds.\"\n// https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf\nconst float T0    = 0.6;  // contrast of the texture pattern\nconst float k     = 0.1;  // computed to produce a maximum value of 1\nconst float C0    = 0.8;  // coefficient\nconst float FX0   = 0.6;  // frequency X\nconst float FY0   = 0.6;  // frequency Y\nconst int octaves = 5;\n\nfloat T(vec3 point) {\n    vec2 sum = vec2(0.0);\n    float Ci = C0;\n    vec2 FXY = vec2(FX0, FY0);\n    vec2 PXY = vec2(0.0);\n    for(int i = 1; i <= octaves; i++) {\n        PXY = phaseShift3D(point, FXY);\n        Ci *= 0.707;\n        FXY *= 2.0;\n        vec2 sinTerm = sin(FXY * point.xy + PXY);\n        sum += Ci * sinTerm + vec2(T0);\n    }\n    return k * sum.x * sum.y;\n}\n\nconst float a = 0.5;  // fraction of surface reflection due to ambient or scattered light,\nconst float t = 0.4;  // fraction of texture shading\nconst float s = 0.25; // fraction of specular reflection\n\nfloat I(float Id, float Is, float It) {\n    return (1.0 - a) * ((1.0 - t) * ((1.0 - s) * Id + s * Is) + t * It) + a;\n}\n\nconst vec3 lightDir = normalize(vec3(0.2, -1.0, 0.7));\n\nvec4 drawCloud(vec3 rayOrigin, vec3 rayDir, vec3 cloudCenter, vec3 cloudScale, float cloudSlice,\n               float brightness) {\n    vec3 cloudPoint, cloudNormal;\n    if(!intersectEllipsoid(rayOrigin, rayDir, cloudCenter, cloudScale, cloudSlice,\n                            cloudPoint, cloudNormal)) {\n        return vec4(0.0);\n    }\n\n    float Id = clamp(dot(cloudNormal, -lightDir), 0.0, 1.0);  // diffuse reflection\n    float Is = max(pow(dot(-lightDir, -rayDir), 2.0), 0.0);   // specular reflection\n    float It = T(cloudPoint);                                 // texture function\n    float intensity = I(Id, Is, It);\n    vec3 color = vec3(intensity * clamp(brightness, 0.1, 1.0));\n\n    vec4 noise = sampleNoiseTexture(u_noiseDetail * cloudPoint);\n    float W = noise.x;\n    float W2 = noise.y;\n    float W3 = noise.z;\n\n    // The dot product between the cloud's normal and the ray's direction is greatest\n    // in the center of the ellipsoid's surface. It decreases towards the edge.\n    // Thus, it is used to blur the areas leading to the edges of the ellipsoid,\n    // so that no harsh lines appear.\n\n    // The first (and biggest) layer of worley noise is then subtracted from this.\n    // The final result is scaled up so that the base cloud is not too translucent.\n    float ndDot = clamp(dot(cloudNormal, -rayDir), 0.0, 1.0);\n    float TR = pow(ndDot, 3.0) - W; // translucency\n    TR *= 1.3;\n\n    // Subtracting the second and third layers of worley noise is more complicated.\n    // If these layers of noise were simply subtracted from the current translucency,\n    // the shape derived from the first layer of noise would be completely deleted.\n    // The erosion of this noise should thus be constricted to the edges of the cloud.\n    // However, because the edges of the ellipsoid were already blurred away, mapping\n    // the noise to (1.0 - ndDot) will have no impact on most of the cloud's appearance.\n    // The value of (0.5 - ndDot) provides the best compromise.\n    float minusDot = 0.5 - ndDot;\n\n    // Even with the previous calculation, subtracting the second layer of wnoise\n    // erode too much of the cloud. The addition of it, however, will detailed\n    // volume to the cloud. As long as the noise is only added and not subtracted,\n    // the results are aesthetically pleasing.\n\n    // The minusDot product is mapped in a way that it is larger at the edges of\n    // the ellipsoid, so a subtraction and min operation are used instead of\n    // an addition and max one.\n    TR -= min(minusDot * W2, 0.0);\n\n    // The third level of worley noise is subtracted from the result, with some\n    // modifications. First, a scalar is added to minusDot so that the noise\n    // starts affecting the shape farther away from the center of the ellipsoid's\n    // surface. Then, it is scaled down so its impact is not too intense.\n    TR -= 0.8 * (minusDot + 0.25) * W3;\n\n    // The texture function's shading does not correlate with the shape of the cloud\n    // produced by the layers of noise, so an extra shading scalar is calculated.\n    // The darkest areas of the cloud are assigned to be where the noise erodes\n    // the cloud the most. This is then interpolated based on the translucency\n    // and the diffuse shading term of that point in the cloud.\n    float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR);\n\n    // To avoid values that are too dark, this scalar is increased by a small amount\n    // and clamped so it never goes to zero.\n    shading = clamp(shading + 0.2, 0.3, 1.0);\n\n    // Finally, the contrast of the cloud's color is increased.\n    vec3 finalColor = mix(vec3(0.5), shading * color, 1.15);\n    return vec4(finalColor, clamp(TR, 0.0, 1.0)) * v_color;\n}\n\nvoid main() {\n#ifdef DEBUG_BILLBOARDS\n    out_FragColor = vec4(0.0, 0.5, 0.5, 1.0);\n#endif\n    // To avoid calculations with high values,\n    // we raycast from an arbitrarily smaller space.\n    vec2 coordinate = v_maximumSize.xy * v_offset;\n\n    vec3 ellipsoidScale = 0.82 * v_maximumSize;\n    vec3 ellipsoidCenter = vec3(0.0);\n\n    float zOffset = max(ellipsoidScale.z - 10.0, 0.0);\n    vec3 eye = vec3(0, 0, -10.0 - zOffset);\n    vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye);\n    vec3 rayOrigin = eye;\n#ifdef DEBUG_ELLIPSOIDS\n    vec3 point, normal;\n    if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice,\n                          point, normal)) {\n        out_FragColor = v_brightness * v_color;\n    }\n#else\n#ifndef DEBUG_BILLBOARDS\n    vec4 cloud = drawCloud(rayOrigin, rayDir,\n                           ellipsoidCenter, ellipsoidScale, v_slice, v_brightness);\n    if(cloud.w < 0.01) {\n        discard;\n    }\n    out_FragColor = cloud;\n#endif\n#endif\n}\n"]}),this.debugBillboards&&i.defines.push("DEBUG_BILLBOARDS"),this.debugEllipsoids&&i.defines.push("DEBUG_ELLIPSOIDS"),this._sp=U.A.replaceCache({context:t,shaderProgram:this._sp,vertexShaderSource:n,fragmentShaderSource:i,attributeLocations:o}),this._rs=O.A.fromCache({depthTest:{enabled:!0,func:Y.A.LESS},depthMask:!1,blending:s.A.ALPHA_BLEND}),this._spCreated=!0,this._compiledDebugBillboards=this.debugBillboards,this._compiledDebugEllipsoids=this.debugEllipsoids),function(e,t){let n=t.passes,o=e._uniforms,i=t.commandList;if(n.render){let t=e._colorCommands,n=e._vaf.va,s=n.length;t.length=s;for(let r=0;r<s;r++){let s=t[r];(0,x.A)(s)||(s=t[r]=new E.A),s.pass=N.A.TRANSLUCENT,s.owner=e,s.uniformMap=o,s.count=n[r].indicesCount,s.vertexArray=n[r].va,s.shaderProgram=e._sp,s.renderState=e._rs,e._instanced&&(s.count=6,s.instanceCount=e._clouds.length),i.push(s)}}}(this,e)}},eo.prototype.isDestroyed=function(){return!1},eo.prototype.destroy=function(){return this._noiseTexture=this._noiseTexture&&this._noiseTexture.destroy(),this._sp=this._sp&&this._sp.destroy(),this._vaf=this._vaf&&this._vaf.destroy(),es(this._clouds),(0,I.A)(this)};let ex=eo}}]);