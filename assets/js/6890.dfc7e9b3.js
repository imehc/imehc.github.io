"use strict";(self.webpackChunkanch=self.webpackChunkanch||[]).push([["6890"],{37522(e,t,r){r.d(t,{j:()=>l});var n=r(57140),i=r(67199),a=r(45225);function l(e,t,r){let l=(0,a.C)(e=>e.size),o=(0,a.C)(e=>e.viewport),s="number"==typeof e?e:l.width*o.dpr,c="number"==typeof t?t:l.height*o.dpr,u=("number"==typeof e?r:e)||{},{samples:d=0,depth:m,...f}=u,h=null!=m?m:u.depthBuffer,p=n.useMemo(()=>{let e=new i.nWS(s,c,{minFilter:i.k6q,magFilter:i.k6q,type:i.ix0,...f});return h&&(e.depthTexture=new i.VCu(s,c,i.RQf)),e.samples=d,e},[]);return n.useLayoutEffect(()=>{p.setSize(s,c),d&&(p.samples=d)},[d,p,s,c]),n.useEffect(()=>()=>p.dispose(),[]),p}},30182(e,t,r){r.d(t,{Y:()=>o});var n=r(67199),i=r(57140),a=r(45225);function l({defaultScene:e,defaultCamera:t,renderPriority:r=1}){let n,{gl:l,scene:o,camera:s}=(0,a.C)();return(0,a.D)(()=>{n=l.autoClear,1===r&&(l.autoClear=!0,l.render(e,t)),l.autoClear=!1,l.clearDepth(),l.render(o,s),l.autoClear=n},r),i.createElement("group",{onPointerOver:()=>null})}function o({children:e,renderPriority:t=1}){let{scene:r,camera:o}=(0,a.C)(),[s]=i.useState(()=>new n.Z58);return i.createElement(i.Fragment,null,(0,a.o)(i.createElement(i.Fragment,null,e,i.createElement(l,{defaultScene:r,defaultCamera:o,renderPriority:t})),s,{events:{priority:t+1}}))}},4562(e,t,r){r.d(t,{q:()=>o});var n=r(44320),i=r(57140),a=r(45225),l=r(37522);let o=i.forwardRef(({envMap:e,resolution:t=256,frames:r=1/0,children:o,makeDefault:s,...c},u)=>{let d=(0,a.C)(({set:e})=>e),m=(0,a.C)(({camera:e})=>e),f=(0,a.C)(({size:e})=>e),h=i.useRef(null);i.useImperativeHandle(u,()=>h.current,[]);let p=i.useRef(null),x=(0,l.j)(t);i.useLayoutEffect(()=>{c.manual||h.current.updateProjectionMatrix()},[f,c]),i.useLayoutEffect(()=>{h.current.updateProjectionMatrix()}),i.useLayoutEffect(()=>{if(s)return d(()=>({camera:h.current})),()=>d(()=>({camera:m}))},[h,s,d]);let y=0,v=null,g="function"==typeof o;return(0,a.D)(t=>{g&&(r===1/0||y<r)&&(p.current.visible=!1,t.gl.setRenderTarget(x),v=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,h.current),t.scene.background=v,t.gl.setRenderTarget(null),p.current.visible=!0,y++)}),i.createElement(i.Fragment,null,i.createElement("orthographicCamera",(0,n.A)({left:-(f.width/2),right:f.width/2,top:f.height/2,bottom:-(f.height/2),ref:h},c),!g&&o),i.createElement("group",{ref:p},g&&o(x.texture)))})},54325(e,t,r){let n,i;r.d(t,{E:()=>g});var a=r(44320),l=r(57140),o=r(84668),s=r(67199),c=r(45225);let u=new s.Pq0,d=new s.Pq0,m=new s.Pq0,f=new s.I9Y;function h(e,t,r){let n=u.setFromMatrixPosition(e.matrixWorld);n.project(t);let i=r.width/2,a=r.height/2;return[n.x*i+i,-(n.y*a)+a]}let p=e=>1e-10>Math.abs(e)?0:e;function x(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=p(t[r]*e.elements[r])+(15!==r?",":")");return r+n}let y=(n=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>x(e,n)),v=(i=e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1],(e,t)=>x(e,i(t),"translate(-50%,-50%)")),g=l.forwardRef(({children:e,eps:t=.001,style:r,className:n,prepend:i,center:x,fullscreen:g,portal:M,distanceFactor:P,sprite:b=!1,transform:E=!1,occlude:w,onOcclude:C,castShadow:W,receiveShadow:R,material:S,geometry:$,zIndexRange:F=[0x1000037,0],calculatePosition:k=h,as:z="div",wrapperClass:T,pointerEvents:j="auto",...q},A)=>{let{gl:I,camera:L,scene:H,size:D,raycaster:N,events:B,viewport:O}=(0,c.C)(),[U]=l.useState(()=>document.createElement(z)),V=l.useRef(null),Y=l.useRef(null),Z=l.useRef(0),_=l.useRef([0,0]),G=l.useRef(null),Q=l.useRef(null),J=(null==M?void 0:M.current)||B.connected||I.domElement.parentNode,K=l.useRef(null),X=l.useRef(!1),ee=l.useMemo(()=>{var e;return w&&"blending"!==w||Array.isArray(w)&&w.length&&(e=w[0])&&"object"==typeof e&&"current"in e},[w]);l.useLayoutEffect(()=>{let e=I.domElement;w&&"blending"===w?(e.style.zIndex=`${Math.floor(F[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)},[w]),l.useLayoutEffect(()=>{if(Y.current){let e=V.current=o.createRoot(U);if(H.updateMatrixWorld(),E)U.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{let e=k(Y.current,L,D);U.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return J&&(i?J.prepend(U):J.appendChild(U)),()=>{J&&J.removeChild(U),e.unmount()}}},[J,E]),l.useLayoutEffect(()=>{T&&(U.className=T)},[T]);let et=l.useMemo(()=>E?{position:"absolute",top:0,left:0,width:D.width,height:D.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:x?"translate3d(-50%,-50%,0)":"none",...g&&{top:-D.height/2,left:-D.width/2,width:D.width,height:D.height},...r},[r,x,g,D,E]),er=l.useMemo(()=>({position:"absolute",pointerEvents:j}),[j]);l.useLayoutEffect(()=>{var t,i;X.current=!1,E?null==(t=V.current)||t.render(l.createElement("div",{ref:G,style:et},l.createElement("div",{ref:Q,style:er},l.createElement("div",{ref:A,className:n,style:r,children:e})))):null==(i=V.current)||i.render(l.createElement("div",{ref:A,style:et,className:n,children:e}))});let en=l.useRef(!0);(0,c.D)(e=>{if(Y.current){L.updateMatrixWorld(),Y.current.updateWorldMatrix(!0,!1);let e=E?_.current:k(Y.current,L,D);if(E||Math.abs(Z.current-L.zoom)>t||Math.abs(_.current[0]-e[0])>t||Math.abs(_.current[1]-e[1])>t){var r;let t,n,i,a,l=(r=Y.current,t=u.setFromMatrixPosition(r.matrixWorld),n=d.setFromMatrixPosition(L.matrixWorld),i=t.sub(n),a=L.getWorldDirection(m),i.angleTo(a)>Math.PI/2),o=!1;ee&&(Array.isArray(w)?o=w.map(e=>e.current):"blending"!==w&&(o=[H]));let c=en.current;o?en.current=function(e,t,r,n){let i=u.setFromMatrixPosition(e.matrixWorld),a=i.clone();a.project(t),f.set(a.x,a.y),r.setFromCamera(f,t);let l=r.intersectObjects(n,!0);if(l.length){let e=l[0].distance;return i.distanceTo(r.ray.origin)<e}return!0}(Y.current,L,N,o)&&!l:en.current=!l,c!==en.current&&(C?C(!en.current):U.style.display=en.current?"block":"none");let h=Math.floor(F[0]/2),x=w?ee?[F[0],h]:[h-1,0]:F;if(U.style.zIndex=`${function(e,t,r){if(t instanceof s.ubm||t instanceof s.qUd){let n=u.setFromMatrixPosition(e.matrixWorld),i=d.setFromMatrixPosition(t.matrixWorld),a=n.distanceTo(i),l=(r[1]-r[0])/(t.far-t.near),o=r[1]-l*t.far;return Math.round(l*a+o)}}(Y.current,L,x)}`,E){let[e,t]=[D.width/2,D.height/2],r=L.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:i,left:a,bottom:l,right:o}=L,s=y(L.matrixWorldInverse),c=n?`scale(${r})translate(${p(-(o+a)/2)}px,${p((i+l)/2)}px)`:`translateZ(${r}px)`,u=Y.current.matrixWorld;b&&((u=L.matrixWorldInverse.clone().transpose().copyPosition(u).scale(Y.current.scale)).elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),U.style.width=D.width+"px",U.style.height=D.height+"px",U.style.perspective=n?"":`${r}px`,G.current&&Q.current&&(G.current.style.transform=`${c}${s}translate(${e}px,${t}px)`,Q.current.style.transform=v(u,1/((P||10)/400)))}else{let t=void 0===P?1:function(e,t){if(t instanceof s.qUd)return t.zoom;if(!(t instanceof s.ubm))return 1;{let r=u.setFromMatrixPosition(e.matrixWorld),n=d.setFromMatrixPosition(t.matrixWorld);return 1/(2*Math.tan(t.fov*Math.PI/180/2)*r.distanceTo(n))}}(Y.current,L)*P;U.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}_.current=e,Z.current=L.zoom}}if(!ee&&K.current&&!X.current)if(E){if(G.current){let e=G.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){let{isOrthographicCamera:t}=L;if(t||$)q.scale&&(Array.isArray(q.scale)?q.scale instanceof s.Pq0?K.current.scale.copy(q.scale.clone().divideScalar(1)):K.current.scale.set(1/q.scale[0],1/q.scale[1],1/q.scale[2]):K.current.scale.setScalar(1/q.scale));else{let t=(P||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;K.current.scale.set(r,n,1)}X.current=!0}}}else{let t=U.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){let e=1/O.factor,r=t.clientWidth*e,n=t.clientHeight*e;K.current.scale.set(r,n,1),X.current=!0}K.current.lookAt(e.camera.position)}});let ei=l.useMemo(()=>({vertexShader:E?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[E]);return l.createElement("group",(0,a.A)({},q,{ref:Y}),w&&!ee&&l.createElement("mesh",{castShadow:W,receiveShadow:R,ref:K},$||l.createElement("planeGeometry",null),S||l.createElement("shaderMaterial",{side:s.$EB,vertexShader:ei.vertexShader,fragmentShader:ei.fragmentShader})))})}}]);