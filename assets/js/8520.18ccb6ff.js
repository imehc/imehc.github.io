"use strict";(self.webpackChunkanch=self.webpackChunkanch||[]).push([["8520"],{95611(e,t,r){r.r(t),r.d(t,{computeMikkTSpaceTangents:()=>n,computeMorphedAttributes:()=>d,deepCloneAttribute:()=>u,deinterleaveAttribute:()=>a,deinterleaveGeometry:()=>f,estimateBytesUsed:()=>m,interleaveAttributes:()=>l,mergeAttributes:()=>s,mergeGeometries:()=>i,mergeGroups:()=>h,mergeVertices:()=>c,toCreasedNormals:()=>b,toTrianglesDrawMode:()=>g});var o=r(67199);function n(e,t,r=!0){if(!t||!t.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function i(e){if(e.normalized||e.isInterleavedBufferAttribute){let t=new Float32Array(e.count*e.itemSize);for(let r=0,o=0;r<e.count;r++)t[o++]=e.getX(r),t[o++]=e.getY(r),e.itemSize>2&&(t[o++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let s=e.index?e.toNonIndexed():e,u=t.generateTangents(i(s.attributes.position),i(s.attributes.normal),i(s.attributes.uv));if(r)for(let e=3;e<u.length;e+=4)u[e]*=-1;return s.setAttribute("tangent",new o.THS(u,4)),e!==s&&e.copy(s),e}function i(e,t=!1){let r=null!==e[0].index,n=new Set(Object.keys(e[0].attributes)),u=new Set(Object.keys(e[0].morphAttributes)),l={},a={},f=e[0].morphTargetsRelative,m=new o.LoY,c=0;for(let o=0;o<e.length;++o){let i=e[o],s=0;if(r!==(null!==i.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let e in i.attributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===l[e]&&(l[e]=[]),l[e].push(i.attributes[e]),s++}if(s!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(f!==i.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let e in i.morphAttributes){if(!u.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[e]&&(a[e]=[]),a[e].push(i.morphAttributes[e])}if(t){let e;if(r)e=i.index.count;else{if(void 0===i.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=i.attributes.position.count}m.addGroup(c,e,o),c+=e}}if(r){let t=0,r=[];for(let o=0;o<e.length;++o){let n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}m.setIndex(r)}for(let e in l){let t=s(l[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;m.setAttribute(e,t)}for(let e in a){let t=a[e][0].length;if(0===t)break;m.morphAttributes=m.morphAttributes||{},m.morphAttributes[e]=[];for(let r=0;r<t;++r){let t=[];for(let o=0;o<a[e].length;++o)t.push(a[e][o][r]);let o=s(t);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;m.morphAttributes[e].push(o)}}return m}function s(e){let t,r,n,i=-1,s=0;for(let o=0;o<e.length;++o){let u=e[o];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=u.itemSize),r!==u.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=u.normalized),n!==u.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===i&&(i=u.gpuType),i!==u.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;s+=u.count*r}let u=new t(s),l=new o.THS(u,r,n),a=0;for(let t=0;t<e.length;++t){let o=e[t];if(o.isInterleavedBufferAttribute){let e=a/r;for(let t=0,n=o.count;t<n;t++)for(let n=0;n<r;n++){let r=o.getComponent(t,n);l.setComponent(t+e,n,r)}}else u.set(o.array,a);a+=o.count*r}return void 0!==i&&(l.gpuType=i),l}function u(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?a(e):e.isInstancedBufferAttribute?new o.uWO().copy(e):new o.THS().copy(e)}function l(e){let t,r=0,n=0;for(let o=0,i=e.length;o<i;++o){let i=e[o];if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,n+=i.itemSize}let i=new o.eB$(new t(r),n),s=0,u=[],l=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let t=0,r=e.length;t<r;t++){let r=e[t],n=r.itemSize,f=r.count,m=new o.eHs(i,n,s,r.normalized);u.push(m),s+=n;for(let e=0;e<f;e++)for(let t=0;t<n;t++)m[a[t]](e,r[l[t]](e))}return u}function a(e){let t,r=e.data.array.constructor,n=e.count,i=e.itemSize,s=e.normalized,u=new r(n*i);t=e.isInstancedInterleavedBufferAttribute?new o.uWO(u,i,s,e.meshPerAttribute):new o.THS(u,i,s);for(let r=0;r<n;r++)t.setX(r,e.getX(r)),i>=2&&t.setY(r,e.getY(r)),i>=3&&t.setZ(r,e.getZ(r)),i>=4&&t.setW(r,e.getW(r));return t}function f(e){let t=e.attributes,r=e.morphTargets,o=new Map;for(let e in t){let r=t[e];r.isInterleavedBufferAttribute&&(o.has(r)||o.set(r,a(r)),t[e]=o.get(r))}for(let e in r){let t=r[e];t.isInterleavedBufferAttribute&&(o.has(t)||o.set(t,a(t)),r[e]=o.get(t))}}function m(e){let t=0;for(let r in e.attributes){let o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}let r=e.getIndex();return t+(r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0)}function c(e,t=1e-4){t=Math.max(t,Number.EPSILON);let r={},o=e.getIndex(),n=e.getAttribute("position"),i=o?o.count:n.count,s=0,u=Object.keys(e.attributes),l={},a={},f=[],m=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"];for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.attributes[r];l[r]=new o.constructor(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);let n=e.morphAttributes[r];n&&(a[r]||(a[r]=[]),n.forEach((e,t)=>{let o=new e.array.constructor(e.count*e.itemSize);a[r][t]=new e.constructor(o,e.itemSize,e.normalized)}))}let d=.5*t,h=Math.pow(10,Math.log10(1/t)),b=d*h;for(let t=0;t<i;t++){let n=o?o.getX(t):t,i="";for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.getAttribute(r),s=o.itemSize;for(let e=0;e<s;e++)i+=`${~~(o[m[e]](n)*h+b)},`}if(i in r)f.push(r[i]);else{for(let t=0,r=u.length;t<r;t++){let r=u[t],o=e.getAttribute(r),i=e.morphAttributes[r],f=o.itemSize,c=l[r],d=a[r];for(let e=0;e<f;e++){let t=m[e],r=g[e];if(c[r](s,o[t](n)),i)for(let e=0,o=i.length;e<o;e++)d[e][r](s,i[e][t](n))}}r[i]=s,f.push(s),s++}}let p=e.clone();for(let t in e.attributes){let e=l[t];if(p.setAttribute(t,new e.constructor(e.array.slice(0,s*e.itemSize),e.itemSize,e.normalized)),t in a)for(let e=0;e<a[t].length;e++){let r=a[t][e];p.morphAttributes[t][e]=new r.constructor(r.array.slice(0,s*r.itemSize),r.itemSize,r.normalized)}}return p.setIndex(f),p}function g(e,t){if(t===o.RJ4)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t!==o.rYR&&t!==o.O49)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e;{let r=e.getIndex();if(null===r){let t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}let n=r.count-2,i=[];if(t===o.rYR)for(let e=1;e<=n;e++)i.push(r.getX(0)),i.push(r.getX(e)),i.push(r.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(i.push(r.getX(e)),i.push(r.getX(e+1)),i.push(r.getX(e+2))):(i.push(r.getX(e+2)),i.push(r.getX(e+1)),i.push(r.getX(e)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let s=e.clone();return s.setIndex(i),s.clearGroups(),s}}function d(e){let t,r,n,i,s,u,l,a,f,m,c=new o.Pq0,g=new o.Pq0,d=new o.Pq0,h=new o.Pq0,b=new o.Pq0,p=new o.Pq0,y=new o.Pq0,A=new o.Pq0,w=new o.Pq0;function B(e,t,r,o,n,i,s,u){c.fromBufferAttribute(t,n),g.fromBufferAttribute(t,i),d.fromBufferAttribute(t,s);let l=e.morphTargetInfluences;if(r&&l){y.set(0,0,0),A.set(0,0,0),w.set(0,0,0);for(let e=0,t=r.length;e<t;e++){let t=l[e],u=r[e];0!==t&&(h.fromBufferAttribute(u,n),b.fromBufferAttribute(u,i),p.fromBufferAttribute(u,s),o?(y.addScaledVector(h,t),A.addScaledVector(b,t),w.addScaledVector(p,t)):(y.addScaledVector(h.sub(c),t),A.addScaledVector(b.sub(g),t),w.addScaledVector(p.sub(d),t)))}c.add(y),g.add(A),d.add(w)}e.isSkinnedMesh&&(e.applyBoneTransform(n,c),e.applyBoneTransform(i,g),e.applyBoneTransform(s,d)),u[3*n+0]=c.x,u[3*n+1]=c.y,u[3*n+2]=c.z,u[3*i+0]=g.x,u[3*i+1]=g.y,u[3*i+2]=g.z,u[3*s+0]=d.x,u[3*s+1]=d.y,u[3*s+2]=d.z}let T=e.geometry,E=e.material,x=T.index,z=T.attributes.position,S=T.morphAttributes.position,G=T.morphTargetsRelative,I=T.attributes.normal,v=T.morphAttributes.position,R=T.groups,M=T.drawRange,X=new Float32Array(z.count*z.itemSize),P=new Float32Array(I.count*I.itemSize);if(null!==x)if(Array.isArray(E))for(i=0,u=R.length;i<u;i++)for(f=Math.max((a=R[i]).start,M.start),m=Math.min(a.start+a.count,M.start+M.count),s=f,l=m;s<l;s+=3)t=x.getX(s),B(e,z,S,G,t,r=x.getX(s+1),n=x.getX(s+2),X),B(e,I,v,G,t,r,n,P);else for(f=Math.max(0,M.start),m=Math.min(x.count,M.start+M.count),i=f,u=m;i<u;i+=3)t=x.getX(i),B(e,z,S,G,t,r=x.getX(i+1),n=x.getX(i+2),X),B(e,I,v,G,t,r,n,P);else if(Array.isArray(E))for(i=0,u=R.length;i<u;i++)for(f=Math.max((a=R[i]).start,M.start),m=Math.min(a.start+a.count,M.start+M.count),s=f,l=m;s<l;s+=3)B(e,z,S,G,t=s,r=s+1,n=s+2,X),B(e,I,v,G,t,r,n,P);else for(f=Math.max(0,M.start),m=Math.min(z.count,M.start+M.count),i=f,u=m;i<u;i+=3)B(e,z,S,G,t=i,r=i+1,n=i+2,X),B(e,I,v,G,t,r,n,P);return{positionAttribute:z,normalAttribute:I,morphedPositionAttribute:new o.qtW(X,3),morphedNormalAttribute:new o.qtW(P,3)}}function h(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start),null===e.getIndex()){let t=e.getAttribute("position"),r=[];for(let e=0;e<t.count;e+=3)r.push(e,e+1,e+2);e.setIndex(r)}let r=e.getIndex(),o=[];for(let e=0;e<t.length;e++){let n=t[e],i=n.start,s=i+n.count;for(let e=i;e<s;e++)o.push(r.getX(e))}e.dispose(),e.setIndex(o);let n=0;for(let e=0;e<t.length;e++){let r=t[e];r.start=n,n+=r.count}let i=t[0];e.groups=[i];for(let r=1;r<t.length;r++){let o=t[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,e.groups.push(i))}return e}function b(e,t=Math.PI/3){let r=Math.cos(t),n=(1+1e-10)*100,i=[new o.Pq0,new o.Pq0,new o.Pq0],s=new o.Pq0,u=new o.Pq0,l=new o.Pq0,a=new o.Pq0;function f(e){let t=~~(e.x*n),r=~~(e.y*n),o=~~(e.z*n);return`${t},${r},${o}`}let m=e.index?e.toNonIndexed():e,c=m.attributes.position,g={};for(let e=0,t=c.count/3;e<t;e++){let t=3*e,r=i[0].fromBufferAttribute(c,t+0),n=i[1].fromBufferAttribute(c,t+1),l=i[2].fromBufferAttribute(c,t+2);s.subVectors(l,n),u.subVectors(r,n);let a=new o.Pq0().crossVectors(s,u).normalize();for(let e=0;e<3;e++){let t=f(i[e]);t in g||(g[t]=[]),g[t].push(a)}}let d=new Float32Array(3*c.count),h=new o.THS(d,3,!1);for(let e=0,t=c.count/3;e<t;e++){let t=3*e,o=i[0].fromBufferAttribute(c,t+0),n=i[1].fromBufferAttribute(c,t+1),m=i[2].fromBufferAttribute(c,t+2);s.subVectors(m,n),u.subVectors(o,n),l.crossVectors(s,u).normalize();for(let e=0;e<3;e++){let o=g[f(i[e])];a.set(0,0,0);for(let e=0,t=o.length;e<t;e++){let t=o[e];l.dot(t)>r&&a.add(t)}a.normalize(),h.setXYZ(t+e,a.x,a.y,a.z)}}return m.setAttribute("normal",h),m}}}]);