import{a as t}from"./chunk-MLG2LQS6.js";import{a as e}from"./chunk-SYTPJOV4.js";import{a as i}from"./chunk-YJI7JXLA.js";import{a as o}from"./chunk-IBQZCWHF.js";import{a as r}from"./chunk-ZXZD7KWX.js";import{a as n}from"./chunk-KSX6TRAS.js";import{a as a}from"./chunk-GMTHOMGW.js";import{b as s,c as l,d as u}from"./chunk-BELR52CD.js";import{a as m,c as c}from"./chunk-BNHFHP3L.js";import{h as p,j as h}from"./chunk-4NDD6KRQ.js";import{a as f}from"./chunk-N6BI774S.js";import{a as d,b as y,c as A}from"./chunk-ICY67TC6.js";import{a as x,b as g,c as _}from"./chunk-G2EMNOST.js";import{a as w}from"./chunk-4VFKVGYI.js";import{a as b,b as M}from"./chunk-3WJNS2B6.js";import{e as v}from"./chunk-XCN226AA.js";var T=new x,P=new x,j=new x,E=new x,O=new y,S=new g,N=new g,F=new p,k=new x,L=new x,R=new x,D=new d,I=new x,z=new y,B=new y;function V(e,i,r){let n=i.vertexFormat,s=i.center,l=i.semiMajorAxis,c=i.semiMinorAxis,h=i.ellipsoid,d=i.stRotation,A=r?e.length/3*2:e.length/3,_=i.shadowVolume,w=n.st?new Float32Array(2*A):void 0,b=n.normal?new Float32Array(3*A):void 0,M=n.tangent?new Float32Array(3*A):void 0,E=n.bitangent?new Float32Array(3*A):void 0,V=_?new Float32Array(3*A):void 0,G=0,C=k,H=L,Y=R,U=new m(h),J=U.project(h.cartesianToCartographic(s,D),I),Q=h.scaleToGeodeticSurface(s,T);h.geodeticSurfaceNormal(Q,Q);let W=S,X=N;if(0!==d){let t=p.fromAxisAngle(Q,d,F);W=g.fromQuaternion(t,W),t=p.fromAxisAngle(Q,-d,F),X=g.fromQuaternion(t,X)}else W=g.clone(g.IDENTITY,W),X=g.clone(g.IDENTITY,X);let K=y.fromElements(1/0,1/0,z),Z=y.fromElements(-1/0,-1/0,B),q=e.length,$=r?q:0,tt=$/3*2;for(let t=0;t<q;t+=3){let i=t+1,o=t+2,a=x.fromArray(e,t,T);if(n.st){let t=g.multiplyByVector(W,a,P),e=U.project(h.cartesianToCartographic(t,D),j);x.subtract(e,J,e),O.x=(e.x+l)/(2*l),O.y=(e.y+c)/(2*c),K.x=Math.min(O.x,K.x),K.y=Math.min(O.y,K.y),Z.x=Math.max(O.x,Z.x),Z.y=Math.max(O.y,Z.y),r&&(w[G+tt]=O.x,w[G+1+tt]=O.y),w[G++]=O.x,w[G++]=O.y}(n.normal||n.tangent||n.bitangent||_)&&(C=h.geodeticSurfaceNormal(a,C),_&&(V[t+$]=-C.x,V[i+$]=-C.y,V[o+$]=-C.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(H=x.normalize(x.cross(x.UNIT_Z,C,H),H),g.multiplyByVector(X,H,H)),n.normal&&(b[t]=C.x,b[i]=C.y,b[o]=C.z,r&&(b[t+$]=-C.x,b[i+$]=-C.y,b[o+$]=-C.z)),n.tangent&&(M[t]=H.x,M[i]=H.y,M[o]=H.z,r&&(M[t+$]=-H.x,M[i+$]=-H.y,M[o+$]=-H.z)),n.bitangent&&(Y=x.normalize(x.cross(C,H,Y),Y),E[t]=Y.x,E[i]=Y.y,E[o]=Y.z,r&&(E[t+$]=Y.x,E[i+$]=Y.y,E[o+$]=Y.z))))}if(n.st){q=w.length;for(let t=0;t<q;t+=2)w[t]=(w[t]-K.x)/(Z.x-K.x),w[t+1]=(w[t+1]-K.y)/(Z.y-K.y)}let te=new a;if(n.position){let o=t.raisePositionsToHeight(e,i,r);te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:o})}if(n.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),n.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),n.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),n.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:E})),_&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:V})),r&&v(i.offsetAttribute)){let t=new Uint8Array(A);if(i.offsetAttribute===o.TOP)t=t.fill(1,0,A/2);else{let e=+(i.offsetAttribute!==o.NONE);t=t.fill(e)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}function G(t){let e=Array(t*(t+1)*12-6),i=0,o,r,n,a,s;for(o=0,n=1,a=0;a<3;a++)e[i++]=n++,e[i++]=o,e[i++]=n;for(a=2;a<t+1;++a){for(n=a*(a+1)-1,o=(a-1)*a-1,e[i++]=n++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=n++,e[i++]=o,e[i++]=n}for(r=2*t,++n,++o,a=0;a<r-1;++a)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;for(e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o++,e[i++]=o,++o,a=t-1;a>1;--a){for(e[i++]=o++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=o++,e[i++]=o++,e[i++]=n++}for(a=0;a<3;a++)e[i++]=o++,e[i++]=o,e[i++]=n;return e}var C=new x,H=new c,Y=new c;function U(e,i,o,r,n,a,s){let l=t.computeEllipsePositions({center:e,semiMajorAxis:i,semiMinorAxis:o,rotation:r,granularity:n},!1,!0).outerPositions,u=l.length/3,m=Array(u);for(let t=0;t<u;++t)m[t]=x.fromArray(l,3*t);let c=h.fromCartesianArray(m,a,s);return c.width>w.PI&&(c.north=c.north>0?w.PI_OVER_TWO-w.EPSILON7:c.north,c.south=c.south<0?w.EPSILON7-w.PI_OVER_TWO:c.south,c.east=w.PI,c.west=-w.PI),c}function J(t){let e=(t=t??_.EMPTY_OBJECT).center,i=t.ellipsoid??A.default,o=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.vertexFormat??r.DEFAULT;if(M.defined("options.center",e),M.typeOf.number("options.semiMajorAxis",o),M.typeOf.number("options.semiMinorAxis",n),o<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");let l=t.height??0,u=t.extrudedHeight??l;this._center=x.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=n,this._ellipsoid=A.clone(i),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._height=Math.max(u,l),this._granularity=a,this._vertexFormat=r.clone(s),this._extrudedHeight=Math.min(u,l),this._shadowVolume=t.shadowVolume??!1,this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}J.packedLength=x.packedLength+A.packedLength+r.packedLength+9,J.pack=function(t,e,i){return M.defined("value",t),M.defined("array",e),i=i??0,x.pack(t._center,e,i),i+=x.packedLength,A.pack(t._ellipsoid,e,i),i+=A.packedLength,r.pack(t._vertexFormat,e,i),i+=r.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=+!!t._shadowVolume,e[i]=t._offsetAttribute??-1,e};var Q=new x,W=new A,X=new r,K={center:Q,ellipsoid:W,vertexFormat:X,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};J.unpack=function(t,e,i){M.defined("array",t),e=e??0;let o=x.unpack(t,e,Q);e+=x.packedLength;let n=A.unpack(t,e,W);e+=A.packedLength;let a=r.unpack(t,e,X);e+=r.packedLength;let s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],h=t[e++],f=1===t[e++],d=t[e];return v(i)?(i._center=x.clone(o,i._center),i._ellipsoid=A.clone(n,i._ellipsoid),i._vertexFormat=r.clone(a,i._vertexFormat),i._semiMajorAxis=s,i._semiMinorAxis=l,i._rotation=u,i._stRotation=m,i._height=c,i._granularity=p,i._extrudedHeight=h,i._shadowVolume=f,i._offsetAttribute=-1===d?void 0:d,i):(K.height=c,K.extrudedHeight=h,K.granularity=p,K.stRotation=m,K.rotation=u,K.semiMajorAxis=s,K.semiMinorAxis=l,K.shadowVolume=f,K.offsetAttribute=-1===d?void 0:d,new J(K))},J.computeRectangle=function(t,e){let i=(t=t??_.EMPTY_OBJECT).center,o=t.ellipsoid??A.default,r=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.rotation??0;if(M.defined("options.center",i),M.typeOf.number("options.semiMajorAxis",r),M.typeOf.number("options.semiMinorAxis",n),r<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");return U(i,r,n,s,a,o,e)},J.createGeometry=function(r){if(r._semiMajorAxis<=0||r._semiMinorAxis<=0)return;let h=r._height,d=r._extrudedHeight,A=!w.equalsEpsilon(h,d,0,w.EPSILON2);r._center=r._ellipsoid.scaleToGeodeticSurface(r._center,r._center);let _={center:r._center,semiMajorAxis:r._semiMajorAxis,semiMinorAxis:r._semiMinorAxis,ellipsoid:r._ellipsoid,rotation:r._rotation,height:h,granularity:r._granularity,vertexFormat:r._vertexFormat,stRotation:r._stRotation},b;if(A)_.extrudedHeight=d,_.shadowVolume=r._shadowVolume,_.offsetAttribute=r._offsetAttribute,b=function(r){let h=r.center,d=r.ellipsoid,A=r.semiMajorAxis,_=x.multiplyByScalar(d.geodeticSurfaceNormal(h,T),r.height,T);H.center=x.add(h,_,H.center),H.radius=A,_=x.multiplyByScalar(d.geodeticSurfaceNormal(h,_),r.extrudedHeight,_),Y.center=x.add(h,_,Y.center),Y.radius=A;let w=t.computeEllipsePositions(r,!0,!0),b=w.positions,M=w.numPts,N=w.outerPositions,C=c.union(H,Y),U=V(b,r,!0),J=G(M),Q=J.length;J.length=2*Q;let W=b.length/3;for(let t=0;t<Q;t+=3)J[t+Q]=J[t+2]+W,J[t+1+Q]=J[t+1]+W,J[t+2+Q]=J[t]+W;let X=new l({attributes:U,indices:n.createTypedArray(2*W/3,J),primitiveType:s.TRIANGLES}),K=function(t,e){let i=e.vertexFormat,r=e.center,n=e.semiMajorAxis,s=e.semiMinorAxis,l=e.ellipsoid,c=e.height,h=e.extrudedHeight,d=e.stRotation,A=t.length/3*2,_=new Float64Array(3*A),w=i.st?new Float32Array(2*A):void 0,b=i.normal?new Float32Array(3*A):void 0,M=i.tangent?new Float32Array(3*A):void 0,N=i.bitangent?new Float32Array(3*A):void 0,V=e.shadowVolume,G=V?new Float32Array(3*A):void 0,C=0,H=k,Y=L,U=R,J=new m(l),Q=J.project(l.cartesianToCartographic(r,D),I),W=l.scaleToGeodeticSurface(r,T);l.geodeticSurfaceNormal(W,W);let X=p.fromAxisAngle(W,d,F),K=g.fromQuaternion(X,S),Z=y.fromElements(1/0,1/0,z),q=y.fromElements(-1/0,-1/0,B),$=t.length,tt=$/3*2;for(let e=0;e<$;e+=3){let o=e+1,r=e+2,a=x.fromArray(t,e,T),u;if(i.st){let t=g.multiplyByVector(K,a,P),e=J.project(l.cartesianToCartographic(t,D),j);x.subtract(e,Q,e),O.x=(e.x+n)/(2*n),O.y=(e.y+s)/(2*s),Z.x=Math.min(O.x,Z.x),Z.y=Math.min(O.y,Z.y),q.x=Math.max(O.x,q.x),q.y=Math.max(O.y,q.y),w[C+tt]=O.x,w[C+1+tt]=O.y,w[C++]=O.x,w[C++]=O.y}a=l.scaleToGeodeticSurface(a,a),u=x.clone(a,P),H=l.geodeticSurfaceNormal(a,H),V&&(G[e+$]=-H.x,G[o+$]=-H.y,G[r+$]=-H.z);let m=x.multiplyByScalar(H,c,E);if(a=x.add(a,m,a),m=x.multiplyByScalar(H,h,m),u=x.add(u,m,u),i.position&&(_[e+$]=u.x,_[o+$]=u.y,_[r+$]=u.z,_[e]=a.x,_[o]=a.y,_[r]=a.z),i.normal||i.tangent||i.bitangent){U=x.clone(H,U);let n=x.fromArray(t,(e+3)%$,E);x.subtract(n,a,n);let s=x.subtract(u,a,j);H=x.normalize(x.cross(s,n,H),H),i.normal&&(b[e]=H.x,b[o]=H.y,b[r]=H.z,b[e+$]=H.x,b[o+$]=H.y,b[r+$]=H.z),i.tangent&&(Y=x.normalize(x.cross(U,H,Y),Y),M[e]=Y.x,M[o]=Y.y,M[r]=Y.z,M[e+$]=Y.x,M[e+1+$]=Y.y,M[e+2+$]=Y.z),i.bitangent&&(N[e]=U.x,N[o]=U.y,N[r]=U.z,N[e+$]=U.x,N[o+$]=U.y,N[r+$]=U.z)}}if(i.st){$=w.length;for(let t=0;t<$;t+=2)w[t]=(w[t]-Z.x)/(q.x-Z.x),w[t+1]=(w[t+1]-Z.y)/(q.y-Z.y)}let te=new a;if(i.position&&(te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:_})),i.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),i.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),i.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),i.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:N})),V&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:G})),v(e.offsetAttribute)){let t=new Uint8Array(A);if(e.offsetAttribute===o.TOP)t=t.fill(1,0,A/2);else{let i=+(e.offsetAttribute!==o.NONE);t=t.fill(i)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}(N,r);J=function(t){let e=t.length/3,i=n.createTypedArray(e,6*e),o=0;for(let t=0;t<e;t++){let r=t,n=t+e,a=(r+1)%e,s=a+e;i[o++]=r,i[o++]=n,i[o++]=a,i[o++]=a,i[o++]=n,i[o++]=s}return i}(N);let Z=new l({attributes:K,indices:n.createTypedArray(2*N.length/3,J),primitiveType:s.TRIANGLES}),q=i.combineInstances([new e({geometry:X}),new e({geometry:Z})]);return{boundingSphere:C,attributes:q[0].attributes,indices:q[0].indices}}(_);else{let e,i,a,s,l,m,p;if(e=_.center,C=x.multiplyByScalar(_.ellipsoid.geodeticSurfaceNormal(e,C),_.height,C),i=new c(C=x.add(e,C,C),_.semiMajorAxis),s=(a=t.computeEllipsePositions(_,!0,!1)).positions,l=a.numPts,m=V(s,_,!1),p=G(l),b={boundingSphere:i,attributes:m,indices:p=n.createTypedArray(s.length/3,p)},v(r._offsetAttribute)){let t=b.attributes.position.values.length,e=+(r._offsetAttribute!==o.NONE),i=new Uint8Array(t/3).fill(e);b.attributes.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}return new l({attributes:b.attributes,indices:b.indices,primitiveType:s.TRIANGLES,boundingSphere:b.boundingSphere,offsetAttribute:r._offsetAttribute})},J.createShadowVolume=function(t,e,i){let o=t._granularity,n=t._ellipsoid,a=e(o,n),s=i(o,n);return new J({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:o,extrudedHeight:a,height:s,vertexFormat:r.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return v(this._rectangle)||(this._rectangle=U(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return v(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){let i=-e._stRotation;if(0===i)return[0,0,0,1,1,0];let o=t.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=o.length/3,n=Array(r);for(let t=0;t<r;++t)n[t]=x.fromArray(o,3*t);let a=e._ellipsoid,s=e.rectangle;return l._textureCoordinateRotationPoints(n,i,a,s)}(this)),this._textureCoordinateRotationPoints}}});var Z=J;export{Z as a};