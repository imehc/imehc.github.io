import{h as t,i as e,j as n,k as i}from"./chunk-4NDD6KRQ.js";import{b as r}from"./chunk-5ELDAYCN.js";import{a as o}from"./chunk-TI35VBH7.js";import{a as s,b as a}from"./chunk-ICY67TC6.js";import{a as u,b as m,c as p}from"./chunk-G2EMNOST.js";import{a as N,b as c}from"./chunk-3WJNS2B6.js";import{e as I}from"./chunk-XCN226AA.js";var h=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3}),l={POINTS:o.POINTS,LINES:o.LINES,LINE_LOOP:o.LINE_LOOP,LINE_STRIP:o.LINE_STRIP,TRIANGLES:o.TRIANGLES,TRIANGLE_STRIP:o.TRIANGLE_STRIP,TRIANGLE_FAN:o.TRIANGLE_FAN};l.isLines=function(t){return t===l.LINES||t===l.LINE_LOOP||t===l.LINE_STRIP},l.isTriangles=function(t){return t===l.TRIANGLES||t===l.TRIANGLE_STRIP||t===l.TRIANGLE_FAN},l.validate=function(t){return t===l.POINTS||t===l.LINES||t===l.LINE_LOOP||t===l.LINE_STRIP||t===l.TRIANGLES||t===l.TRIANGLE_STRIP||t===l.TRIANGLE_FAN};var T=Object.freeze(l);function b(t){t=t??p.EMPTY_OBJECT,c.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=t.primitiveType??T.TRIANGLES,this.boundingSphere=t.boundingSphere,this.geometryType=t.geometryType??h.NONE,this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}b.computeNumberOfVertices=function(t){c.typeOf.object("geometry",t);let e=-1;for(let n in t.attributes)if(t.attributes.hasOwnProperty(n)&&I(t.attributes[n])&&I(t.attributes[n].values)){let i=t.attributes[n],r=i.values.length/i.componentsPerAttribute;if(e!==r&&-1!==e)throw new N("All attribute lists must have the same number of attributes.");e=r}return e};var f=new s,A=new u,E=new r,L=[new s,new s,new s],y=[new a,new a,new a],w=[new a,new a,new a],P=new u,S=new t,R=new r,O=new i;b._textureCoordinateRotationPoints=function(o,p,N,c){let I,h=n.center(c,f),l=s.toCartesian(h,N,A),T=e.eastNorthUpToFixedFrame(l,N,E),b=r.inverse(T,E);L[0].longitude=c.west,L[0].latitude=c.south,L[1].longitude=c.west,L[1].latitude=c.north,L[2].longitude=c.east,L[2].latitude=c.south;let d=P;for(I=0;I<3;I++)s.toCartesian(L[I],N,d),d=r.multiplyByPointAsVector(b,d,d),y[I].x=d.x,y[I].y=d.y;let _=t.fromAxisAngle(u.UNIT_Z,-p,S),x=m.fromQuaternion(_,R),v=o.length,G=1/0,g=1/0,j=-1/0,k=-1/0;for(I=0;I<v;I++)d=r.multiplyByPointAsVector(b,o[I],d),G=Math.min(G,(d=m.multiplyByVector(x,d,d)).x),g=Math.min(g,d.y),j=Math.max(j,d.x),k=Math.max(k,d.y);let C=i.fromRotation(p,O);w[0].x=G,w[0].y=g,w[1].x=G,w[1].y=k,w[2].x=j,w[2].y=g;let B=y[0],M=y[2].x-B.x,V=y[1].y-B.y;for(I=0;I<3;I++){let t=w[I];i.multiplyByVector(C,t,t),t.x=(t.x-B.x)/M,t.y=(t.y-B.y)/V}let D=w[0],F=w[1],Y=w[2],z=Array(6);return a.pack(D,z),a.pack(F,z,2),a.pack(Y,z,4),z};var d=b,_=function(t){if(!I((t=t??p.EMPTY_OBJECT).componentDatatype))throw new N("options.componentDatatype is required.");if(!I(t.componentsPerAttribute))throw new N("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new N("options.componentsPerAttribute must be between 1 and 4.");if(!I(t.values))throw new N("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=t.normalize??!1,this.values=t.values};export{h as a,T as b,d as c,_ as d};