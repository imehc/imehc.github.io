import{a as i}from"./chunk-MABAS5D2.js";import{a as t}from"./chunk-GSMLTRAL.js";import{a as o}from"./chunk-IUX576XK.js";import{b as e,c as r,d as n}from"./chunk-UIGT6VOJ.js";import{c as a}from"./chunk-XO2FNJZK.js";import{a as s}from"./chunk-KXT7EZPS.js";import{c as m}from"./chunk-KCR7AORG.js";import{a as u,c as f}from"./chunk-QDJTHWTA.js";import{a as c}from"./chunk-2YWR3G22.js";import{a as l}from"./chunk-HTSQLHXI.js";import{e as h}from"./chunk-JDAHMWM5.js";var d=new u(1,1,1),_=Math.cos,k=Math.sin;function p(t){let o=(t=t??f.EMPTY_OBJECT).radii??d,e=t.innerRadii??o,r=t.minimumClock??0,n=t.maximumClock??c.TWO_PI,a=t.minimumCone??0,s=t.maximumCone??c.PI,m=Math.round(t.stackPartitions??10),_=Math.round(t.slicePartitions??8),k=Math.round(t.subdivisions??128);if(m<1)throw new l("options.stackPartitions cannot be less than 1");if(_<0)throw new l("options.slicePartitions cannot be less than 0");if(k<0)throw new l("options.subdivisions must be greater than or equal to zero.");if(h(t.offsetAttribute)&&t.offsetAttribute===i.TOP)throw new l("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=u.clone(o),this._innerRadii=u.clone(e),this._minimumClock=r,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=m,this._slicePartitions=_,this._subdivisions=k,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*u.packedLength+8,p.pack=function(i,t,o){if(!h(i))throw new l("value is required");if(!h(t))throw new l("array is required");return o=o??0,u.pack(i._radii,t,o),o+=u.packedLength,u.pack(i._innerRadii,t,o),o+=u.packedLength,t[o++]=i._minimumClock,t[o++]=i._maximumClock,t[o++]=i._minimumCone,t[o++]=i._maximumCone,t[o++]=i._stackPartitions,t[o++]=i._slicePartitions,t[o++]=i._subdivisions,t[o]=i._offsetAttribute??-1,t};var b=new u,C=new u,A={radii:b,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(i,t,o){if(!h(i))throw new l("array is required");t=t??0;let e=u.unpack(i,t,b);t+=u.packedLength;let r=u.unpack(i,t,C);t+=u.packedLength;let n=i[t++],a=i[t++],s=i[t++],m=i[t++],f=i[t++],c=i[t++],d=i[t++],_=i[t];return h(o)?(o._radii=u.clone(e,o._radii),o._innerRadii=u.clone(r,o._innerRadii),o._minimumClock=n,o._maximumClock=a,o._minimumCone=s,o._maximumCone=m,o._stackPartitions=f,o._slicePartitions=c,o._subdivisions=d,o._offsetAttribute=-1===_?void 0:_,o):(A.minimumClock=n,A.maximumClock=a,A.minimumCone=s,A.maximumCone=m,A.stackPartitions=f,A.slicePartitions=c,A.subdivisions=d,A.offsetAttribute=-1===_?void 0:_,new p(A))},p.createGeometry=function(u){let f=u._radii;if(f.x<=0||f.y<=0||f.z<=0)return;let l=u._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;let d=u._minimumClock,p=u._maximumClock,b=u._minimumCone,C=u._maximumCone,A=u._subdivisions,P=m.fromCartesian3(f),y=u._slicePartitions+1,v=u._stackPartitions+1;y=Math.round(y*Math.abs(p-d)/c.TWO_PI),v=Math.round(v*Math.abs(C-b)/c.PI),y<2&&(y=2),v<2&&(v=2);let w=0,x=1,M=l.x!==f.x||l.y!==f.y||l.z!==f.z,T=!1,g=!1;M&&(x=2,b>0&&(T=!0,w+=y),C<Math.PI&&(g=!0,w+=y));let O=A*x*(v+y),j=new Float64Array(3*O),L=2*(O+w-(y+v)*x),R=t.createTypedArray(O,L),E,I,z,G,D=0,N=Array(v),S=Array(v);for(E=0;E<v;E++)G=b+E*(C-b)/(v-1),N[E]=k(G),S[E]=_(G);let J=Array(A),U=Array(A);for(E=0;E<A;E++)z=d+E*(p-d)/(A-1),J[E]=k(z),U[E]=_(z);for(E=0;E<v;E++)for(I=0;I<A;I++)j[D++]=f.x*N[E]*U[I],j[D++]=f.y*N[E]*J[I],j[D++]=f.z*S[E];if(M)for(E=0;E<v;E++)for(I=0;I<A;I++)j[D++]=l.x*N[E]*U[I],j[D++]=l.y*N[E]*J[I],j[D++]=l.z*S[E];for(N.length=A,S.length=A,E=0;E<A;E++)G=b+E*(C-b)/(A-1),N[E]=k(G),S[E]=_(G);for(J.length=y,U.length=y,E=0;E<y;E++)z=d+E*(p-d)/(y-1),J[E]=k(z),U[E]=_(z);for(E=0;E<A;E++)for(I=0;I<y;I++)j[D++]=f.x*N[E]*U[I],j[D++]=f.y*N[E]*J[I],j[D++]=f.z*S[E];if(M)for(E=0;E<A;E++)for(I=0;I<y;I++)j[D++]=l.x*N[E]*U[I],j[D++]=l.y*N[E]*J[I],j[D++]=l.z*S[E];for(D=0,E=0;E<v*x;E++){let i=E*A;for(I=0;I<A-1;I++)R[D++]=i+I,R[D++]=i+I+1}let W=v*A*x;for(E=0;E<y;E++)for(I=0;I<A-1;I++)R[D++]=W+E+I*y,R[D++]=W+E+(I+1)*y;if(M)for(W=v*A*x+y*A,E=0;E<y;E++)for(I=0;I<A-1;I++)R[D++]=W+E+I*y,R[D++]=W+E+(I+1)*y;if(M){let i=v*A*x,t=i+A*y;if(T)for(E=0;E<y;E++)R[D++]=i+E,R[D++]=t+E;if(g)for(i+=A*y-y,t+=A*y-y,E=0;E<y;E++)R[D++]=i+E,R[D++]=t+E}let X=new o({position:new n({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:j})});if(h(u._offsetAttribute)){let t=j.length,o=+(u._offsetAttribute!==i.NONE),e=new Uint8Array(t/3).fill(o);X.applyOffset=new n({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new r({attributes:X,indices:R,primitiveType:e.LINES,boundingSphere:a.fromEllipsoid(P),offsetAttribute:u._offsetAttribute})};var P=p;export{P as a};