import{a as e}from"./chunk-VO22SP3V.js";import{a as t}from"./chunk-MABAS5D2.js";import{a as i}from"./chunk-GSMLTRAL.js";import{a as r}from"./chunk-IUX576XK.js";import{b as n,c as o,d as s}from"./chunk-UIGT6VOJ.js";import{c as a}from"./chunk-XO2FNJZK.js";import{a as u}from"./chunk-KXT7EZPS.js";import{c as l}from"./chunk-KCR7AORG.js";import{a as c,c as f}from"./chunk-QDJTHWTA.js";import{a as h}from"./chunk-2YWR3G22.js";import{a as m}from"./chunk-HTSQLHXI.js";import{e as d}from"./chunk-JDAHMWM5.js";var p=new c,_=new c,A=new a,g=new a;function b(e){let t=(e=e??f.EMPTY_OBJECT).center,i=e.ellipsoid??l.default,r=e.semiMajorAxis,n=e.semiMinorAxis,o=e.granularity??h.RADIANS_PER_DEGREE;if(!d(t))throw new m("center is required.");if(!d(r))throw new m("semiMajorAxis is required.");if(!d(n))throw new m("semiMinorAxis is required.");if(r<n)throw new m("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new m("granularity must be greater than zero.");let s=e.height??0,a=e.extrudedHeight??s;this._center=c.clone(t),this._semiMajorAxis=r,this._semiMinorAxis=n,this._ellipsoid=l.clone(i),this._rotation=e.rotation??0,this._height=Math.max(a,s),this._granularity=o,this._extrudedHeight=Math.min(a,s),this._numberOfVerticalLines=Math.max(e.numberOfVerticalLines??16,0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}b.packedLength=c.packedLength+l.packedLength+8,b.pack=function(e,t,i){if(!d(e))throw new m("value is required");if(!d(t))throw new m("array is required");return i=i??0,c.pack(e._center,t,i),i+=c.packedLength,l.pack(e._ellipsoid,t,i),i+=l.packedLength,t[i++]=e._semiMajorAxis,t[i++]=e._semiMinorAxis,t[i++]=e._rotation,t[i++]=e._height,t[i++]=e._granularity,t[i++]=e._extrudedHeight,t[i++]=e._numberOfVerticalLines,t[i]=e._offsetAttribute??-1,t};var x=new c,M=new l,w={center:x,ellipsoid:M,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};b.unpack=function(e,t,i){if(!d(e))throw new m("array is required");t=t??0;let r=c.unpack(e,t,x);t+=c.packedLength;let n=l.unpack(e,t,M);t+=l.packedLength;let o=e[t++],s=e[t++],a=e[t++],u=e[t++],f=e[t++],h=e[t++],p=e[t++],_=e[t];return d(i)?(i._center=c.clone(r,i._center),i._ellipsoid=l.clone(n,i._ellipsoid),i._semiMajorAxis=o,i._semiMinorAxis=s,i._rotation=a,i._height=u,i._granularity=f,i._extrudedHeight=h,i._numberOfVerticalLines=p,i._offsetAttribute=-1===_?void 0:_,i):(w.height=u,w.extrudedHeight=h,w.granularity=f,w.rotation=a,w.semiMajorAxis=o,w.semiMinorAxis=s,w.numberOfVerticalLines=p,w.offsetAttribute=-1===_?void 0:_,new b(w))},b.createGeometry=function(l){if(l._semiMajorAxis<=0||l._semiMinorAxis<=0)return;let f=l._height,m=l._extrudedHeight,b=!h.equalsEpsilon(f,m,0,h.EPSILON2);l._center=l._ellipsoid.scaleToGeodeticSurface(l._center,l._center);let x={center:l._center,semiMajorAxis:l._semiMajorAxis,semiMinorAxis:l._semiMinorAxis,ellipsoid:l._ellipsoid,rotation:l._rotation,height:f,granularity:l._granularity,numberOfVerticalLines:l._numberOfVerticalLines},M;if(b)x.extrudedHeight=m,x.offsetAttribute=l._offsetAttribute,M=function(n){let o,l=n.center,f=n.ellipsoid,m=n.semiMajorAxis,_=c.multiplyByScalar(f.geodeticSurfaceNormal(l,p),n.height,p);A.center=c.add(l,_,A.center),A.radius=m,_=c.multiplyByScalar(f.geodeticSurfaceNormal(l,_),n.extrudedHeight,_),g.center=c.add(l,_,g.center),g.radius=m;let b=e.computeEllipsePositions(n,!1,!0).outerPositions,x=new r({position:new s({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e.raisePositionsToHeight(b,n,!0)})});b=x.position.values;let M=a.union(A,g),w=b.length/3;if(d(n.offsetAttribute)){let e=new Uint8Array(w);if(n.offsetAttribute===t.TOP)e=e.fill(1,0,w/2);else{let i=+(n.offsetAttribute!==t.NONE);e=e.fill(i)}x.applyOffset=new s({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let y=n.numberOfVerticalLines??16;y=h.clamp(y,0,w/2);let k=i.createTypedArray(w,2*w+2*y);w/=2;let j=0,L;for(L=0;L<w;++L)k[j++]=L,k[j++]=(L+1)%w,k[j++]=L+w,k[j++]=(L+1)%w+w;if(y>0){let e=Math.min(y,w),t=Math.min((o=Math.round(w/e))*y,w);for(L=0;L<t;L+=o)k[j++]=L,k[j++]=L+w}return{boundingSphere:M,attributes:x,indices:k}}(x);else if(M=function(t){let n=t.center;_=c.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(n,_),t.height,_);let o=new a(_=c.add(n,_,_),t.semiMajorAxis),l=e.computeEllipsePositions(t,!1,!0).outerPositions,f=new r({position:new s({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e.raisePositionsToHeight(l,t,!1)})}),h=l.length/3,m=i.createTypedArray(h,2*h),d=0;for(let e=0;e<h;++e)m[d++]=e,m[d++]=(e+1)%h;return{boundingSphere:o,attributes:f,indices:m}}(x),d(l._offsetAttribute)){let e=M.attributes.position.values.length,i=+(l._offsetAttribute!==t.NONE),r=new Uint8Array(e/3).fill(i);M.attributes.applyOffset=new s({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new o({attributes:M.attributes,indices:M.indices,primitiveType:n.LINES,boundingSphere:M.boundingSphere,offsetAttribute:l._offsetAttribute})};var y=b;export{y as a};