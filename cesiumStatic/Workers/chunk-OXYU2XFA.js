import{a as i}from"./chunk-IBQZCWHF.js";import{a as t}from"./chunk-KSX6TRAS.js";import{a as o}from"./chunk-GMTHOMGW.js";import{b as e,c as r,d as n}from"./chunk-BELR52CD.js";import{c as a}from"./chunk-BNHFHP3L.js";import{a as s}from"./chunk-N6BI774S.js";import{c as m}from"./chunk-ICY67TC6.js";import{a as u,c as f}from"./chunk-G2EMNOST.js";import{a as c}from"./chunk-4VFKVGYI.js";import{a as l}from"./chunk-3WJNS2B6.js";import{e as h}from"./chunk-XCN226AA.js";var d=new u(1,1,1),_=Math.cos,k=Math.sin;function p(t){let o=(t=t??f.EMPTY_OBJECT).radii??d,e=t.innerRadii??o,r=t.minimumClock??0,n=t.maximumClock??c.TWO_PI,a=t.minimumCone??0,s=t.maximumCone??c.PI,m=Math.round(t.stackPartitions??10),_=Math.round(t.slicePartitions??8),k=Math.round(t.subdivisions??128);if(m<1)throw new l("options.stackPartitions cannot be less than 1");if(_<0)throw new l("options.slicePartitions cannot be less than 0");if(k<0)throw new l("options.subdivisions must be greater than or equal to zero.");if(h(t.offsetAttribute)&&t.offsetAttribute===i.TOP)throw new l("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=u.clone(o),this._innerRadii=u.clone(e),this._minimumClock=r,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=m,this._slicePartitions=_,this._subdivisions=k,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*u.packedLength+8,p.pack=function(i,t,o){if(!h(i))throw new l("value is required");if(!h(t))throw new l("array is required");return o=o??0,u.pack(i._radii,t,o),o+=u.packedLength,u.pack(i._innerRadii,t,o),o+=u.packedLength,t[o++]=i._minimumClock,t[o++]=i._maximumClock,t[o++]=i._minimumCone,t[o++]=i._maximumCone,t[o++]=i._stackPartitions,t[o++]=i._slicePartitions,t[o++]=i._subdivisions,t[o]=i._offsetAttribute??-1,t};var C=new u,b=new u,P={radii:C,innerRadii:b,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(i,t,o){if(!h(i))throw new l("array is required");t=t??0;let e=u.unpack(i,t,C);t+=u.packedLength;let r=u.unpack(i,t,b);t+=u.packedLength;let n=i[t++],a=i[t++],s=i[t++],m=i[t++],f=i[t++],c=i[t++],d=i[t++],_=i[t];return h(o)?(o._radii=u.clone(e,o._radii),o._innerRadii=u.clone(r,o._innerRadii),o._minimumClock=n,o._maximumClock=a,o._minimumCone=s,o._maximumCone=m,o._stackPartitions=f,o._slicePartitions=c,o._subdivisions=d,o._offsetAttribute=-1===_?void 0:_,o):(P.minimumClock=n,P.maximumClock=a,P.minimumCone=s,P.maximumCone=m,P.stackPartitions=f,P.slicePartitions=c,P.subdivisions=d,P.offsetAttribute=-1===_?void 0:_,new p(P))},p.createGeometry=function(u){let f=u._radii;if(f.x<=0||f.y<=0||f.z<=0)return;let l=u._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;let d=u._minimumClock,p=u._maximumClock,C=u._minimumCone,b=u._maximumCone,P=u._subdivisions,y=m.fromCartesian3(f),A=u._slicePartitions+1,v=u._stackPartitions+1;A=Math.round(A*Math.abs(p-d)/c.TWO_PI),v=Math.round(v*Math.abs(b-C)/c.PI),A<2&&(A=2),v<2&&(v=2);let w=0,x=1,g=l.x!==f.x||l.y!==f.y||l.z!==f.z,M=!1,T=!1;g&&(x=2,C>0&&(M=!0,w+=A),b<Math.PI&&(T=!0,w+=A));let O=P*x*(v+A),j=new Float64Array(3*O),E=2*(O+w-(A+v)*x),I=t.createTypedArray(O,E),N,L,z,R,B=0,G=Array(v),S=Array(v);for(N=0;N<v;N++)R=C+N*(b-C)/(v-1),G[N]=k(R),S[N]=_(R);let D=Array(P),W=Array(P);for(N=0;N<P;N++)z=d+N*(p-d)/(P-1),D[N]=k(z),W[N]=_(z);for(N=0;N<v;N++)for(L=0;L<P;L++)j[B++]=f.x*G[N]*W[L],j[B++]=f.y*G[N]*D[L],j[B++]=f.z*S[N];if(g)for(N=0;N<v;N++)for(L=0;L<P;L++)j[B++]=l.x*G[N]*W[L],j[B++]=l.y*G[N]*D[L],j[B++]=l.z*S[N];for(G.length=P,S.length=P,N=0;N<P;N++)R=C+N*(b-C)/(P-1),G[N]=k(R),S[N]=_(R);for(D.length=A,W.length=A,N=0;N<A;N++)z=d+N*(p-d)/(A-1),D[N]=k(z),W[N]=_(z);for(N=0;N<P;N++)for(L=0;L<A;L++)j[B++]=f.x*G[N]*W[L],j[B++]=f.y*G[N]*D[L],j[B++]=f.z*S[N];if(g)for(N=0;N<P;N++)for(L=0;L<A;L++)j[B++]=l.x*G[N]*W[L],j[B++]=l.y*G[N]*D[L],j[B++]=l.z*S[N];for(B=0,N=0;N<v*x;N++){let i=N*P;for(L=0;L<P-1;L++)I[B++]=i+L,I[B++]=i+L+1}let q=v*P*x;for(N=0;N<A;N++)for(L=0;L<P-1;L++)I[B++]=q+N+L*A,I[B++]=q+N+(L+1)*A;if(g)for(q=v*P*x+A*P,N=0;N<A;N++)for(L=0;L<P-1;L++)I[B++]=q+N+L*A,I[B++]=q+N+(L+1)*A;if(g){let i=v*P*x,t=i+P*A;if(M)for(N=0;N<A;N++)I[B++]=i+N,I[B++]=t+N;if(T)for(i+=P*A-A,t+=P*A-A,N=0;N<A;N++)I[B++]=i+N,I[B++]=t+N}let F=new o({position:new n({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:j})});if(h(u._offsetAttribute)){let t=j.length,o=+(u._offsetAttribute!==i.NONE),e=new Uint8Array(t/3).fill(o);F.applyOffset=new n({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new r({attributes:F,indices:I,primitiveType:e.LINES,boundingSphere:a.fromEllipsoid(y),offsetAttribute:u._offsetAttribute})};var y=p;export{y as a};