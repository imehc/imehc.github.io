import{a as t}from"./chunk-VO22SP3V.js";import{a as e}from"./chunk-3QPLNPJT.js";import{a as i}from"./chunk-UPV7RDUS.js";import{a as o}from"./chunk-MABAS5D2.js";import{a as r}from"./chunk-PXD6ATBI.js";import{a as n}from"./chunk-GSMLTRAL.js";import{a as a}from"./chunk-IUX576XK.js";import{b as s,c as l,d as u}from"./chunk-UIGT6VOJ.js";import{a as m,c as c}from"./chunk-XO2FNJZK.js";import{h as p,j as h}from"./chunk-IB27QQGF.js";import{a as f}from"./chunk-KXT7EZPS.js";import{a as d,b as y,c as A}from"./chunk-KCR7AORG.js";import{a as x,b as g,c as _}from"./chunk-QDJTHWTA.js";import{a as w}from"./chunk-2YWR3G22.js";import{a as b,b as M}from"./chunk-HTSQLHXI.js";import{e as v}from"./chunk-JDAHMWM5.js";var T=new x,P=new x,j=new x,E=new x,O=new y,S=new g,R=new g,k=new p,F=new x,N=new x,D=new x,L=new d,I=new x,z=new y,V=new y;function G(e,i,r){let n=i.vertexFormat,s=i.center,l=i.semiMajorAxis,c=i.semiMinorAxis,h=i.ellipsoid,d=i.stRotation,A=r?e.length/3*2:e.length/3,_=i.shadowVolume,w=n.st?new Float32Array(2*A):void 0,b=n.normal?new Float32Array(3*A):void 0,M=n.tangent?new Float32Array(3*A):void 0,E=n.bitangent?new Float32Array(3*A):void 0,G=_?new Float32Array(3*A):void 0,B=0,H=F,C=N,U=D,Y=new m(h),Q=Y.project(h.cartesianToCartographic(s,L),I),J=h.scaleToGeodeticSurface(s,T);h.geodeticSurfaceNormal(J,J);let X=S,W=R;if(0!==d){let t=p.fromAxisAngle(J,d,k);X=g.fromQuaternion(t,X),t=p.fromAxisAngle(J,-d,k),W=g.fromQuaternion(t,W)}else X=g.clone(g.IDENTITY,X),W=g.clone(g.IDENTITY,W);let K=y.fromElements(1/0,1/0,z),q=y.fromElements(-1/0,-1/0,V),Z=e.length,$=r?Z:0,tt=$/3*2;for(let t=0;t<Z;t+=3){let i=t+1,o=t+2,a=x.fromArray(e,t,T);if(n.st){let t=g.multiplyByVector(X,a,P),e=Y.project(h.cartesianToCartographic(t,L),j);x.subtract(e,Q,e),O.x=(e.x+l)/(2*l),O.y=(e.y+c)/(2*c),K.x=Math.min(O.x,K.x),K.y=Math.min(O.y,K.y),q.x=Math.max(O.x,q.x),q.y=Math.max(O.y,q.y),r&&(w[B+tt]=O.x,w[B+1+tt]=O.y),w[B++]=O.x,w[B++]=O.y}(n.normal||n.tangent||n.bitangent||_)&&(H=h.geodeticSurfaceNormal(a,H),_&&(G[t+$]=-H.x,G[i+$]=-H.y,G[o+$]=-H.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(C=x.normalize(x.cross(x.UNIT_Z,H,C),C),g.multiplyByVector(W,C,C)),n.normal&&(b[t]=H.x,b[i]=H.y,b[o]=H.z,r&&(b[t+$]=-H.x,b[i+$]=-H.y,b[o+$]=-H.z)),n.tangent&&(M[t]=C.x,M[i]=C.y,M[o]=C.z,r&&(M[t+$]=-C.x,M[i+$]=-C.y,M[o+$]=-C.z)),n.bitangent&&(U=x.normalize(x.cross(H,C,U),U),E[t]=U.x,E[i]=U.y,E[o]=U.z,r&&(E[t+$]=U.x,E[i+$]=U.y,E[o+$]=U.z))))}if(n.st){Z=w.length;for(let t=0;t<Z;t+=2)w[t]=(w[t]-K.x)/(q.x-K.x),w[t+1]=(w[t+1]-K.y)/(q.y-K.y)}let te=new a;if(n.position){let o=t.raisePositionsToHeight(e,i,r);te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:o})}if(n.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),n.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),n.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),n.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:E})),_&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:G})),r&&v(i.offsetAttribute)){let t=new Uint8Array(A);if(i.offsetAttribute===o.TOP)t=t.fill(1,0,A/2);else{let e=+(i.offsetAttribute!==o.NONE);t=t.fill(e)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}function B(t){let e=Array(t*(t+1)*12-6),i=0,o,r,n,a,s;for(o=0,n=1,a=0;a<3;a++)e[i++]=n++,e[i++]=o,e[i++]=n;for(a=2;a<t+1;++a){for(n=a*(a+1)-1,o=(a-1)*a-1,e[i++]=n++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=n++,e[i++]=o,e[i++]=n}for(r=2*t,++n,++o,a=0;a<r-1;++a)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;for(e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o++,e[i++]=o,++o,a=t-1;a>1;--a){for(e[i++]=o++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=o++,e[i++]=o++,e[i++]=n++}for(a=0;a<3;a++)e[i++]=o++,e[i++]=o,e[i++]=n;return e}var H=new x,C=new c,U=new c;function Y(e,i,o,r,n,a,s){let l=t.computeEllipsePositions({center:e,semiMajorAxis:i,semiMinorAxis:o,rotation:r,granularity:n},!1,!0).outerPositions,u=l.length/3,m=Array(u);for(let t=0;t<u;++t)m[t]=x.fromArray(l,3*t);let c=h.fromCartesianArray(m,a,s);return c.width>w.PI&&(c.north=c.north>0?w.PI_OVER_TWO-w.EPSILON7:c.north,c.south=c.south<0?w.EPSILON7-w.PI_OVER_TWO:c.south,c.east=w.PI,c.west=-w.PI),c}function Q(t){let e=(t=t??_.EMPTY_OBJECT).center,i=t.ellipsoid??A.default,o=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.vertexFormat??r.DEFAULT;if(M.defined("options.center",e),M.typeOf.number("options.semiMajorAxis",o),M.typeOf.number("options.semiMinorAxis",n),o<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");let l=t.height??0,u=t.extrudedHeight??l;this._center=x.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=n,this._ellipsoid=A.clone(i),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._height=Math.max(u,l),this._granularity=a,this._vertexFormat=r.clone(s),this._extrudedHeight=Math.min(u,l),this._shadowVolume=t.shadowVolume??!1,this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}Q.packedLength=x.packedLength+A.packedLength+r.packedLength+9,Q.pack=function(t,e,i){return M.defined("value",t),M.defined("array",e),i=i??0,x.pack(t._center,e,i),i+=x.packedLength,A.pack(t._ellipsoid,e,i),i+=A.packedLength,r.pack(t._vertexFormat,e,i),i+=r.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=+!!t._shadowVolume,e[i]=t._offsetAttribute??-1,e};var J=new x,X=new A,W=new r,K={center:J,ellipsoid:X,vertexFormat:W,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Q.unpack=function(t,e,i){M.defined("array",t),e=e??0;let o=x.unpack(t,e,J);e+=x.packedLength;let n=A.unpack(t,e,X);e+=A.packedLength;let a=r.unpack(t,e,W);e+=r.packedLength;let s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],h=t[e++],f=1===t[e++],d=t[e];return v(i)?(i._center=x.clone(o,i._center),i._ellipsoid=A.clone(n,i._ellipsoid),i._vertexFormat=r.clone(a,i._vertexFormat),i._semiMajorAxis=s,i._semiMinorAxis=l,i._rotation=u,i._stRotation=m,i._height=c,i._granularity=p,i._extrudedHeight=h,i._shadowVolume=f,i._offsetAttribute=-1===d?void 0:d,i):(K.height=c,K.extrudedHeight=h,K.granularity=p,K.stRotation=m,K.rotation=u,K.semiMajorAxis=s,K.semiMinorAxis=l,K.shadowVolume=f,K.offsetAttribute=-1===d?void 0:d,new Q(K))},Q.computeRectangle=function(t,e){let i=(t=t??_.EMPTY_OBJECT).center,o=t.ellipsoid??A.default,r=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.rotation??0;if(M.defined("options.center",i),M.typeOf.number("options.semiMajorAxis",r),M.typeOf.number("options.semiMinorAxis",n),r<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");return Y(i,r,n,s,a,o,e)},Q.createGeometry=function(r){if(r._semiMajorAxis<=0||r._semiMinorAxis<=0)return;let h=r._height,d=r._extrudedHeight,A=!w.equalsEpsilon(h,d,0,w.EPSILON2);r._center=r._ellipsoid.scaleToGeodeticSurface(r._center,r._center);let _={center:r._center,semiMajorAxis:r._semiMajorAxis,semiMinorAxis:r._semiMinorAxis,ellipsoid:r._ellipsoid,rotation:r._rotation,height:h,granularity:r._granularity,vertexFormat:r._vertexFormat,stRotation:r._stRotation},b;if(A)_.extrudedHeight=d,_.shadowVolume=r._shadowVolume,_.offsetAttribute=r._offsetAttribute,b=function(r){let h=r.center,d=r.ellipsoid,A=r.semiMajorAxis,_=x.multiplyByScalar(d.geodeticSurfaceNormal(h,T),r.height,T);C.center=x.add(h,_,C.center),C.radius=A,_=x.multiplyByScalar(d.geodeticSurfaceNormal(h,_),r.extrudedHeight,_),U.center=x.add(h,_,U.center),U.radius=A;let w=t.computeEllipsePositions(r,!0,!0),b=w.positions,M=w.numPts,R=w.outerPositions,H=c.union(C,U),Y=G(b,r,!0),Q=B(M),J=Q.length;Q.length=2*J;let X=b.length/3;for(let t=0;t<J;t+=3)Q[t+J]=Q[t+2]+X,Q[t+1+J]=Q[t+1]+X,Q[t+2+J]=Q[t]+X;let W=new l({attributes:Y,indices:n.createTypedArray(2*X/3,Q),primitiveType:s.TRIANGLES}),K=function(t,e){let i=e.vertexFormat,r=e.center,n=e.semiMajorAxis,s=e.semiMinorAxis,l=e.ellipsoid,c=e.height,h=e.extrudedHeight,d=e.stRotation,A=t.length/3*2,_=new Float64Array(3*A),w=i.st?new Float32Array(2*A):void 0,b=i.normal?new Float32Array(3*A):void 0,M=i.tangent?new Float32Array(3*A):void 0,R=i.bitangent?new Float32Array(3*A):void 0,G=e.shadowVolume,B=G?new Float32Array(3*A):void 0,H=0,C=F,U=N,Y=D,Q=new m(l),J=Q.project(l.cartesianToCartographic(r,L),I),X=l.scaleToGeodeticSurface(r,T);l.geodeticSurfaceNormal(X,X);let W=p.fromAxisAngle(X,d,k),K=g.fromQuaternion(W,S),q=y.fromElements(1/0,1/0,z),Z=y.fromElements(-1/0,-1/0,V),$=t.length,tt=$/3*2;for(let e=0;e<$;e+=3){let o=e+1,r=e+2,a=x.fromArray(t,e,T),u;if(i.st){let t=g.multiplyByVector(K,a,P),e=Q.project(l.cartesianToCartographic(t,L),j);x.subtract(e,J,e),O.x=(e.x+n)/(2*n),O.y=(e.y+s)/(2*s),q.x=Math.min(O.x,q.x),q.y=Math.min(O.y,q.y),Z.x=Math.max(O.x,Z.x),Z.y=Math.max(O.y,Z.y),w[H+tt]=O.x,w[H+1+tt]=O.y,w[H++]=O.x,w[H++]=O.y}a=l.scaleToGeodeticSurface(a,a),u=x.clone(a,P),C=l.geodeticSurfaceNormal(a,C),G&&(B[e+$]=-C.x,B[o+$]=-C.y,B[r+$]=-C.z);let m=x.multiplyByScalar(C,c,E);if(a=x.add(a,m,a),m=x.multiplyByScalar(C,h,m),u=x.add(u,m,u),i.position&&(_[e+$]=u.x,_[o+$]=u.y,_[r+$]=u.z,_[e]=a.x,_[o]=a.y,_[r]=a.z),i.normal||i.tangent||i.bitangent){Y=x.clone(C,Y);let n=x.fromArray(t,(e+3)%$,E);x.subtract(n,a,n);let s=x.subtract(u,a,j);C=x.normalize(x.cross(s,n,C),C),i.normal&&(b[e]=C.x,b[o]=C.y,b[r]=C.z,b[e+$]=C.x,b[o+$]=C.y,b[r+$]=C.z),i.tangent&&(U=x.normalize(x.cross(Y,C,U),U),M[e]=U.x,M[o]=U.y,M[r]=U.z,M[e+$]=U.x,M[e+1+$]=U.y,M[e+2+$]=U.z),i.bitangent&&(R[e]=Y.x,R[o]=Y.y,R[r]=Y.z,R[e+$]=Y.x,R[o+$]=Y.y,R[r+$]=Y.z)}}if(i.st){$=w.length;for(let t=0;t<$;t+=2)w[t]=(w[t]-q.x)/(Z.x-q.x),w[t+1]=(w[t+1]-q.y)/(Z.y-q.y)}let te=new a;if(i.position&&(te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:_})),i.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),i.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),i.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),i.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:R})),G&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:B})),v(e.offsetAttribute)){let t=new Uint8Array(A);if(e.offsetAttribute===o.TOP)t=t.fill(1,0,A/2);else{let i=+(e.offsetAttribute!==o.NONE);t=t.fill(i)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}(R,r);Q=function(t){let e=t.length/3,i=n.createTypedArray(e,6*e),o=0;for(let t=0;t<e;t++){let r=t,n=t+e,a=(r+1)%e,s=a+e;i[o++]=r,i[o++]=n,i[o++]=a,i[o++]=a,i[o++]=n,i[o++]=s}return i}(R);let q=new l({attributes:K,indices:n.createTypedArray(2*R.length/3,Q),primitiveType:s.TRIANGLES}),Z=i.combineInstances([new e({geometry:W}),new e({geometry:q})]);return{boundingSphere:H,attributes:Z[0].attributes,indices:Z[0].indices}}(_);else{let e,i,a,s,l,m,p;if(e=_.center,H=x.multiplyByScalar(_.ellipsoid.geodeticSurfaceNormal(e,H),_.height,H),i=new c(H=x.add(e,H,H),_.semiMajorAxis),s=(a=t.computeEllipsePositions(_,!0,!1)).positions,l=a.numPts,m=G(s,_,!1),p=B(l),b={boundingSphere:i,attributes:m,indices:p=n.createTypedArray(s.length/3,p)},v(r._offsetAttribute)){let t=b.attributes.position.values.length,e=+(r._offsetAttribute!==o.NONE),i=new Uint8Array(t/3).fill(e);b.attributes.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}return new l({attributes:b.attributes,indices:b.indices,primitiveType:s.TRIANGLES,boundingSphere:b.boundingSphere,offsetAttribute:r._offsetAttribute})},Q.createShadowVolume=function(t,e,i){let o=t._granularity,n=t._ellipsoid,a=e(o,n),s=i(o,n);return new Q({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:o,extrudedHeight:a,height:s,vertexFormat:r.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(Q.prototype,{rectangle:{get:function(){return v(this._rectangle)||(this._rectangle=Y(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return v(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){let i=-e._stRotation;if(0===i)return[0,0,0,1,1,0];let o=t.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=o.length/3,n=Array(r);for(let t=0;t<r;++t)n[t]=x.fromArray(o,3*t);let a=e._ellipsoid,s=e.rectangle;return l._textureCoordinateRotationPoints(n,i,a,s)}(this)),this._textureCoordinateRotationPoints}}});var q=Q;export{q as a};