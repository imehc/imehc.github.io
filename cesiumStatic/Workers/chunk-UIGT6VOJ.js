import{h as t,i as e,j as n,k as i}from"./chunk-IB27QQGF.js";import{b as r}from"./chunk-RGFEE67W.js";import{a as o}from"./chunk-ZIOQOCPQ.js";import{a as s,b as a}from"./chunk-KCR7AORG.js";import{a as u,b as m,c as p}from"./chunk-QDJTHWTA.js";import{a as c,b as I}from"./chunk-HTSQLHXI.js";import{e as N}from"./chunk-JDAHMWM5.js";var h=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3}),l={POINTS:o.POINTS,LINES:o.LINES,LINE_LOOP:o.LINE_LOOP,LINE_STRIP:o.LINE_STRIP,TRIANGLES:o.TRIANGLES,TRIANGLE_STRIP:o.TRIANGLE_STRIP,TRIANGLE_FAN:o.TRIANGLE_FAN};l.isLines=function(t){return t===l.LINES||t===l.LINE_LOOP||t===l.LINE_STRIP},l.isTriangles=function(t){return t===l.TRIANGLES||t===l.TRIANGLE_STRIP||t===l.TRIANGLE_FAN},l.validate=function(t){return t===l.POINTS||t===l.LINES||t===l.LINE_LOOP||t===l.LINE_STRIP||t===l.TRIANGLES||t===l.TRIANGLE_STRIP||t===l.TRIANGLE_FAN};var T=Object.freeze(l);function b(t){t=t??p.EMPTY_OBJECT,I.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=t.primitiveType??T.TRIANGLES,this.boundingSphere=t.boundingSphere,this.geometryType=t.geometryType??h.NONE,this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}b.computeNumberOfVertices=function(t){I.typeOf.object("geometry",t);let e=-1;for(let n in t.attributes)if(t.attributes.hasOwnProperty(n)&&N(t.attributes[n])&&N(t.attributes[n].values)){let i=t.attributes[n],r=i.values.length/i.componentsPerAttribute;if(e!==r&&-1!==e)throw new c("All attribute lists must have the same number of attributes.");e=r}return e};var f=new s,A=new u,E=new r,L=[new s,new s,new s],y=[new a,new a,new a],P=[new a,new a,new a],w=new u,S=new t,R=new r,O=new i;b._textureCoordinateRotationPoints=function(o,p,c,I){let N,h=n.center(I,f),l=s.toCartesian(h,c,A),T=e.eastNorthUpToFixedFrame(l,c,E),b=r.inverse(T,E);L[0].longitude=I.west,L[0].latitude=I.south,L[1].longitude=I.west,L[1].latitude=I.north,L[2].longitude=I.east,L[2].latitude=I.south;let d=w;for(N=0;N<3;N++)s.toCartesian(L[N],c,d),d=r.multiplyByPointAsVector(b,d,d),y[N].x=d.x,y[N].y=d.y;let _=t.fromAxisAngle(u.UNIT_Z,-p,S),x=m.fromQuaternion(_,R),G=o.length,v=1/0,g=1/0,j=-1/0,k=-1/0;for(N=0;N<G;N++)d=r.multiplyByPointAsVector(b,o[N],d),v=Math.min(v,(d=m.multiplyByVector(x,d,d)).x),g=Math.min(g,d.y),j=Math.max(j,d.x),k=Math.max(k,d.y);let C=i.fromRotation(p,O);P[0].x=v,P[0].y=g,P[1].x=v,P[1].y=k,P[2].x=j,P[2].y=g;let F=y[0],M=y[2].x-F.x,B=y[1].y-F.y;for(N=0;N<3;N++){let t=P[N];i.multiplyByVector(C,t,t),t.x=(t.x-F.x)/M,t.y=(t.y-F.y)/B}let Q=P[0],V=P[1],D=P[2],z=Array(6);return a.pack(Q,z),a.pack(V,z,2),a.pack(D,z,4),z};var d=b,_=function(t){if(!N((t=t??p.EMPTY_OBJECT).componentDatatype))throw new c("options.componentDatatype is required.");if(!N(t.componentsPerAttribute))throw new c("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new c("options.componentsPerAttribute must be between 1 and 4.");if(!N(t.values))throw new c("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=t.normalize??!1,this.values=t.values};export{h as a,T as b,d as c,_ as d};