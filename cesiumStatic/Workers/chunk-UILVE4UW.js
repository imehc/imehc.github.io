import{a as e}from"./chunk-MCM3P7ZC.js";import{a as t}from"./chunk-UPV7RDUS.js";import{a as n,b as i}from"./chunk-TN2BIDXM.js";import{a as o}from"./chunk-KF74ULE7.js";import{a as r}from"./chunk-4EHG4BFI.js";import{b as s}from"./chunk-KIJM7B3H.js";import{a as a}from"./chunk-P44F6KLE.js";import{a as l}from"./chunk-GSMLTRAL.js";import{a as u}from"./chunk-IUX576XK.js";import{b as c,c as h,d as f}from"./chunk-UIGT6VOJ.js";import{h as p}from"./chunk-IB27QQGF.js";import{a as g}from"./chunk-KXT7EZPS.js";import{a as d,b as m,c as y}from"./chunk-KCR7AORG.js";import{a as v,b as b}from"./chunk-QDJTHWTA.js";import{a as x}from"./chunk-2YWR3G22.js";import{e as w}from"./chunk-JDAHMWM5.js";var L=function(e,t){this.positions=w(e)?e:[],this.holes=w(t)?t:[]};function T(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(T.prototype,{length:{get:function(){return this._length}}}),T.prototype.enqueue=function(e){this._array.push(e),this._length++},T.prototype.dequeue=function(){if(0===this._length)return;let e=this._array,t=this._offset,n=e[t];return e[t]=void 0,++t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},T.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},T.prototype.contains=function(e){return -1!==this._array.indexOf(e)},T.prototype.clear=function(){this._array.length=this._offset=this._length=0},T.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};var M={};M.computeHierarchyPackedLength=function(e,t){let n=0,i=[e];for(;i.length>0;){let e=i.pop();if(!w(e))continue;n+=2;let o=e.positions,r=e.holes;if(w(o)&&o.length>0&&(n+=o.length*t.packedLength),w(r)){let e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},M.packPolygonHierarchy=function(e,t,n,i){let o=[e];for(;o.length>0;){let e=o.pop();if(!w(e))continue;let r=e.positions,s=e.holes;if(t[n++]=w(r)?r.length:0,t[n++]=w(s)?s.length:0,w(r)){let e=r.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(r[o],t,n)}if(w(s)){let e=s.length;for(let t=0;t<e;++t)o.push(s[t])}}return n},M.unpackPolygonHierarchy=function(e,t,n){let i=e[t++],o=e[t++],r=Array(i),s=o>0?Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)s[i]=M.unpackPolygonHierarchy(e,t,n),t=s[i].startingIndex,delete s[i].startingIndex;return{positions:r,holes:s,startingIndex:t}};var E=new m;function k(e,t,n,i){return m.subtract(t,e,E),m.multiplyByScalar(E,n/i,E),m.add(e,E,E),[E.x,E.y]}var A=new v;M.subdivideLineCount=function(e,t,n){let i=v.distance(e,t)/n;return Math.pow(2,Math.max(0,Math.ceil(x.log2(i))))};var C=new d,S=new d,_=new d,D=new v,I=new r;M.subdivideRhumbLineCount=function(e,t,n,i){let o=new r(e.cartesianToCartographic(t,C),e.cartesianToCartographic(n,S),e).surfaceDistance/i;return Math.pow(2,Math.max(0,Math.ceil(x.log2(o))))},M.subdivideTexcoordLine=function(e,t,n,i,o,r){let s=M.subdivideLineCount(n,i,o),a=m.distance(e,t),l=a/s;r.length=2*s;let u=0;for(let n=0;n<s;n++){let i=k(e,t,n*l,a);r[u++]=i[0],r[u++]=i[1]}return r},M.subdivideLine=function(e,t,n,i){let o=M.subdivideLineCount(e,t,n),r=v.distance(e,t),s=r/o;w(i)||(i=[]);let a=i;a.length=3*o;let l=0;for(let n=0;n<o;n++){var u;let i=(u=n*s,v.subtract(t,e,A),v.multiplyByScalar(A,u/r,A),v.add(e,A,A),[A.x,A.y,A.z]);a[l++]=i[0],a[l++]=i[1],a[l++]=i[2]}return a},M.subdivideTexcoordRhumbLine=function(e,t,n,i,o,r,s){let a=n.cartesianToCartographic(i,C),l=n.cartesianToCartographic(o,S);I.setEndPoints(a,l);let u=I.surfaceDistance/r,c=Math.pow(2,Math.max(0,Math.ceil(x.log2(u)))),h=m.distance(e,t),f=h/c;s.length=2*c;let p=0;for(let n=0;n<c;n++){let i=k(e,t,n*f,h);s[p++]=i[0],s[p++]=i[1]}return s},M.subdivideRhumbLine=function(e,t,n,i,o){let s=new r(e.cartesianToCartographic(t,C),e.cartesianToCartographic(n,S),e);if(w(o)||(o=[]),s.surfaceDistance<=i)return o.length=3,o[0]=t.x,o[1]=t.y,o[2]=t.z,o;let a=s.surfaceDistance/i,l=Math.pow(2,Math.max(0,Math.ceil(x.log2(a)))),u=s.surfaceDistance/l,c=o;c.length=3*l;let h=0;for(let t=0;t<l;t++){let n=s.interpolateUsingSurfaceDistance(t*u,_),i=e.cartographicToCartesian(n,D);c[h++]=i.x,c[h++]=i.y,c[h++]=i.z}return c};var P=new v,R=new v,G=new v,O=new v;M.scaleToGeodeticHeightExtruded=function(e,t,n,i,o){i=i??y.default;let r=R,s=O;if(w(e)&&w(e.attributes)&&w(e.attributes.position)){let a=e.attributes.position.values,l=a.length/2;for(let e=0;e<l;e+=3)v.fromArray(a,e,G),i.geodeticSurfaceNormal(G,P),s=i.scaleToGeodeticSurface(G,s),r=v.multiplyByScalar(P,n,r),r=v.add(s,r,r),a[e+l]=r.x,a[e+1+l]=r.y,a[e+2+l]=r.z,o&&(s=v.clone(G,s)),r=v.multiplyByScalar(P,t,r),r=v.add(s,r,r),a[e]=r.x,a[e+1]=r.y,a[e+2]=r.z}return e},M.polygonOutlinesFromHierarchy=function(e,t,n){let i,r,s,a=[],l=new T;for(l.enqueue(e);0!==l.length;){let e=l.dequeue(),u=e.positions;if(t)for(s=u.length,i=0;i<s;i++)n.scaleToGeodeticSurface(u[i],u[i]);if((u=o(u,v.equalsEpsilon,!0)).length<3)continue;let c=e.holes?e.holes.length:0;for(i=0;i<c;i++){let u=e.holes[i],c=u.positions;if(t)for(s=c.length,r=0;r<s;++r)n.scaleToGeodeticSurface(c[r],c[r]);if((c=o(c,v.equalsEpsilon,!0)).length<3)continue;a.push(c);let h=0;for(w(u.holes)&&(h=u.holes.length),r=0;r<h;r++)l.enqueue(u.holes[r])}a.push(u)}return a};var j=new d,B=new d;M.splitPolygonsOnEquator=function(t,n,i,o){w(o)||(o=[]),o.splice(0,0,...t),o.length=t.length;let r=0;for(;r<o.length;){let t=o[r],l=t.slice();if(t.length<3){o[r]=l,++r;continue}let u=function(t,n,i){let o=[],r,l,u,c,h,f=0;for(;f<t.length;){r=t[f],l=t[(f+1)%t.length],u=x.sign(r.z),c=x.sign(l.z);let p=e=>n.cartesianToCartographic(e,B).longitude;if(0===u)o.push({position:f,type:u,visited:!1,next:c,theta:p(r)});else if(0!==c){if(h=function(t,n,i,o){if(o===e.RHUMB)return function(e,t,n){let i=n.cartesianToCartographic(e,C),o=n.cartesianToCartographic(t,S);if(Math.sign(i.latitude)===Math.sign(o.latitude))return;I.setEndPoints(i,o);let r=I.findIntersectionWithLatitude(0,j);if(!w(r))return;let s=Math.min(i.longitude,o.longitude),a=Math.max(i.longitude,o.longitude);if(Math.abs(a-s)>x.PI){let e=s;s=a,a=e}if(!(r.longitude<s||r.longitude>a))return n.cartographicToCartesian(r)}(t,n,i);let r=s.lineSegmentPlane(t,n,a.ORIGIN_XY_PLANE);if(w(r))return i.scaleToGeodeticSurface(r,r)}(r,l,n,i),++f,!w(h))continue;t.splice(f,0,h),o.push({position:f,type:u,visited:!1,next:c,theta:p(h)})}++f}return o}(l,n,i);if(l.length===t.length||u.length<=1){o[r]=l,++r;continue}u.sort((e,t)=>e.theta-t.theta);let c=l[0].z>=0;r=function e(t,n,i,o,r,s,a){let l=[],u=s,c=e=>t=>t.position===e,h=[];do{let e=i[u];l.push(e);let t=o.findIndex(c(u)),n=o[t];if(!w(n)){++u;continue}let{visited:r,type:f,next:p}=n;if(n.visited=!0,0===f){if(0===p){let e=o[t-(a?1:-1)];if(e?.position===u+1)e.visited=!0;else{++u;continue}}if(!r&&a&&p>0||s===u&&!a&&p<0){++u;continue}}if(!(a?f>=0:f<=0)){++u;continue}r||h.push(u);let g=o[t+(a?1:-1)];if(!w(g)){++u;continue}u=g.position}while(u<i.length&&u>=0&&u!==s&&l.length<i.length)for(let s of(t.splice(n,r,l),h))n=e(t,++n,i,o,0,s,!a);return n}(o,r,l,u,1,0,c)}return o},M.polygonsFromHierarchy=function(e,t,r,s,a,l){let u=[],c=[],h=new T;h.enqueue(e);let f=w(l);for(;0!==h.length;){let e=h.dequeue(),p=e.positions,g=e.holes,d,m;if(s)for(m=p.length,d=0;d<m;d++)a.scaleToGeodeticSurface(p[d],p[d]);if(t||(p=o(p,v.equalsEpsilon,!0)),p.length<3)continue;let y=r(p);if(!w(y))continue;let b=[],x=i.computeWindingOrder2D(y);if(x===n.CLOCKWISE&&(y.reverse(),p=p.slice().reverse()),f){f=!1;let e=[p];if((e=l(e,e)).length>1){for(let t of e)h.enqueue(new L(t,g));continue}}let T=p.slice(),M=w(g)?g.length:0,E=[],k;for(d=0;d<M;d++){let e=g[d],l=e.positions;if(s)for(m=l.length,k=0;k<m;++k)a.scaleToGeodeticSurface(l[k],l[k]);if(t||(l=o(l,v.equalsEpsilon,!0)),l.length<3)continue;let u=r(l);if(!w(u))continue;(x=i.computeWindingOrder2D(u))===n.CLOCKWISE&&(u.reverse(),l=l.slice().reverse()),E.push(l),b.push(T.length),T=T.concat(l),y=y.concat(u);let c=0;for(w(e.holes)&&(c=e.holes.length),k=0;k<c;k++)h.enqueue(e.holes[k])}u.push({outerRing:p,holes:E}),c.push({positions:T,positions2D:y,holes:b})}return{hierarchy:u,polygons:c}};var q=new m,H=new v,z=new p,U=new b;M.computeBoundingRectangle=function(e,t,n,i,o){let r=p.fromAxisAngle(e,i,z),s=b.fromQuaternion(r,U),a=1/0,l=-1/0,u=1/0,c=-1/0,h=n.length;for(let e=0;e<h;++e){let i=v.clone(n[e],H);b.multiplyByVector(s,i,i);let o=t(i,q);w(o)&&(a=Math.min(a,o.x),l=Math.max(l,o.x),u=Math.min(u,o.y),c=Math.max(c,o.y))}return o.x=a,o.y=u,o.width=l-a,o.height=c-u,o},M.createGeometryFromPositions=function(n,o,r,s,a,l,u){let p=i.triangulate(o.positions2D,o.holes);p.length<3&&(p=[0,1,2]);let d=o.positions,y=w(r),v=y?r.positions:void 0;if(a){let e=d.length,n=Array(3*e),i=0;for(let t=0;t<e;t++){let e=d[t];n[i++]=e.x,n[i++]=e.y,n[i++]=e.z}let o={attributes:{position:new f({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:n})},indices:p,primitiveType:c.TRIANGLES};y&&(o.attributes.st=new f({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:m.packArray(v)}));let r=new h(o);return l.normal?t.computeNormal(r):r}return u===e.GEODESIC?i.computeSubdivision(n,d,p,v,s):u===e.RHUMB?i.computeRhumbLineSubdivision(n,d,p,v,s):void 0};var F=[],N=[],W=new v,K=new v;M.computeWallGeometry=function(t,n,i,o,r,s){let a,p,d,m,y,b,L,T,E,k=t.length,A=0,C=0,S=w(n),_=S?n.positions:void 0;if(r)for(a=Array(2*(p=3*k*2)),S&&(T=Array(2*(E=2*k*2))),d=0;d<k;d++)m=t[d],y=t[(d+1)%k],a[A]=a[A+p]=m.x,a[++A]=a[A+p]=m.y,a[++A]=a[A+p]=m.z,a[++A]=a[A+p]=y.x,a[++A]=a[A+p]=y.y,a[++A]=a[A+p]=y.z,++A,S&&(b=_[d],L=_[(d+1)%k],T[C]=T[C+E]=b.x,T[++C]=T[C+E]=b.y,T[++C]=T[C+E]=L.x,T[++C]=T[C+E]=L.y,++C);else{let n=x.chordLength(o,i.maximumRadius),r=0;if(s===e.GEODESIC)for(d=0;d<k;d++)r+=M.subdivideLineCount(t[d],t[(d+1)%k],n);else if(s===e.RHUMB)for(d=0;d<k;d++)r+=M.subdivideRhumbLineCount(i,t[d],t[(d+1)%k],n);for(a=Array(2*(p=(r+k)*3)),S&&(T=Array(2*(E=(r+k)*2))),d=0;d<k;d++){let o,r;m=t[d],y=t[(d+1)%k],S&&(b=_[d],L=_[(d+1)%k]),s===e.GEODESIC?(o=M.subdivideLine(m,y,n,N),S&&(r=M.subdivideTexcoordLine(b,L,m,y,n,F))):s===e.RHUMB&&(o=M.subdivideRhumbLine(i,m,y,n,N),S&&(r=M.subdivideTexcoordRhumbLine(b,L,i,m,y,n,F)));let l=o.length;for(let e=0;e<l;++e,++A)a[A]=o[e],a[A+p]=o[e];if(a[A]=y.x,a[A+p]=y.x,a[++A]=y.y,a[A+p]=y.y,a[++A]=y.z,a[A+p]=y.z,++A,S){let e=r.length;for(let t=0;t<e;++t,++C)T[C]=r[t],T[C+E]=r[t];T[C]=L.x,T[C+E]=L.x,T[++C]=L.y,T[C+E]=L.y,++C}}}k=a.length;let D=l.createTypedArray(k/3,k-6*t.length),I=0;for(k/=6,d=0;d<k;d++){let e=d,t=e+1,n=e+k,i=n+1;m=v.fromArray(a,3*e,W),y=v.fromArray(a,3*t,K),v.equalsEpsilon(m,y,x.EPSILON10,x.EPSILON10)||(D[I++]=e,D[I++]=n,D[I++]=t,D[I++]=t,D[I++]=n,D[I++]=i)}let P={attributes:new u({position:new f({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:a})}),indices:D,primitiveType:c.TRIANGLES};return S&&(P.attributes.st=new f({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:T})),new h(P)};var X=M;export{X as a};