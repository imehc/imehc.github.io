import{a as e}from"./chunk-NPKIHRIX.js";import{a as t}from"./chunk-MUKCYY2X.js";import{b as r}from"./chunk-KIJM7B3H.js";import{a as i}from"./chunk-P44F6KLE.js";import{a as n}from"./chunk-GSMLTRAL.js";import{a as o,b as s,c as a,d as u}from"./chunk-UIGT6VOJ.js";import{a as l,c as p}from"./chunk-XO2FNJZK.js";import{a as m}from"./chunk-CM5O7VPK.js";import{a as c,b as f}from"./chunk-RGFEE67W.js";import{a as y}from"./chunk-KXT7EZPS.js";import{a as h,b as d}from"./chunk-KCR7AORG.js";import{a as v,b as b,c as w}from"./chunk-QDJTHWTA.js";import{a as g}from"./chunk-2YWR3G22.js";import{a as T,b as A}from"./chunk-HTSQLHXI.js";import{e as S}from"./chunk-JDAHMWM5.js";var x=new v,P=new v,N=new v,E=function(e,t,r,i,n){let o,s,a,u,l,p,m,c;if(A.defined("point",e),A.defined("p0",t),A.defined("p1",r),A.defined("p2",i),S(n)||(n=new v),S(t.z)){if(v.equalsEpsilon(e,t,g.EPSILON14))return v.clone(v.UNIT_X,n);if(v.equalsEpsilon(e,r,g.EPSILON14))return v.clone(v.UNIT_Y,n);if(v.equalsEpsilon(e,i,g.EPSILON14))return v.clone(v.UNIT_Z,n);o=v.subtract(r,t,x),s=v.subtract(i,t,P),a=v.subtract(e,t,N),u=v.dot(o,o),l=v.dot(o,s),p=v.dot(o,a),m=v.dot(s,s),c=v.dot(s,a)}else{if(d.equalsEpsilon(e,t,g.EPSILON14))return v.clone(v.UNIT_X,n);if(d.equalsEpsilon(e,r,g.EPSILON14))return v.clone(v.UNIT_Y,n);if(d.equalsEpsilon(e,i,g.EPSILON14))return v.clone(v.UNIT_Z,n);o=d.subtract(r,t,x),s=d.subtract(i,t,P),a=d.subtract(e,t,N),u=d.dot(o,o),l=d.dot(o,s),p=d.dot(o,a),m=d.dot(s,s),c=d.dot(s,a)}n.y=m*p-l*c,n.z=u*c-l*p;let f=u*m-l*l;if(0!==f)return n.y/=f,n.z/=f,n.x=1-n.y-n.z,n},I={};I.calculateACMR=function(e){let t=(e=e??w.EMPTY_OBJECT).indices,r=e.maximumIndex,i=e.cacheSize??24;if(!S(t))throw new T("indices is required.");let n=t.length;if(n<3||n%3!=0)throw new T("indices length must be a multiple of three.");if(r<=0)throw new T("maximumIndex must be greater than zero.");if(i<3)throw new T("cacheSize must be greater than two.");if(!S(r)){r=0;let e=0,i=t[0];for(;e<n;)i>r&&(r=i),i=t[++e]}let o=[];for(let e=0;e<r+1;e++)o[e]=0;let s=i+1;for(let e=0;e<n;++e)s-o[t[e]]>i&&(o[t[e]]=s,++s);return(s-i+1)/(n/3)},I.tipsify=function(e){let t,r,i=(e=e??w.EMPTY_OBJECT).indices,n=e.maximumIndex,o=e.cacheSize??24,s;if(!S(i))throw new T("indices is required.");let a=i.length;if(a<3||a%3!=0)throw new T("indices length must be a multiple of three.");if(n<=0)throw new T("maximumIndex must be greater than zero.");if(o<3)throw new T("cacheSize must be greater than two.");let u=0,l=0,p=i[0];if(S(n))u=n+1;else{for(;l<a;)p>u&&(u=p),p=i[++l];if(-1===u)return 0;++u}let m=[],c;for(c=0;c<u;c++)m[c]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};l=0;let f=0;for(;l<a;)m[i[l]].vertexTriangles.push(f),++m[i[l]].numLiveTriangles,m[i[l+1]].vertexTriangles.push(f),++m[i[l+1]].numLiveTriangles,m[i[l+2]].vertexTriangles.push(f),++m[i[l+2]].numLiveTriangles,++f,l+=3;let y=0,h=o+1;s=1;let d=[],v=[],b,g,A=0,x=[],P=a/3,N=[];for(c=0;c<P;c++)N[c]=!1;for(;-1!==y;){d=[],r=(g=m[y]).vertexTriangles.length;for(let e=0;e<r;++e)if(!N[f=g.vertexTriangles[e]]){N[f]=!0,l=f+f+f;for(let e=0;e<3;++e)t=i[l],d.push(t),v.push(t),x[A]=t,++A,b=m[t],--b.numLiveTriangles,h-b.timeStamp>o&&(b.timeStamp=h,++h),++l}y=function(e,t,r,i,n,o,a){let u=-1,l,p=-1,m=0;for(;m<r.length;){let e=r[m];i[e].numLiveTriangles&&(l=0,n-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(l=n-i[e].timeStamp),(l>p||-1===p)&&(p=l,u=e)),++m}return -1===u?function(e,t,r,i){for(;t.length>=1;){let r=t[t.length-1];if(t.splice(t.length-1,1),e[r].numLiveTriangles>0)return r}for(;s<i;){if(e[s].numLiveTriangles>0)return++s-1;++s}return -1}(i,o,0,a):u}(0,o,d,m,h,v,u)}return x};var O={};function L(e,t,r,i,n){e[t++]=r,e[t++]=i,e[t++]=i,e[t++]=n,e[t++]=n,e[t]=r}function z(e){let t={};for(let r in e)if(e.hasOwnProperty(r)&&S(e[r])&&S(e[r].values)){let i=e[r];t[r]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}O.toWireframe=function(e){if(!S(e))throw new T("geometry is required.");let t=e.indices;if(S(t)){switch(e.primitiveType){case s.TRIANGLES:e.indices=function(e){let t=e.length,r=n.createTypedArray(t,t/3*6),i=0;for(let n=0;n<t;n+=3,i+=6)L(r,i,e[n],e[n+1],e[n+2]);return r}(t);break;case s.TRIANGLE_STRIP:e.indices=function(e){let t=e.length;if(t>=3){let r=n.createTypedArray(t,(t-2)*6);L(r,0,e[0],e[1],e[2]);let i=6;for(let n=3;n<t;++n,i+=6)L(r,i,e[n-1],e[n],e[n-2]);return r}return new Uint16Array}(t);break;case s.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){let t=e.length-1,r=n.createTypedArray(t,(t-1)*6),i=e[0],o=0;for(let n=1;n<t;++n,o+=6)L(r,o,i,e[n],e[n+1]);return r}return new Uint16Array}(t);break;default:throw new T("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=s.LINES}return e},O.createLineSegmentsForVectors=function(e,t,r){if(t=t??"normal",!S(e))throw new T("geometry is required.");if(!S(e.attributes.position))throw new T("geometry.attributes.position is required.");if(!S(e.attributes[t]))throw new T(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);r=r??1e4;let i=e.attributes.position.values,n=e.attributes[t].values,o=i.length,l=new Float64Array(2*o),m=0;for(let e=0;e<o;e+=3)l[m++]=i[e],l[m++]=i[e+1],l[m++]=i[e+2],l[m++]=i[e]+n[e]*r,l[m++]=i[e+1]+n[e+1]*r,l[m++]=i[e+2]+n[e+2]*r;let c,f=e.boundingSphere;return S(f)&&(c=new p(f.center,f.radius+r)),new a({attributes:{position:new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:l})},primitiveType:s.LINES,boundingSphere:c})},O.createAttributeLocations=function(e){if(!S(e))throw new T("geometry is required.");let t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],r=e.attributes,i={},n=0,o,s=t.length;for(o=0;o<s;++o){let e=t[o];S(r[e])&&(i[e]=n++)}for(let e in r)r.hasOwnProperty(e)&&!S(i[e])&&(i[e]=n++);return i},O.reorderForPreVertexCache=function(e){if(!S(e))throw new T("geometry is required.");let t=a.computeNumberOfVertices(e),r=e.indices;if(S(r)){let i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;let o=r.length,s=n.createTypedArray(t,o),a=0,u=0,l=0,p;for(;a<o;)-1!==(p=i[r[a]])?s[u]=p:(i[p=r[a]]=l,s[u]=l,++l),++a,++u;e.indices=s;let m=e.attributes;for(let e in m)if(m.hasOwnProperty(e)&&S(m[e])&&S(m[e].values)){let r=m[e],n=r.values,o=0,s=r.componentsPerAttribute,a=y.createTypedArray(r.componentDatatype,l*s);for(;o<t;){let e=i[o];if(-1!==e)for(let t=0;t<s;t++)a[s*e+t]=n[s*o+t];++o}r.values=a}}return e},O.reorderForPostVertexCache=function(e,t){if(!S(e))throw new T("geometry is required.");let r=e.indices;if(e.primitiveType===s.TRIANGLES&&S(r)){let i=r.length,n=0;for(let e=0;e<i;e++)r[e]>n&&(n=r[e]);e.indices=I.tipsify({indices:r,maximumIndex:n,cacheSize:t})}return e},O.fitToUnsignedShortIndices=function(e){if(!S(e))throw new T("geometry is required.");if(S(e.indices)&&e.primitiveType!==s.TRIANGLES&&e.primitiveType!==s.LINES&&e.primitiveType!==s.POINTS)throw new T("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");let t=[],r=a.computeNumberOfVertices(e);if(S(e.indices)&&r>=g.SIXTY_FOUR_KILOBYTES){let r=[],i=[],n=0,o=z(e.attributes),u=e.indices,l=u.length,p;e.primitiveType===s.TRIANGLES?p=3:e.primitiveType===s.LINES?p=2:e.primitiveType===s.POINTS&&(p=1);for(let s=0;s<l;s+=p){for(let t=0;t<p;++t){let a=u[s+t],l=r[a];S(l)||(l=n++,r[a]=l,function(e,t,r){for(let i in t)if(t.hasOwnProperty(i)&&S(t[i])&&S(t[i].values)){let n=t[i];for(let t=0;t<n.componentsPerAttribute;++t)e[i].values.push(n.values[r*n.componentsPerAttribute+t])}}(o,e.attributes,a)),i.push(l)}n+p>=g.SIXTY_FOUR_KILOBYTES&&(t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),r=[],i=[],n=0,o=z(e.attributes))}0!==i.length&&t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};var D=new v,q=new h;O.projectTo2D=function(e,t,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(t))throw new T("attributeName is required.");if(!S(r))throw new T("attributeName3D is required.");if(!S(i))throw new T("attributeName2D is required.");if(!S(e.attributes[t]))throw new T(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[t],s=(n=S(n)?n:new l).ellipsoid,a=o.values,p=new Float64Array(a.length),m=0;for(let e=0;e<a.length;e+=3){let t=v.fromArray(a,e,D),r=s.cartesianToCartographic(t,q);if(!S(r))throw new T(`Could not project point (${t.x}, ${t.y}, ${t.z}) to 2D.`);let i=n.project(r,D);p[m++]=i.x,p[m++]=i.y,p[m++]=i.z}return e.attributes[r]=o,e.attributes[i]=new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:p}),delete e.attributes[t],e};var R={high:0,low:0};O.encodeAttribute=function(e,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(r))throw new T("attributeName is required.");if(!S(i))throw new T("attributeHighName is required.");if(!S(n))throw new T("attributeLowName is required.");if(!S(e.attributes[r]))throw new T(`geometry must have attribute matching the attributeName argument: ${r}.`);if(e.attributes[r].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[r],s=o.values,a=s.length,l=new Float32Array(a),p=new Float32Array(a);for(let e=0;e<a;++e)t.encode(s[e],R),l[e]=R.high,p[e]=R.low;let m=o.componentsPerAttribute;return e.attributes[i]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:m,values:l}),e.attributes[n]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:m,values:p}),delete e.attributes[r],e};var k=new v;function G(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)v.unpack(r,t,k),f.multiplyByPoint(e,k,k),v.pack(k,r,t)}}function F(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)v.unpack(r,t,k),b.multiplyByVector(e,k,k),k=v.normalize(k,k),v.pack(k,r,t)}}var C=new f,B=new b;O.transformToWorldCoordinates=function(e){if(!S(e))throw new T("instance is required.");let t=e.modelMatrix;if(f.equals(t,f.IDENTITY))return e;let r=e.geometry.attributes;G(t,r.position),G(t,r.prevPosition),G(t,r.nextPosition),(S(r.normal)||S(r.tangent)||S(r.bitangent))&&(f.inverse(t,C),f.transpose(C,C),f.getMatrix3(C,B),F(B,r.normal),F(B,r.tangent),F(B,r.bitangent));let i=e.geometry.boundingSphere;return S(i)&&(e.geometry.boundingSphere=p.transform(i,t,i)),e.modelMatrix=f.clone(f.IDENTITY),e};var _=new v;function M(e,t){let r,i=e.length,o,l,m,c,h=e[0].modelMatrix,d=S(e[0][t].indices),b=e[0][t].primitiveType;for(l=1;l<i;++l){if(!f.equals(e[l].modelMatrix,h))throw new T("All instances must have the same modelMatrix.");if(S(e[l][t].indices)!==d)throw new T("All instance geometries must have an indices or not have one.");if(e[l][t].primitiveType!==b)throw new T("All instance geometries must have the same primitiveType.")}let w=function(e,t){let r=e.length,i={},n=e[0][t].attributes,o;for(o in n)if(n.hasOwnProperty(o)&&S(n[o])&&S(n[o].values)){let s=n[o],a=s.values.length,l=!0;for(let i=1;i<r;++i){let r=e[i][t].attributes[o];if(!S(r)||s.componentDatatype!==r.componentDatatype||s.componentsPerAttribute!==r.componentsPerAttribute||s.normalize!==r.normalize){l=!1;break}a+=r.values.length}l&&(i[o]=new u({componentDatatype:s.componentDatatype,componentsPerAttribute:s.componentsPerAttribute,normalize:s.normalize,values:y.createTypedArray(s.componentDatatype,a)}))}return i}(e,t),g,A,x;for(o in w)if(w.hasOwnProperty(o))for(g=w[o].values,c=0,l=0;l<i;++l)for(x=(A=e[l][t].attributes[o].values).length,m=0;m<x;++m)g[c++]=A[m];if(d){let o=0;for(l=0;l<i;++l)o+=e[l][t].indices.length;let u=a.computeNumberOfVertices(new a({attributes:w,primitiveType:s.POINTS})),p=n.createTypedArray(u,o),m=0,f=0;for(l=0;l<i;++l){let r=e[l][t].indices,i=r.length;for(c=0;c<i;++c)p[m++]=f+r[c];f+=a.computeNumberOfVertices(e[l][t])}r=p}let P=new v,N=0,E;for(l=0;l<i;++l){if(!S(E=e[l][t].boundingSphere)){P=void 0;break}v.add(E.center,P,P)}if(S(P))for(v.divideByScalar(P,i,P),l=0;l<i;++l){E=e[l][t].boundingSphere;let r=v.magnitude(v.subtract(E.center,P,_))+E.radius;r>N&&(N=r)}return new a({attributes:w,indices:r,primitiveType:b,boundingSphere:S(P)?new p(P,N):void 0})}O.combineInstances=function(e){if(!S(e)||e.length<1)throw new T("instances is required and must have length greater than zero.");let t=[],r=[],i=e.length;for(let n=0;n<i;++n){let i=e[n];S(i.geometry)?t.push(i):S(i.westHemisphereGeometry)&&S(i.eastHemisphereGeometry)&&r.push(i)}let n=[];return t.length>0&&n.push(M(t,"geometry")),r.length>0&&(n.push(M(r,"westHemisphereGeometry")),n.push(M(r,"eastHemisphereGeometry"))),n};var V=new v,U=new v,j=new v,Y=new v;O.computeNormal=function(e){let t;if(!S(e))throw new T("geometry is required.");if(!S(e.attributes.position)||!S(e.attributes.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(e.indices))throw new T("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let r=e.indices,i=e.attributes,n=i.position.values,o=i.position.values.length/3,a=r.length,l=Array(o),p=Array(a/3),m=Array(a),c;for(c=0;c<o;c++)l[c]={indexOffset:0,count:0,currentCount:0};let f=0;for(c=0;c<a;c+=3){let e=r[c],t=r[c+1],i=r[c+2],o=3*e,s=3*t,a=3*i;U.x=n[o],U.y=n[o+1],U.z=n[o+2],j.x=n[s],j.y=n[s+1],j.z=n[s+2],Y.x=n[a],Y.y=n[a+1],Y.z=n[a+2],l[e].count++,l[t].count++,l[i].count++,v.subtract(j,U,j),v.subtract(Y,U,Y),p[f]=v.cross(j,Y,new v),f++}let h=0;for(c=0;c<o;c++)l[c].indexOffset+=h,h+=l[c].count;for(c=0,f=0;c<a;c+=3){let e=(t=l[r[c]]).indexOffset+t.currentCount;m[e]=f,t.currentCount++,m[e=(t=l[r[c+1]]).indexOffset+t.currentCount]=f,t.currentCount++,m[e=(t=l[r[c+2]]).indexOffset+t.currentCount]=f,t.currentCount++,f++}let d=new Float32Array(3*o);for(c=0;c<o;c++){let e=3*c;if(t=l[c],v.clone(v.ZERO,V),t.count>0){for(f=0;f<t.count;f++)v.add(V,p[m[t.indexOffset+f]],V);v.equalsEpsilon(v.ZERO,V,g.EPSILON10)&&v.clone(p[m[t.indexOffset]],V)}v.equalsEpsilon(v.ZERO,V,g.EPSILON10)&&(V.z=1),v.normalize(V,V),d[e]=V.x,d[e+1]=V.y,d[e+2]=V.z}return e.attributes.normal=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:d}),e};var H=new v,Z=new v,W=new v;O.computeTangentAndBitangent=function(e){let t,r,i;if(!S(e))throw new T("geometry is required.");let n=e.attributes,o=e.indices;if(!S(n.position)||!S(n.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(n.normal)||!S(n.normal.values))throw new T("geometry.attributes.normal.values is required.");if(!S(n.st)||!S(n.st.values))throw new T("geometry.attributes.st.values is required.");if(!S(o))throw new T("geometry.indices is required.");if(o.length<2||o.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let a=e.attributes.position.values,l=e.attributes.normal.values,p=e.attributes.st.values,m=e.attributes.position.values.length/3,c=o.length,f=Array(3*m),h;for(h=0;h<f.length;h++)f[h]=0;for(h=0;h<c;h+=3){let e=o[h],n=o[h+1],s=o[h+2];t=3*e,r=3*n,i=3*s;let u=2*e,l=2*n,m=2*s,c=a[t],y=a[t+1],d=a[t+2],v=p[u],b=p[u+1],w=p[l+1]-b,g=p[m+1]-b,T=1/((p[l]-v)*g-(p[m]-v)*w),A=(g*(a[r]-c)-w*(a[i]-c))*T,S=(g*(a[r+1]-y)-w*(a[i+1]-y))*T,x=(g*(a[r+2]-d)-w*(a[i+2]-d))*T;f[t]+=A,f[t+1]+=S,f[t+2]+=x,f[r]+=A,f[r+1]+=S,f[r+2]+=x,f[i]+=A,f[i+1]+=S,f[i+2]+=x}let d=new Float32Array(3*m),b=new Float32Array(3*m);for(h=0;h<m;h++){r=(t=3*h)+1,i=t+2;let e=v.fromArray(l,t,H),n=v.fromArray(f,t,W),o=v.dot(e,n);v.multiplyByScalar(e,o,Z),v.normalize(v.subtract(n,Z,n),n),d[t]=n.x,d[r]=n.y,d[i]=n.z,v.normalize(v.cross(e,n,n),n),b[t]=n.x,b[r]=n.y,b[i]=n.z}return e.attributes.tangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:d}),e.attributes.bitangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:b}),e};var K=new d,X=new v,J=new v,$=new v,Q=new d;function ee(e,t){Math.abs(e.y)<g.EPSILON6&&(t?e.y=-g.EPSILON6:e.y=g.EPSILON6)}O.compressVertices=function(t){if(!S(t))throw new T("geometry is required.");let r=t.attributes.extrudeDirection,i,n;if(S(r)){let o=r.values,s=new Float32Array(2*(n=o.length/3)),a=0;for(i=0;i<n;++i){if(v.fromArray(o,3*i,X),v.equals(X,v.ZERO)){a+=2;continue}Q=e.octEncodeInRange(X,65535,Q),s[a++]=Q.x,s[a++]=Q.y}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:2,values:s}),delete t.attributes.extrudeDirection,t}let o=t.attributes.normal,s=t.attributes.st,a=S(o),l=S(s);if(!a&&!l)return t;let p=t.attributes.tangent,m=t.attributes.bitangent,c=S(p),f=S(m),h,b,w,g;a&&(h=o.values),l&&(b=s.values),c&&(w=p.values),f&&(g=m.values);let A=n=(a?h.length:b.length)/(a?3:2),x=l&&a?2:1;x+=c||f?1:0;let P=new Float32Array(A*=x),N=0;for(i=0;i<n;++i){l&&(d.fromArray(b,2*i,K),P[N++]=e.compressTextureCoordinates(K));let t=3*i;a&&S(w)&&S(g)?(v.fromArray(h,t,X),v.fromArray(w,t,J),v.fromArray(g,t,$),e.octPack(X,J,$,K),P[N++]=K.x,P[N++]=K.y):(a&&(v.fromArray(h,t,X),P[N++]=e.octEncodeFloat(X)),c&&(v.fromArray(w,t,X),P[N++]=e.octEncodeFloat(X)),f&&(v.fromArray(g,t,X),P[N++]=e.octEncodeFloat(X)))}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:x,values:P}),a&&delete t.attributes.normal,l&&delete t.attributes.st,f&&delete t.attributes.bitangent,c&&delete t.attributes.tangent,t};var et=new v;function er(e,t,r,i){v.add(e,v.multiplyByScalar(v.subtract(t,e,et),e.y/(e.y-t.y),et),r),v.clone(r,i),ee(r,!0),ee(i,!1)}var ei=new v,en=new v,eo=new v,es=new v,ea={positions:Array(7),indices:Array(9)};function eu(e,t){let r=e.attributes;if(0===r.position.values.length)return;for(let e in r)if(r.hasOwnProperty(e)&&S(r[e])&&S(r[e].values)){let t=r[e];t.values=y.createTypedArray(t.componentDatatype,t.values)}let i=a.computeNumberOfVertices(e);return e.indices=n.createTypedArray(i,e.indices),t&&(e.boundingSphere=p.fromVertices(r.position.values)),e}function el(e){let t=e.attributes,r={};for(let e in t)if(t.hasOwnProperty(e)&&S(t[e])&&S(t[e].values)){let i=t[e];r[e]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new a({attributes:r,indices:[],primitiveType:e.primitiveType})}function ep(e,t,r){let i=S(e.geometry.boundingSphere);t=eu(t,i),S(r=eu(r,i))&&!S(t)?e.geometry=r:!S(r)&&S(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=r,e.geometry=void 0)}function em(e,t){let r=new e,i=new e,n=new e;return function(o,s,a,u,l,p,m,c){let f=e.fromArray(l,o*t,r),y=e.fromArray(l,s*t,i),h=e.fromArray(l,a*t,n);e.multiplyByScalar(f,u.x,f),e.multiplyByScalar(y,u.y,y),e.multiplyByScalar(h,u.z,h);let d=e.add(f,y,f);e.add(d,h,d),c&&e.normalize(d,d),e.pack(d,p,m*t)}}var ec=em(c,4),ef=em(v,3),ey=em(d,2),eh=function(e,t,r,i,n,o,s){let a=n[e]*i.x,u=n[t]*i.y,l=n[r]*i.z;o[s]=+(a+u+l>g.EPSILON6)},ed=new v,ev=new v,eb=new v,ew=new v;function eg(e,t,r,i,n,o,s,a,u,l,p,m,c,f,y,h){if(!S(o)&&!S(s)&&!S(a)&&!S(u)&&!S(l)&&0===f)return;let d=E(i,v.fromArray(n,3*e,ed),v.fromArray(n,3*t,ev),v.fromArray(n,3*r,eb),ew);if(S(d)){if(S(o)&&ef(e,t,r,d,o,m.normal.values,h,!0),S(l)){let i,n=v.fromArray(l,3*e,ed),o=v.fromArray(l,3*t,ev),s=v.fromArray(l,3*r,eb);v.multiplyByScalar(n,d.x,n),v.multiplyByScalar(o,d.y,o),v.multiplyByScalar(s,d.z,s),v.equals(n,v.ZERO)&&v.equals(o,v.ZERO)&&v.equals(s,v.ZERO)?((i=ed).x=0,i.y=0,i.z=0):(i=v.add(n,o,n),v.add(i,s,i),v.normalize(i,i)),v.pack(i,m.extrudeDirection.values,3*h)}if(S(p)&&eh(e,t,r,d,p,m.applyOffset.values,h),S(s)&&ef(e,t,r,d,s,m.tangent.values,h,!0),S(a)&&ef(e,t,r,d,a,m.bitangent.values,h,!0),S(u)&&ey(e,t,r,d,u,m.st.values,h),f>0)for(let i=0;i<f;i++){let n=c[i];!function(e,t,r,i,n,o,s){let a=o.componentsPerAttribute,u=o.values,l=s.values;switch(a){case 4:ec(e,t,r,i,u,l,n,!1);break;case 3:ef(e,t,r,i,u,l,n,!1);break;case 2:ey(e,t,r,i,u,l,n,!1);break;default:l[n]=u[e]*i.x+u[t]*i.y+u[r]*i.z}}(e,t,r,d,h,y[n],m[n])}}}function eT(e,t,r,i,n,o){let s=e.position.values.length/3;if(-1!==n){let a=i[n],u=r[a];return -1===u?(r[a]=s,e.position.values.push(o.x,o.y,o.z),t.push(s),s):(t.push(u),u)}return e.position.values.push(o.x,o.y,o.z),t.push(s),s}var eA={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function eS(e){let t=e.geometry,r=t.attributes,i=r.position.values,n=S(r.normal)?r.normal.values:void 0,o=S(r.bitangent)?r.bitangent.values:void 0,s=S(r.tangent)?r.tangent.values:void 0,a=S(r.st)?r.st.values:void 0,u=S(r.extrudeDirection)?r.extrudeDirection.values:void 0,l=S(r.applyOffset)?r.applyOffset.values:void 0,p=t.indices,m=[];for(let e in r)r.hasOwnProperty(e)&&!eA[e]&&S(r[e])&&m.push(e);let c=m.length,f=el(t),y=el(t),h,d,b,w,T,A=[];A.length=i.length/3;let x=[];for(x.length=i.length/3,T=0;T<A.length;++T)A[T]=-1,x[T]=-1;let P=p.length;for(T=0;T<P;T+=3){let e=p[T],t=p[T+1],P=p[T+2],N=v.fromArray(i,3*e),E=v.fromArray(i,3*t),I=v.fromArray(i,3*P),O=function(e,t,r){if(e.x>=0||t.x>=0||r.x>=0)return;!function(e,t,r){if(0!==e.y&&0!==t.y&&0!==r.y){ee(e,e.y<0),ee(t,t.y<0),ee(r,r.y<0);return}let i=Math.abs(e.y),n=Math.abs(t.y),o=Math.abs(r.y),s=(i>n?i>o?g.sign(e.y):g.sign(r.y):n>o?g.sign(t.y):g.sign(r.y))<0;ee(e,s),ee(t,s),ee(r,s)}(e,t,r);let i=e.y<0,n=t.y<0,o=r.y<0,s;s=0+(+!!i+ +!!n+ +!!o);let a=ea.indices;1===s?(a[1]=3,a[2]=4,a[5]=6,a[7]=6,a[8]=5,i?(er(e,t,ei,eo),er(e,r,en,es),a[0]=0,a[3]=1,a[4]=2,a[6]=1):n?(er(t,r,ei,eo),er(t,e,en,es),a[0]=1,a[3]=2,a[4]=0,a[6]=2):o&&(er(r,e,ei,eo),er(r,t,en,es),a[0]=2,a[3]=0,a[4]=1,a[6]=0)):2===s&&(a[2]=4,a[4]=4,a[5]=3,a[7]=5,a[8]=6,i?n?o||(er(r,e,ei,eo),er(r,t,en,es),a[0]=0,a[1]=1,a[3]=0,a[6]=2):(er(t,r,ei,eo),er(t,e,en,es),a[0]=2,a[1]=0,a[3]=2,a[6]=1):(er(e,t,ei,eo),er(e,r,en,es),a[0]=1,a[1]=2,a[3]=1,a[6]=0));let u=ea.positions;return u[0]=e,u[1]=t,u[2]=r,u.length=3,(1===s||2===s)&&(u[3]=ei,u[4]=en,u[5]=eo,u[6]=es,u.length=7),ea}(N,E,I);if(S(O)&&O.positions.length>3){let v=O.positions,g=O.indices,S=g.length;for(let N=0;N<S;++N){let S=g[N],E=v[S];E.y<0?(h=y.attributes,d=y.indices,b=A):(h=f.attributes,d=f.indices,b=x),w=eT(h,d,b,p,S<3?T+S:-1,E),eg(e,t,P,E,i,n,s,o,a,u,l,h,m,c,r,w)}}else S(O)&&(N=O.positions[0],E=O.positions[1],I=O.positions[2]),N.y<0?(h=y.attributes,d=y.indices,b=A):(h=f.attributes,d=f.indices,b=x),w=eT(h,d,b,p,T,N),eg(e,t,P,N,i,n,s,o,a,u,l,h,m,c,r,w),w=eT(h,d,b,p,T+1,E),eg(e,t,P,E,i,n,s,o,a,u,l,h,m,c,r,w),w=eT(h,d,b,p,T+2,I),eg(e,t,P,I,i,n,s,o,a,u,l,h,m,c,r,w)}ep(e,y,f)}var ex=i.fromPointNormal(v.ZERO,v.UNIT_Y),eP=new v,eN=new v;function eE(e,t,r,i,n,o,s){if(!S(s))return;let a=v.fromArray(i,3*e,ed);v.equalsEpsilon(a,r,g.EPSILON10)?o.applyOffset.values[n]=s[e]:o.applyOffset.values[n]=s[t]}function eI(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=S(i.applyOffset)?i.applyOffset.values:void 0,s=t.indices,a=el(t),u=el(t),l,p=s.length,m=[];m.length=n.length/3;let c=[];for(c.length=n.length/3,l=0;l<m.length;++l)m[l]=-1,c[l]=-1;for(l=0;l<p;l+=2){let e=s[l],t=s[l+1],i=v.fromArray(n,3*e,ed),p=v.fromArray(n,3*t,ev),f;Math.abs(i.y)<g.EPSILON6&&(i.y<0?i.y=-g.EPSILON6:i.y=g.EPSILON6),Math.abs(p.y)<g.EPSILON6&&(p.y<0?p.y=-g.EPSILON6:p.y=g.EPSILON6);let y=a.attributes,h=a.indices,d=c,b=u.attributes,w=u.indices,T=m,A=r.lineSegmentPlane(i,p,ex,eb);if(S(A)){let r=v.multiplyByScalar(v.UNIT_Y,5*g.EPSILON9,eP);i.y<0&&(v.negate(r,r),y=u.attributes,h=u.indices,d=m,b=a.attributes,w=a.indices,T=c);let S=v.add(A,r,eN);f=eT(y,h,d,s,l,i),eE(e,t,i,n,f,y,o),f=eT(y,h,d,s,-1,S),eE(e,t,S,n,f,y,o),v.negate(r,r),v.add(A,r,S),f=eT(b,w,T,s,-1,S),eE(e,t,S,n,f,b,o),f=eT(b,w,T,s,l+1,p),eE(e,t,p,n,f,b,o)}else{let r,y,h;i.y<0?(r=u.attributes,y=u.indices,h=m):(r=a.attributes,y=a.indices,h=c),f=eT(r,y,h,s,l,i),eE(e,t,i,n,f,r,o),f=eT(r,y,h,s,l+1,p),eE(e,t,p,n,f,r,o)}}ep(e,u,a)}var eO=new d,eL=new d,ez=new v,eD=new v,eq=new v,eR=new v,ek=new v,eG=new v,eF=new c;function eC(e){let t=e.attributes,r=t.position.values,i=t.prevPosition.values,n=t.nextPosition.values,o=r.length;for(let e=0;e<o;e+=3){let t=v.unpack(r,e,ez);if(t.x>0)continue;let s=v.unpack(i,e,eD);(t.y<0&&s.y>0||t.y>0&&s.y<0)&&(e-3>0?(i[e]=r[e-3],i[e+1]=r[e-2],i[e+2]=r[e-1]):v.pack(t,i,e));let a=v.unpack(n,e,eq);(t.y<0&&a.y>0||t.y>0&&a.y<0)&&(e+3<o?(n[e]=r[e+3],n[e+1]=r[e+4],n[e+2]=r[e+5]):v.pack(t,n,e))}}var eB=5*g.EPSILON9,e_=g.EPSILON6;O.splitLongitude=function(e){if(!S(e))throw new T("instance is required.");let t=e.geometry,u=t.boundingSphere;if(S(u)&&(u.center.x-u.radius>0||p.intersectPlane(u,i.ORIGIN_ZX_PLANE)!==m.INTERSECTING))return e;if(t.geometryType!==o.NONE)switch(t.geometryType){case o.POLYLINES:!function(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=i.prevPosition.values,s=i.nextPosition.values,a=i.expandAndWidth.values,u=S(i.st)?i.st.values:void 0,l=S(i.color)?i.color.values:void 0,p=el(t),m=el(t),f,y,h,b=!1,w=n.length/3;for(f=0;f<w;f+=4){let e=f,t=f+2,i=v.fromArray(n,3*e,ez),w=v.fromArray(n,3*t,eD);if(Math.abs(i.y)<e_)for(i.y=e_*(w.y<0?-1:1),n[3*f+1]=i.y,n[(f+1)*3+1]=i.y,y=3*e;y<3*e+12;y+=3)o[y]=n[3*f],o[y+1]=n[3*f+1],o[y+2]=n[3*f+2];if(Math.abs(w.y)<e_)for(w.y=e_*(i.y<0?-1:1),n[(f+2)*3+1]=w.y,n[(f+3)*3+1]=w.y,y=3*e;y<3*e+12;y+=3)s[y]=n[(f+2)*3],s[y+1]=n[(f+2)*3+1],s[y+2]=n[(f+2)*3+2];let T=p.attributes,A=p.indices,x=m.attributes,P=m.indices,N=r.lineSegmentPlane(i,w,ex,eR);if(S(N)){b=!0;let r=v.multiplyByScalar(v.UNIT_Y,eB,ek);i.y<0&&(v.negate(r,r),T=m.attributes,A=m.indices,x=p.attributes,P=p.indices);let n=v.add(N,r,eG);T.position.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.position.values.push(n.x,n.y,n.z),T.position.values.push(n.x,n.y,n.z),T.prevPosition.values.push(o[3*e],o[3*e+1],o[3*e+2]),T.prevPosition.values.push(o[3*e+3],o[3*e+4],o[3*e+5]),T.prevPosition.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),v.negate(r,r),v.add(N,r,n),x.position.values.push(n.x,n.y,n.z),x.position.values.push(n.x,n.y,n.z),x.position.values.push(w.x,w.y,w.z,w.x,w.y,w.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.nextPosition.values.push(w.x,w.y,w.z,w.x,w.y,w.z),x.nextPosition.values.push(s[3*t],s[3*t+1],s[3*t+2]),x.nextPosition.values.push(s[3*t+3],s[3*t+4],s[3*t+5]);let E=Math.abs(d.fromArray(a,2*e,eO).y);T.expandAndWidth.values.push(-1,E,1,E),T.expandAndWidth.values.push(-1,-E,1,-E),x.expandAndWidth.values.push(-1,E,1,E),x.expandAndWidth.values.push(-1,-E,1,-E);let I=v.magnitudeSquared(v.subtract(N,i,eq));if(I/=v.magnitudeSquared(v.subtract(w,i,eq)),S(l)){let r=c.fromArray(l,4*e,eF),i=c.fromArray(l,4*t,eF),n=g.lerp(r.x,i.x,I),o=g.lerp(r.y,i.y,I),s=g.lerp(r.z,i.z,I),a=g.lerp(r.w,i.w,I);for(y=4*e;y<4*e+8;++y)T.color.values.push(l[y]);for(T.color.values.push(n,o,s,a),T.color.values.push(n,o,s,a),x.color.values.push(n,o,s,a),x.color.values.push(n,o,s,a),y=4*t;y<4*t+8;++y)x.color.values.push(l[y])}if(S(u)){let r=d.fromArray(u,2*e,eO),i=d.fromArray(u,(f+3)*2,eL),n=g.lerp(r.x,i.x,I);for(y=2*e;y<2*e+4;++y)T.st.values.push(u[y]);for(T.st.values.push(n,r.y),T.st.values.push(n,i.y),x.st.values.push(n,r.y),x.st.values.push(n,i.y),y=2*t;y<2*t+4;++y)x.st.values.push(u[y])}h=T.position.values.length/3-4,A.push(h,h+2,h+1),A.push(h+1,h+2,h+3),h=x.position.values.length/3-4,P.push(h,h+2,h+1),P.push(h+1,h+2,h+3)}else{let e,t;for(i.y<0?(e=m.attributes,t=m.indices):(e=p.attributes,t=p.indices),e.position.values.push(i.x,i.y,i.z),e.position.values.push(i.x,i.y,i.z),e.position.values.push(w.x,w.y,w.z),e.position.values.push(w.x,w.y,w.z),y=3*f;y<3*f+12;++y)e.prevPosition.values.push(o[y]),e.nextPosition.values.push(s[y]);for(y=2*f;y<2*f+8;++y)e.expandAndWidth.values.push(a[y]),S(u)&&e.st.values.push(u[y]);if(S(l))for(y=4*f;y<4*f+16;++y)e.color.values.push(l[y]);h=e.position.values.length/3-4,t.push(h,h+2,h+1),t.push(h+1,h+2,h+3)}}b&&(eC(m),eC(p)),ep(e,m,p)}(e);break;case o.TRIANGLES:eS(e);break;case o.LINES:eI(e)}else(function(e){switch(e.primitiveType){case s.TRIANGLE_FAN:let t=a.computeNumberOfVertices(e);if(t<3)throw new T("The number of vertices must be at least three.");let r=n.createTypedArray(t,(t-2)*3);r[0]=1,r[1]=0,r[2]=2;let i=3;for(let e=3;e<t;++e)r[i++]=e-1,r[i++]=0,r[i++]=e;return e.indices=r,e.primitiveType=s.TRIANGLES;case s.TRIANGLE_STRIP:let o=a.computeNumberOfVertices(e);if(o<3)throw new T("The number of vertices must be at least 3.");let u=n.createTypedArray(o,(o-2)*3);u[0]=0,u[1]=1,u[2]=2,o>3&&(u[3]=0,u[4]=2,u[5]=3);let l=6;for(let e=3;e<o-1;e+=2)u[l++]=e,u[l++]=e-1,u[l++]=e+1,e+2<o&&(u[l++]=e,u[l++]=e+1,u[l++]=e+2);return e.indices=u,e.primitiveType=s.TRIANGLES;case s.TRIANGLES:if(S(e.indices))return;let p=a.computeNumberOfVertices(e);if(p<3)throw new T("The number of vertices must be at least three.");if(p%3!=0)throw new T("The number of vertices must be a multiple of three.");let m=n.createTypedArray(p,p);for(let e=0;e<p;++e)m[e]=e;return e.indices=m;case s.LINE_STRIP:let c=a.computeNumberOfVertices(e);if(c<2)throw new T("The number of vertices must be at least two.");let f=n.createTypedArray(c,(c-1)*2);f[0]=0,f[1]=1;let y=2;for(let e=2;e<c;++e)f[y++]=e-1,f[y++]=e;return e.indices=f,e.primitiveType=s.LINES;case s.LINE_LOOP:let h=a.computeNumberOfVertices(e);if(h<2)throw new T("The number of vertices must be at least two.");let d=n.createTypedArray(h,2*h);d[0]=0,d[1]=1;let v=2;for(let e=2;e<h;++e)d[v++]=e-1,d[v++]=e;return d[v++]=h-1,d[v]=0,e.indices=d,e.primitiveType=s.LINES;case s.LINES:if(S(e.indices))return;let b=a.computeNumberOfVertices(e);if(b<2)throw new T("The number of vertices must be at least two.");if(b%2!=0)throw new T("The number of vertices must be a multiple of 2.");let w=n.createTypedArray(b,b);for(let e=0;e<b;++e)w[e]=e;return e.indices=w}})(t),t.primitiveType===s.TRIANGLES?eS(e):t.primitiveType===s.LINES&&eI(e);return e};var eM=O;export{eM as a};