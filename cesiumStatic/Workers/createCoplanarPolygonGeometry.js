import{a as t}from"./chunk-WA4PTCEU.js";import{a as e}from"./chunk-JFW4S7F5.js";import"./chunk-AZKYNZOH.js";import{a as o}from"./chunk-LFYJT7PG.js";import"./chunk-XQCNGPKC.js";import{a as n}from"./chunk-SYTPJOV4.js";import{a as r}from"./chunk-YJI7JXLA.js";import"./chunk-DAX2P4DI.js";import"./chunk-RKB2XVMW.js";import{a as i}from"./chunk-ZXZD7KWX.js";import"./chunk-SI3KZUTO.js";import"./chunk-QM7HI6IF.js";import{b as a}from"./chunk-45FW5IBC.js";import{a as s}from"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as c}from"./chunk-KSX6TRAS.js";import{a as p}from"./chunk-GMTHOMGW.js";import{b as l,c as u,d as m}from"./chunk-BELR52CD.js";import{c as h}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import{h as y}from"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as g}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{b as d,c as k}from"./chunk-ICY67TC6.js";import{a as f,b as j,c as w}from"./chunk-G2EMNOST.js";import{a as A}from"./chunk-4VFKVGYI.js";import{b as T}from"./chunk-3WJNS2B6.js";import{e as x}from"./chunk-XCN226AA.js";var F=new f,P=new t,v=new d,b=new d,_=new f,H=new f,L=new f,C=new f,I=new f,D=new f,E=new y,N=new j,O=new j,R=new f;function B(t){let e=(t=t??w.EMPTY_OBJECT).polygonHierarchy,n=t.textureCoordinates;T.defined("options.polygonHierarchy",e);let r=t.vertexFormat??i.DEFAULT;this._vertexFormat=i.clone(r),this._polygonHierarchy=e,this._stRotation=t.stRotation??0,this._ellipsoid=k.clone(t.ellipsoid??k.default),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=n,this.packedLength=o.computeHierarchyPackedLength(e,f)+i.packedLength+k.packedLength+(x(n)?o.computeHierarchyPackedLength(n,d):1)+2}B.fromPositions=function(t){return t=t??w.EMPTY_OBJECT,T.defined("options.positions",t.positions),new B({polygonHierarchy:{positions:t.positions},vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,textureCoordinates:t.textureCoordinates})},B.pack=function(t,e,n){return T.typeOf.object("value",t),T.defined("array",e),n=n??0,n=o.packPolygonHierarchy(t._polygonHierarchy,e,n,f),k.pack(t._ellipsoid,e,n),n+=k.packedLength,i.pack(t._vertexFormat,e,n),n+=i.packedLength,e[n++]=t._stRotation,x(t._textureCoordinates)?n=o.packPolygonHierarchy(t._textureCoordinates,e,n,d):e[n++]=-1,e[n++]=t.packedLength,e};var S=k.clone(k.UNIT_SPHERE),Y=new i,G={polygonHierarchy:{}};B.unpack=function(t,e,n){T.defined("array",t),e=e??0;let r=o.unpackPolygonHierarchy(t,e,f);e=r.startingIndex,delete r.startingIndex;let a=k.unpack(t,e,S);e+=k.packedLength;let s=i.unpack(t,e,Y);e+=i.packedLength;let c=t[e++],p=-1===t[e]?void 0:o.unpackPolygonHierarchy(t,e,d);x(p)?(e=p.startingIndex,delete p.startingIndex):e++;let l=t[e++];return x(n)||(n=new B(G)),n._polygonHierarchy=r,n._ellipsoid=k.clone(a,n._ellipsoid),n._vertexFormat=i.clone(s,n._vertexFormat),n._stRotation=c,n._textureCoordinates=p,n.packedLength=l,n},B.createGeometry=function(t){let i=t._vertexFormat,k=t._polygonHierarchy,w=t._stRotation,T=t._textureCoordinates,B=x(T),S=k.positions;if((S=s(S,f.equalsEpsilon,!0)).length<3)return;let Y=_,G=H,M=L,K=I;if(!e.computeProjectTo2DArguments(S,C,K,D))return;if(Y=f.cross(K,D,Y),Y=f.normalize(Y,Y),!f.equalsEpsilon(C,f.ZERO,A.EPSILON6)){let e=t._ellipsoid.geodeticSurfaceNormal(C,R);0>f.dot(Y,e)&&(Y=f.negate(Y,Y),K=f.negate(K,K))}let V=e.createProjectPointsTo2DFunction(C,K,D),W=e.createProjectPointTo2DFunction(C,K,D);i.tangent&&(G=f.clone(K,G)),i.bitangent&&(M=f.clone(D,M));let X=o.polygonsFromHierarchy(k,B,V,!1),J=X.hierarchy,z=X.polygons,Q=B?o.polygonsFromHierarchy(T,!0,function(t){return t},!1).polygons:void 0;if(0===J.length)return;S=J[0].outerRing;let U=h.fromPoints(S),Z=o.computeBoundingRectangle(Y,W,S,w,P),q=[];for(let t=0;t<z.length;t++){let e=new n({geometry:function(t,e,o,n,r,i,s,h,k){let w=t.positions,T=a.triangulate(t.positions2D,t.holes);T.length<3&&(T=[0,1,2]);let P=c.createTypedArray(w.length,T.length);P.set(T);let _=N;if(0!==n){let t=y.fromAxisAngle(s,n,E);if(_=j.fromQuaternion(t,_),e.tangent||e.bitangent){t=y.fromAxisAngle(s,-n,E);let o=j.fromQuaternion(t,O);h=f.normalize(j.multiplyByVector(o,h,h),h),e.bitangent&&(k=f.normalize(f.cross(s,h,k),k))}}else _=j.clone(j.IDENTITY,_);e.st&&(b.x=o.x,b.y=o.y);let H=w.length,L=3*H,C=new Float64Array(L),I=e.normal?new Float32Array(L):void 0,D=e.tangent?new Float32Array(L):void 0,R=e.bitangent?new Float32Array(L):void 0,B=e.st?new Float32Array(2*H):void 0,S=0,Y=0,G=0,M=0,K=0;for(let t=0;t<H;t++){let n=w[t];if(C[S++]=n.x,C[S++]=n.y,C[S++]=n.z,e.st)if(x(r)&&r.positions.length===H)B[K++]=r.positions[t].x,B[K++]=r.positions[t].y;else{let t=i(j.multiplyByVector(_,n,F),v);d.subtract(t,b,t);let e=A.clamp(t.x/o.width,0,1),r=A.clamp(t.y/o.height,0,1);B[K++]=e,B[K++]=r}e.normal&&(I[Y++]=s.x,I[Y++]=s.y,I[Y++]=s.z),e.tangent&&(D[M++]=h.x,D[M++]=h.y,D[M++]=h.z),e.bitangent&&(R[G++]=k.x,R[G++]=k.y,R[G++]=k.z)}let V=new p;return e.position&&(V.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:C})),e.normal&&(V.normal=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:I})),e.tangent&&(V.tangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:D})),e.bitangent&&(V.bitangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:R})),e.st&&(V.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:B})),new u({attributes:V,indices:P,primitiveType:l.TRIANGLES})}(z[t],i,Z,w,B?Q[t]:void 0,W,Y,G,M)});q.push(e)}let $=r.combineInstances(q)[0];$.attributes.position.values=new Float64Array($.attributes.position.values),$.indices=c.createTypedArray($.attributes.position.values.length/3,$.indices);let tt=$.attributes;return i.position||delete tt.position,new u({attributes:tt,indices:$.indices,primitiveType:$.primitiveType,boundingSphere:U})};var M=function(t,e){return x(e)&&(t=B.unpack(t,e)),B.createGeometry(t)};export{M as default};