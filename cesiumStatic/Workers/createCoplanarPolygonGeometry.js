import{a as t}from"./chunk-AEXJAIC2.js";import{a as e}from"./chunk-BLHXNU6V.js";import"./chunk-RNCQLKJ3.js";import{a as o}from"./chunk-UILVE4UW.js";import"./chunk-MCM3P7ZC.js";import{a as n}from"./chunk-3QPLNPJT.js";import{a as r}from"./chunk-UPV7RDUS.js";import"./chunk-NPKIHRIX.js";import"./chunk-MUKCYY2X.js";import{a as i}from"./chunk-PXD6ATBI.js";import"./chunk-33M5C4LG.js";import"./chunk-X2JOWFTB.js";import{b as a}from"./chunk-TN2BIDXM.js";import{a as s}from"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as c}from"./chunk-GSMLTRAL.js";import{a as p}from"./chunk-IUX576XK.js";import{b as l,c as u,d as m}from"./chunk-UIGT6VOJ.js";import{c as h}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import{h as y}from"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as g}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{b as d,c as k}from"./chunk-KCR7AORG.js";import{a as f,b as j,c as w}from"./chunk-QDJTHWTA.js";import{a as P}from"./chunk-2YWR3G22.js";import{b as x}from"./chunk-HTSQLHXI.js";import{e as A}from"./chunk-JDAHMWM5.js";var T=new f,v=new t,F=new d,L=new d,b=new f,_=new f,H=new f,I=new f,E=new f,C=new f,R=new y,D=new j,O=new j,B=new f;function G(t){let e=(t=t??w.EMPTY_OBJECT).polygonHierarchy,n=t.textureCoordinates;x.defined("options.polygonHierarchy",e);let r=t.vertexFormat??i.DEFAULT;this._vertexFormat=i.clone(r),this._polygonHierarchy=e,this._stRotation=t.stRotation??0,this._ellipsoid=k.clone(t.ellipsoid??k.default),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=n,this.packedLength=o.computeHierarchyPackedLength(e,f)+i.packedLength+k.packedLength+(A(n)?o.computeHierarchyPackedLength(n,d):1)+2}G.fromPositions=function(t){return t=t??w.EMPTY_OBJECT,x.defined("options.positions",t.positions),new G({polygonHierarchy:{positions:t.positions},vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,textureCoordinates:t.textureCoordinates})},G.pack=function(t,e,n){return x.typeOf.object("value",t),x.defined("array",e),n=n??0,n=o.packPolygonHierarchy(t._polygonHierarchy,e,n,f),k.pack(t._ellipsoid,e,n),n+=k.packedLength,i.pack(t._vertexFormat,e,n),n+=i.packedLength,e[n++]=t._stRotation,A(t._textureCoordinates)?n=o.packPolygonHierarchy(t._textureCoordinates,e,n,d):e[n++]=-1,e[n++]=t.packedLength,e};var N=k.clone(k.UNIT_SPHERE),X=new i,M={polygonHierarchy:{}};G.unpack=function(t,e,n){x.defined("array",t),e=e??0;let r=o.unpackPolygonHierarchy(t,e,f);e=r.startingIndex,delete r.startingIndex;let a=k.unpack(t,e,N);e+=k.packedLength;let s=i.unpack(t,e,X);e+=i.packedLength;let c=t[e++],p=-1===t[e]?void 0:o.unpackPolygonHierarchy(t,e,d);A(p)?(e=p.startingIndex,delete p.startingIndex):e++;let l=t[e++];return A(n)||(n=new G(M)),n._polygonHierarchy=r,n._ellipsoid=k.clone(a,n._ellipsoid),n._vertexFormat=i.clone(s,n._vertexFormat),n._stRotation=c,n._textureCoordinates=p,n.packedLength=l,n},G.createGeometry=function(t){let i=t._vertexFormat,k=t._polygonHierarchy,w=t._stRotation,x=t._textureCoordinates,G=A(x),N=k.positions;if((N=s(N,f.equalsEpsilon,!0)).length<3)return;let X=b,M=_,U=H,J=E;if(!e.computeProjectTo2DArguments(N,I,J,C))return;if(X=f.cross(J,C,X),X=f.normalize(X,X),!f.equalsEpsilon(I,f.ZERO,P.EPSILON6)){let e=t._ellipsoid.geodeticSurfaceNormal(I,B);0>f.dot(X,e)&&(X=f.negate(X,X),J=f.negate(J,J))}let K=e.createProjectPointsTo2DFunction(I,J,C),Q=e.createProjectPointTo2DFunction(I,J,C);i.tangent&&(M=f.clone(J,M)),i.bitangent&&(U=f.clone(C,U));let S=o.polygonsFromHierarchy(k,G,K,!1),Y=S.hierarchy,z=S.polygons,V=G?o.polygonsFromHierarchy(x,!0,function(t){return t},!1).polygons:void 0;if(0===Y.length)return;N=Y[0].outerRing;let W=h.fromPoints(N),Z=o.computeBoundingRectangle(X,Q,N,w,v),q=[];for(let t=0;t<z.length;t++){let e=new n({geometry:function(t,e,o,n,r,i,s,h,k){let w=t.positions,x=a.triangulate(t.positions2D,t.holes);x.length<3&&(x=[0,1,2]);let v=c.createTypedArray(w.length,x.length);v.set(x);let b=D;if(0!==n){let t=y.fromAxisAngle(s,n,R);if(b=j.fromQuaternion(t,b),e.tangent||e.bitangent){t=y.fromAxisAngle(s,-n,R);let o=j.fromQuaternion(t,O);h=f.normalize(j.multiplyByVector(o,h,h),h),e.bitangent&&(k=f.normalize(f.cross(s,h,k),k))}}else b=j.clone(j.IDENTITY,b);e.st&&(L.x=o.x,L.y=o.y);let _=w.length,H=3*_,I=new Float64Array(H),E=e.normal?new Float32Array(H):void 0,C=e.tangent?new Float32Array(H):void 0,B=e.bitangent?new Float32Array(H):void 0,G=e.st?new Float32Array(2*_):void 0,N=0,X=0,M=0,U=0,J=0;for(let t=0;t<_;t++){let n=w[t];if(I[N++]=n.x,I[N++]=n.y,I[N++]=n.z,e.st)if(A(r)&&r.positions.length===_)G[J++]=r.positions[t].x,G[J++]=r.positions[t].y;else{let t=i(j.multiplyByVector(b,n,T),F);d.subtract(t,L,t);let e=P.clamp(t.x/o.width,0,1),r=P.clamp(t.y/o.height,0,1);G[J++]=e,G[J++]=r}e.normal&&(E[X++]=s.x,E[X++]=s.y,E[X++]=s.z),e.tangent&&(C[U++]=h.x,C[U++]=h.y,C[U++]=h.z),e.bitangent&&(B[M++]=k.x,B[M++]=k.y,B[M++]=k.z)}let K=new p;return e.position&&(K.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:I})),e.normal&&(K.normal=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:E})),e.tangent&&(K.tangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:C})),e.bitangent&&(K.bitangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:B})),e.st&&(K.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:G})),new u({attributes:K,indices:v,primitiveType:l.TRIANGLES})}(z[t],i,Z,w,G?V[t]:void 0,Q,X,M,U)});q.push(e)}let $=r.combineInstances(q)[0];$.attributes.position.values=new Float64Array($.attributes.position.values),$.indices=c.createTypedArray($.attributes.position.values.length/3,$.indices);let tt=$.attributes;return i.position||delete tt.position,new u({attributes:tt,indices:$.indices,primitiveType:$.primitiveType,boundingSphere:W})};var U=function(t,e){return A(e)&&(t=G.unpack(t,e)),G.createGeometry(t)};export{U as default};