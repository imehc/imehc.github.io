import{a as t}from"./chunk-525YMNGT.js";import{a as e}from"./chunk-MRH6LWHV.js";import"./chunk-2A2JFXXO.js";import"./chunk-TULFNR3P.js";import{a as r}from"./chunk-MABAS5D2.js";import{a as o}from"./chunk-PXD6ATBI.js";import"./chunk-33M5C4LG.js";import"./chunk-X2JOWFTB.js";import{b as i}from"./chunk-TN2BIDXM.js";import{a as a}from"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as n}from"./chunk-GSMLTRAL.js";import{a as s}from"./chunk-IUX576XK.js";import{b as l,c as u,d as d}from"./chunk-UIGT6VOJ.js";import{c as m}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import{j as c}from"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as h}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{a as f,c as p}from"./chunk-KCR7AORG.js";import{a as g,c as A}from"./chunk-QDJTHWTA.js";import{a as y}from"./chunk-2YWR3G22.js";import{b as b}from"./chunk-HTSQLHXI.js";import{e as _}from"./chunk-JDAHMWM5.js";var w=new g,v=new g,T=new g,k=new g,M=new g,O=new g,E=new g,F=new g;function P(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function N(e,r,o,i,a,n){let s=e.normals,l=e.tangents,u=e.bitangents,d=g.normalize(g.cross(o,r,E),E);n.normal&&t.addAttribute(s,r,i,a),n.tangent&&t.addAttribute(l,d,i,a),n.bitangent&&t.addAttribute(u,o,i,a)}function j(e,r,o){let i,a,l=e.positions,u=e.corners,m=e.endPositions,c=e.lefts,f=e.normals,p=new s,A,b=0,M=0,P,j=0,x;for(P=0;P<l.length;P+=2)b+=x=l[P].length-3,j+=2*x,M+=l[P+1].length-3;for(b+=3,M+=3,P=0;P<u.length;P++){A=u[P];let t=u[P].leftPositions;_(t)?b+=x=t.length:M+=x=u[P].rightPositions.length,j+=x}let D=_(m),L;D&&(b+=L=m[0].length-3,M+=L,L/=3,j+=6*L);let S=b+M,I=new Float64Array(S),H={normals:r.normal?new Float32Array(S):void 0,tangents:r.tangent?new Float32Array(S):void 0,bitangents:r.bitangent?new Float32Array(S):void 0},R=0,G=S-1,V,B,U,z,C=w,W=v,X,J,Y=L/2,K=n.createTypedArray(S/3,j),Q=0;if(D){J=T,X=k;let e=m[0];for(C=g.fromArray(f,0,C),W=g.fromArray(c,0,W),P=0;P<Y;P++)J=g.fromArray(e,(Y-1-P)*3,J),X=g.fromArray(e,(Y+P)*3,X),t.addAttribute(I,X,R),t.addAttribute(I,J,void 0,G),N(H,C,W,R,G,r),z=(B=R/3)+1,U=(V=(G-2)/3)-1,K[Q++]=V,K[Q++]=B,K[Q++]=U,K[Q++]=U,K[Q++]=B,K[Q++]=z,R+=3,G-=3}let q=0,Z=0,$=l[q++],tt=l[q++];for(I.set($,R),I.set(tt,G-tt.length+1),W=g.fromArray(c,Z,W),x=tt.length-3,P=0;P<x;P+=3)i=o.geodeticSurfaceNormal(g.fromArray($,P,E),E),a=o.geodeticSurfaceNormal(g.fromArray(tt,x-P,F),F),N(H,C=g.normalize(g.add(i,a,C),C),W,R,G,r),z=(B=R/3)+1,U=(V=(G-2)/3)-1,K[Q++]=V,K[Q++]=B,K[Q++]=U,K[Q++]=U,K[Q++]=B,K[Q++]=z,R+=3,G-=3;for(i=o.geodeticSurfaceNormal(g.fromArray($,x,E),E),a=o.geodeticSurfaceNormal(g.fromArray(tt,x,F),F),C=g.normalize(g.add(i,a,C),C),Z+=3,P=0;P<u.length;P++){let e,n=(A=u[P]).leftPositions,s=A.rightPositions,d,m,h=O,p=T,y=k;if(C=g.fromArray(f,Z,C),_(n)){for(N(H,C,W,void 0,G,r),G-=3,d=z,m=U,e=0;e<n.length/3;e++)h=g.fromArray(n,3*e,h),K[Q++]=d,K[Q++]=m-e-1,K[Q++]=m-e,t.addAttribute(I,h,void 0,G),p=g.fromArray(I,(m-e-1)*3,p),y=g.fromArray(I,3*d,y),N(H,C,W=g.normalize(g.subtract(p,y,W),W),void 0,G,r),G-=3;h=g.fromArray(I,3*d,h),p=g.subtract(g.fromArray(I,3*m,p),h,p),y=g.subtract(g.fromArray(I,(m-e)*3,y),h,y),N(H,C,W=g.normalize(g.add(p,y,W),W),R,void 0,r),R+=3}else{for(N(H,C,W,R,void 0,r),R+=3,d=U,m=z,e=0;e<s.length/3;e++)h=g.fromArray(s,3*e,h),K[Q++]=d,K[Q++]=m+e,K[Q++]=m+e+1,t.addAttribute(I,h,R),p=g.fromArray(I,3*d,p),y=g.fromArray(I,(m+e)*3,y),N(H,C,W=g.normalize(g.subtract(p,y,W),W),R,void 0,r),R+=3;h=g.fromArray(I,3*d,h),p=g.subtract(g.fromArray(I,(m+e)*3,p),h,p),y=g.subtract(g.fromArray(I,3*m,y),h,y),N(H,C,W=g.normalize(g.negate(g.add(y,p,W),W),W),void 0,G,r),G-=3}for($=l[q++],tt=l[q++],$.splice(0,3),tt.splice(tt.length-3,3),I.set($,R),I.set(tt,G-tt.length+1),x=tt.length-3,Z+=3,W=g.fromArray(c,Z,W),e=0;e<tt.length;e+=3)i=o.geodeticSurfaceNormal(g.fromArray($,e,E),E),a=o.geodeticSurfaceNormal(g.fromArray(tt,x-e,F),F),N(H,C=g.normalize(g.add(i,a,C),C),W,R,G,r),B=(z=R/3)-1,V=(U=(G-2)/3)+1,K[Q++]=V,K[Q++]=B,K[Q++]=U,K[Q++]=U,K[Q++]=B,K[Q++]=z,R+=3,G-=3;R-=3,G+=3}if(N(H,C=g.fromArray(f,f.length-3,C),W,R,G,r),D){R+=3,G-=3,J=T,X=k;let e=m[1];for(P=0;P<Y;P++)J=g.fromArray(e,(L-P-1)*3,J),X=g.fromArray(e,3*P,X),t.addAttribute(I,J,void 0,G),t.addAttribute(I,X,R),N(H,C,W,R,G,r),B=(z=R/3)-1,V=(U=(G-2)/3)+1,K[Q++]=V,K[Q++]=B,K[Q++]=U,K[Q++]=U,K[Q++]=B,K[Q++]=z,R+=3,G-=3}if(p.position=new d({componentDatatype:h.DOUBLE,componentsPerAttribute:3,values:I}),r.st){let t=new Float32Array(S/3*2),e,r,o=0;if(D){b/=3,M/=3;let i=Math.PI/(L+1);r=1/(b-L+1),e=1/(M-L+1);let a,n=L/2;for(P=n+1;P<L+1;P++)a=y.PI_OVER_TWO+i*P,t[o++]=e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(P=1;P<M-L+1;P++)t[o++]=P*e,t[o++]=0;for(P=L;P>n;P--)a=y.PI_OVER_TWO-P*i,t[o++]=1-e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(P=n;P>0;P--)a=y.PI_OVER_TWO-i*P,t[o++]=1-r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(P=b-L;P>0;P--)t[o++]=P*r,t[o++]=1;for(P=1;P<n+1;P++)a=y.PI_OVER_TWO+i*P,t[o++]=r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a))}else{for(b/=3,M/=3,r=1/(b-1),e=1/(M-1),P=0;P<M;P++)t[o++]=P*e,t[o++]=0;for(P=b;P>0;P--)t[o++]=(P-1)*r,t[o++]=1}p.st=new d({componentDatatype:h.FLOAT,componentsPerAttribute:2,values:t})}return r.normal&&(p.normal=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.normals})),r.tangent&&(p.tangent=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.tangents})),r.bitangent&&(p.bitangent=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.bitangents})),{attributes:p,indices:K}}function x(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let o=3;o<t.length;o+=3){let i=t[o],a=t[o+1],n=t[o+2];r[e++]=i,r[e++]=a,r[e++]=n,r[e++]=i,r[e++]=a,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var D=new g,L=new g,S=new f;function I(t,e,r,o,i,a){let n=g.subtract(e,t,D);g.normalize(n,n);let s=r.geodeticSurfaceNormal(t,L),l=g.cross(n,s,D);g.multiplyByScalar(l,o,l);let u=i.latitude,d=i.longitude,m=a.latitude,c=a.longitude;g.add(t,l,L),r.cartesianToCartographic(L,S);let h=S.latitude,f=S.longitude;u=Math.min(u,h),d=Math.min(d,f),m=Math.max(m,h),c=Math.max(c,f),g.subtract(t,l,L),r.cartesianToCartographic(L,S),h=S.latitude,f=S.longitude,u=Math.min(u,h),d=Math.min(d,f),m=Math.max(m,h),c=Math.max(c,f),i.latitude=u,i.longitude=d,a.latitude=m,a.longitude=c}var H=new g,R=new g,G=new f,V=new f;function B(t,r,o,i,n){let s,l,u=a(t=P(t,r),g.equalsEpsilon),d=u.length;if(d<2||o<=0)return new c;let m=.5*o;if(G.latitude=1/0,G.longitude=1/0,V.latitude=-1/0,V.longitude=-1/0,i===e.ROUNDED){let t=u[0];g.subtract(t,u[1],H),g.normalize(H,H),g.multiplyByScalar(H,m,H),g.add(t,H,R),r.cartesianToCartographic(R,S),s=S.latitude,l=S.longitude,G.latitude=Math.min(G.latitude,s),G.longitude=Math.min(G.longitude,l),V.latitude=Math.max(V.latitude,s),V.longitude=Math.max(V.longitude,l)}for(let t=0;t<d-1;++t)I(u[t],u[t+1],r,m,G,V);let h=u[d-1];g.subtract(h,u[d-2],H),g.normalize(H,H),g.multiplyByScalar(H,m,H),g.add(h,H,R),I(h,R,r,m,G,V),i===e.ROUNDED&&(r.cartesianToCartographic(R,S),s=S.latitude,l=S.longitude,G.latitude=Math.min(G.latitude,s),G.longitude=Math.min(G.longitude,l),V.latitude=Math.max(V.latitude,s),V.longitude=Math.max(V.longitude,l));let f=_(n)?n:new c;return f.north=V.latitude,f.south=G.latitude,f.east=V.longitude,f.west=G.longitude,f}function U(t){let r=(t=t??A.EMPTY_OBJECT).positions,i=t.width;b.defined("options.positions",r),b.defined("options.width",i);let a=t.height??0,n=t.extrudedHeight??a;this._positions=r,this._ellipsoid=p.clone(t.ellipsoid??p.default),this._vertexFormat=o.clone(t.vertexFormat??o.DEFAULT),this._width=i,this._height=Math.max(a,n),this._extrudedHeight=Math.min(a,n),this._cornerType=t.cornerType??e.ROUNDED,this._granularity=t.granularity??y.RADIANS_PER_DEGREE,this._shadowVolume=t.shadowVolume??!1,this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*g.packedLength+p.packedLength+o.packedLength+7}U.pack=function(t,e,r){b.defined("value",t),b.defined("array",e),r=r??0;let i=t._positions,a=i.length;e[r++]=a;for(let t=0;t<a;++t,r+=g.packedLength)g.pack(i[t],e,r);return p.pack(t._ellipsoid,e,r),r+=p.packedLength,o.pack(t._vertexFormat,e,r),r+=o.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=+!!t._shadowVolume,e[r]=t._offsetAttribute??-1,e};var z=p.clone(p.UNIT_SPHERE),C=new o,W={positions:void 0,ellipsoid:z,vertexFormat:C,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};U.unpack=function(t,e,r){b.defined("array",t),e=e??0;let i=t[e++],a=Array(i);for(let r=0;r<i;++r,e+=g.packedLength)a[r]=g.unpack(t,e);let n=p.unpack(t,e,z);e+=p.packedLength;let s=o.unpack(t,e,C);e+=o.packedLength;let l=t[e++],u=t[e++],d=t[e++],m=t[e++],c=t[e++],h=1===t[e++],f=t[e];return _(r)?(r._positions=a,r._ellipsoid=p.clone(n,r._ellipsoid),r._vertexFormat=o.clone(s,r._vertexFormat),r._width=l,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=c,r._shadowVolume=h,r._offsetAttribute=-1===f?void 0:f,r):(W.positions=a,W.width=l,W.height=u,W.extrudedHeight=d,W.cornerType=m,W.granularity=c,W.shadowVolume=h,W.offsetAttribute=-1===f?void 0:f,new U(W))},U.computeRectangle=function(t,r){let o=(t=t??A.EMPTY_OBJECT).positions,i=t.width;return b.defined("options.positions",o),b.defined("options.width",i),B(o,t.ellipsoid??p.default,i,t.cornerType??e.ROUNDED,r)},U.createGeometry=function(e){let s=e._positions,c=e._width,f=e._ellipsoid,p=a(s=P(s,f),g.equalsEpsilon);if(p.length<2||c<=0)return;let A=e._height,b=e._extrudedHeight,E=!y.equalsEpsilon(A,b,0,y.EPSILON2),F=e._vertexFormat,N={ellipsoid:f,positions:p,width:c,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0},D;if(E)N.height=A,N.extrudedHeight=b,N.shadowVolume=e._shadowVolume,N.offsetAttribute=e._offsetAttribute,D=function(e,a){let s,l,u,m,c=new o({position:a.position,normal:a.normal||a.bitangent||e.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),f=e.ellipsoid,p=j(t.computePositions(e),c,f),A=e.height,y=e.extrudedHeight,b=p.attributes,E=p.indices,F=b.position.values,P=F.length,N=new Float64Array(6*P),D=new Float64Array(P);D.set(F);let L=new Float64Array(4*P);L=x(F=i.scaleToGeodeticHeight(F,A,f),0,L),L=x(D=i.scaleToGeodeticHeight(D,y,f),2*P,L),N.set(F),N.set(D,P),N.set(L,2*P),b.position.values=N,b=function(e,r){if(!r.normal&&!r.tangent&&!r.bitangent&&!r.st)return e;let o=e.position.values,i,a;(r.normal||r.bitangent)&&(i=e.normal.values,a=e.bitangent.values);let n=e.position.values.length/18,s=3*n,l=2*n,u=2*s,d;if(r.normal||r.bitangent||r.tangent){let n=r.normal?new Float32Array(6*s):void 0,l=r.tangent?new Float32Array(6*s):void 0,m=r.bitangent?new Float32Array(6*s):void 0,c=w,h=v,f=T,p=k,A=M,y=O,b=u;for(d=0;d<s;d+=3){let e=b+u;c=g.fromArray(o,d,c),h=g.fromArray(o,d+s,h),f=g.fromArray(o,(d+3)%s,f),h=g.subtract(h,c,h),f=g.subtract(f,c,f),p=g.normalize(g.cross(h,f,p),p),r.normal&&(t.addAttribute(n,p,e),t.addAttribute(n,p,e+3),t.addAttribute(n,p,b),t.addAttribute(n,p,b+3)),(r.tangent||r.bitangent)&&(y=g.fromArray(i,d,y),r.bitangent&&(t.addAttribute(m,y,e),t.addAttribute(m,y,e+3),t.addAttribute(m,y,b),t.addAttribute(m,y,b+3)),r.tangent&&(A=g.normalize(g.cross(y,p,A),A),t.addAttribute(l,A,e),t.addAttribute(l,A,e+3),t.addAttribute(l,A,b),t.addAttribute(l,A,b+3))),b+=6}if(r.normal){for(n.set(i),d=0;d<s;d+=3)n[d+s]=-i[d],n[d+s+1]=-i[d+1],n[d+s+2]=-i[d+2];e.normal.values=n}else e.normal=void 0;if(r.bitangent?(m.set(a),m.set(a,s),e.bitangent.values=m):e.bitangent=void 0,r.tangent){let t=e.tangent.values;l.set(t),l.set(t,s),e.tangent.values=l}}if(r.st){let t=e.st.values,r=new Float32Array(6*l);r.set(t),r.set(t,l);let o=2*l;for(let e=0;e<2;e++){for(r[o++]=t[0],r[o++]=t[1],d=2;d<l;d+=2){let e=t[d],i=t[d+1];r[o++]=e,r[o++]=i,r[o++]=e,r[o++]=i}r[o++]=t[0],r[o++]=t[1]}e.st.values=r}return e}(b,a);let S,I=P/3;if(e.shadowVolume){let t=b.normal.values,e=new Float32Array(6*(P=t.length));for(S=0;S<P;S++)t[S]=-t[S];e.set(t,P),e=x(t,4*P,e),b.extrudeDirection=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:e}),a.normal||(b.normal=void 0)}if(_(e.offsetAttribute)){let t=new Uint8Array(6*I);if(e.offsetAttribute===r.TOP)t=t.fill(1,0,I).fill(1,2*I,4*I);else{let o=+(e.offsetAttribute!==r.NONE);t=t.fill(o)}b.applyOffset=new d({componentDatatype:h.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let H=E.length,R=I+I,G=n.createTypedArray(N.length/3,2*H+3*R);G.set(E);let V=H;for(S=0;S<H;S+=3){let t=E[S],e=E[S+1],r=E[S+2];G[V++]=r+I,G[V++]=e+I,G[V++]=t+I}for(S=0;S<R;S+=2)l=(s=S+R)+R,u=s+1,m=l+1,G[V++]=s,G[V++]=l,G[V++]=u,G[V++]=u,G[V++]=l,G[V++]=m;return{attributes:b,indices:G}}(N,F);else if((D=j(t.computePositions(N),F,f)).attributes.position.values=i.scaleToGeodeticHeight(D.attributes.position.values,A,f),_(e._offsetAttribute)){let t=+(e._offsetAttribute!==r.NONE),o=new Uint8Array(D.attributes.position.values.length/3).fill(t);D.attributes.applyOffset=new d({componentDatatype:h.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}let L=D.attributes,S=m.fromVertices(L.position.values,void 0,3);return F.position||(D.attributes.position.values=void 0),new u({attributes:L,indices:D.indices,primitiveType:l.TRIANGLES,boundingSphere:S,offsetAttribute:e._offsetAttribute})},U.createShadowVolume=function(t,e,r){let i=t._granularity,a=t._ellipsoid,n=e(i,a),s=r(i,a);return new U({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:a,granularity:i,extrudedHeight:n,height:s,vertexFormat:o.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(U.prototype,{rectangle:{get:function(){return _(this._rectangle)||(this._rectangle=B(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var X=function(t,e){return _(e)&&(t=U.unpack(t,e)),t._ellipsoid=p.clone(t._ellipsoid),U.createGeometry(t)};export{X as default};