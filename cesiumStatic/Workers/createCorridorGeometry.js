import{a as t}from"./chunk-7YYII3LO.js";import{a as e}from"./chunk-KSAXP2ON.js";import"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import{a as r}from"./chunk-IBQZCWHF.js";import{a as o}from"./chunk-ZXZD7KWX.js";import"./chunk-SI3KZUTO.js";import"./chunk-QM7HI6IF.js";import{b as i}from"./chunk-45FW5IBC.js";import{a as a}from"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as n}from"./chunk-KSX6TRAS.js";import{a as s}from"./chunk-GMTHOMGW.js";import{b as l,c as u,d as d}from"./chunk-BELR52CD.js";import{c as m}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import{j as c}from"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as h}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{a as f,c as p}from"./chunk-ICY67TC6.js";import{a as g,c as A}from"./chunk-G2EMNOST.js";import{a as y}from"./chunk-4VFKVGYI.js";import{b as b}from"./chunk-3WJNS2B6.js";import{e as _}from"./chunk-XCN226AA.js";var w=new g,v=new g,T=new g,k=new g,M=new g,O=new g,N=new g,E=new g;function F(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function P(e,r,o,i,a,n){let s=e.normals,l=e.tangents,u=e.bitangents,d=g.normalize(g.cross(o,r,N),N);n.normal&&t.addAttribute(s,r,i,a),n.tangent&&t.addAttribute(l,d,i,a),n.bitangent&&t.addAttribute(u,o,i,a)}function j(e,r,o){let i,a,l=e.positions,u=e.corners,m=e.endPositions,c=e.lefts,f=e.normals,p=new s,A,b=0,M=0,F,j=0,x;for(F=0;F<l.length;F+=2)b+=x=l[F].length-3,j+=2*x,M+=l[F+1].length-3;for(b+=3,M+=3,F=0;F<u.length;F++){A=u[F];let t=u[F].leftPositions;_(t)?b+=x=t.length:M+=x=u[F].rightPositions.length,j+=x}let D=_(m),S;D&&(b+=S=m[0].length-3,M+=S,S/=3,j+=6*S);let I=b+M,L=new Float64Array(I),H={normals:r.normal?new Float32Array(I):void 0,tangents:r.tangent?new Float32Array(I):void 0,bitangents:r.bitangent?new Float32Array(I):void 0},V=0,C=I-1,R,B,G,z,U=w,Y=v,W,K,X=S/2,Z=n.createTypedArray(I/3,j),J=0;if(D){K=T,W=k;let e=m[0];for(U=g.fromArray(f,0,U),Y=g.fromArray(c,0,Y),F=0;F<X;F++)K=g.fromArray(e,(X-1-F)*3,K),W=g.fromArray(e,(X+F)*3,W),t.addAttribute(L,W,V),t.addAttribute(L,K,void 0,C),P(H,U,Y,V,C,r),z=(B=V/3)+1,G=(R=(C-2)/3)-1,Z[J++]=R,Z[J++]=B,Z[J++]=G,Z[J++]=G,Z[J++]=B,Z[J++]=z,V+=3,C-=3}let Q=0,q=0,$=l[Q++],tt=l[Q++];for(L.set($,V),L.set(tt,C-tt.length+1),Y=g.fromArray(c,q,Y),x=tt.length-3,F=0;F<x;F+=3)i=o.geodeticSurfaceNormal(g.fromArray($,F,N),N),a=o.geodeticSurfaceNormal(g.fromArray(tt,x-F,E),E),P(H,U=g.normalize(g.add(i,a,U),U),Y,V,C,r),z=(B=V/3)+1,G=(R=(C-2)/3)-1,Z[J++]=R,Z[J++]=B,Z[J++]=G,Z[J++]=G,Z[J++]=B,Z[J++]=z,V+=3,C-=3;for(i=o.geodeticSurfaceNormal(g.fromArray($,x,N),N),a=o.geodeticSurfaceNormal(g.fromArray(tt,x,E),E),U=g.normalize(g.add(i,a,U),U),q+=3,F=0;F<u.length;F++){let e,n=(A=u[F]).leftPositions,s=A.rightPositions,d,m,h=O,p=T,y=k;if(U=g.fromArray(f,q,U),_(n)){for(P(H,U,Y,void 0,C,r),C-=3,d=z,m=G,e=0;e<n.length/3;e++)h=g.fromArray(n,3*e,h),Z[J++]=d,Z[J++]=m-e-1,Z[J++]=m-e,t.addAttribute(L,h,void 0,C),p=g.fromArray(L,(m-e-1)*3,p),y=g.fromArray(L,3*d,y),P(H,U,Y=g.normalize(g.subtract(p,y,Y),Y),void 0,C,r),C-=3;h=g.fromArray(L,3*d,h),p=g.subtract(g.fromArray(L,3*m,p),h,p),y=g.subtract(g.fromArray(L,(m-e)*3,y),h,y),P(H,U,Y=g.normalize(g.add(p,y,Y),Y),V,void 0,r),V+=3}else{for(P(H,U,Y,V,void 0,r),V+=3,d=G,m=z,e=0;e<s.length/3;e++)h=g.fromArray(s,3*e,h),Z[J++]=d,Z[J++]=m+e,Z[J++]=m+e+1,t.addAttribute(L,h,V),p=g.fromArray(L,3*d,p),y=g.fromArray(L,(m+e)*3,y),P(H,U,Y=g.normalize(g.subtract(p,y,Y),Y),V,void 0,r),V+=3;h=g.fromArray(L,3*d,h),p=g.subtract(g.fromArray(L,(m+e)*3,p),h,p),y=g.subtract(g.fromArray(L,3*m,y),h,y),P(H,U,Y=g.normalize(g.negate(g.add(y,p,Y),Y),Y),void 0,C,r),C-=3}for($=l[Q++],tt=l[Q++],$.splice(0,3),tt.splice(tt.length-3,3),L.set($,V),L.set(tt,C-tt.length+1),x=tt.length-3,q+=3,Y=g.fromArray(c,q,Y),e=0;e<tt.length;e+=3)i=o.geodeticSurfaceNormal(g.fromArray($,e,N),N),a=o.geodeticSurfaceNormal(g.fromArray(tt,x-e,E),E),P(H,U=g.normalize(g.add(i,a,U),U),Y,V,C,r),B=(z=V/3)-1,R=(G=(C-2)/3)+1,Z[J++]=R,Z[J++]=B,Z[J++]=G,Z[J++]=G,Z[J++]=B,Z[J++]=z,V+=3,C-=3;V-=3,C+=3}if(P(H,U=g.fromArray(f,f.length-3,U),Y,V,C,r),D){V+=3,C-=3,K=T,W=k;let e=m[1];for(F=0;F<X;F++)K=g.fromArray(e,(S-F-1)*3,K),W=g.fromArray(e,3*F,W),t.addAttribute(L,K,void 0,C),t.addAttribute(L,W,V),P(H,U,Y,V,C,r),B=(z=V/3)-1,R=(G=(C-2)/3)+1,Z[J++]=R,Z[J++]=B,Z[J++]=G,Z[J++]=G,Z[J++]=B,Z[J++]=z,V+=3,C-=3}if(p.position=new d({componentDatatype:h.DOUBLE,componentsPerAttribute:3,values:L}),r.st){let t=new Float32Array(I/3*2),e,r,o=0;if(D){b/=3,M/=3;let i=Math.PI/(S+1);r=1/(b-S+1),e=1/(M-S+1);let a,n=S/2;for(F=n+1;F<S+1;F++)a=y.PI_OVER_TWO+i*F,t[o++]=e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=1;F<M-S+1;F++)t[o++]=F*e,t[o++]=0;for(F=S;F>n;F--)a=y.PI_OVER_TWO-F*i,t[o++]=1-e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=n;F>0;F--)a=y.PI_OVER_TWO-i*F,t[o++]=1-r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=b-S;F>0;F--)t[o++]=F*r,t[o++]=1;for(F=1;F<n+1;F++)a=y.PI_OVER_TWO+i*F,t[o++]=r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a))}else{for(b/=3,M/=3,r=1/(b-1),e=1/(M-1),F=0;F<M;F++)t[o++]=F*e,t[o++]=0;for(F=b;F>0;F--)t[o++]=(F-1)*r,t[o++]=1}p.st=new d({componentDatatype:h.FLOAT,componentsPerAttribute:2,values:t})}return r.normal&&(p.normal=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.normals})),r.tangent&&(p.tangent=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.tangents})),r.bitangent&&(p.bitangent=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:H.bitangents})),{attributes:p,indices:Z}}function x(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let o=3;o<t.length;o+=3){let i=t[o],a=t[o+1],n=t[o+2];r[e++]=i,r[e++]=a,r[e++]=n,r[e++]=i,r[e++]=a,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var D=new g,S=new g,I=new f;function L(t,e,r,o,i,a){let n=g.subtract(e,t,D);g.normalize(n,n);let s=r.geodeticSurfaceNormal(t,S),l=g.cross(n,s,D);g.multiplyByScalar(l,o,l);let u=i.latitude,d=i.longitude,m=a.latitude,c=a.longitude;g.add(t,l,S),r.cartesianToCartographic(S,I);let h=I.latitude,f=I.longitude;u=Math.min(u,h),d=Math.min(d,f),m=Math.max(m,h),c=Math.max(c,f),g.subtract(t,l,S),r.cartesianToCartographic(S,I),h=I.latitude,f=I.longitude,u=Math.min(u,h),d=Math.min(d,f),m=Math.max(m,h),c=Math.max(c,f),i.latitude=u,i.longitude=d,a.latitude=m,a.longitude=c}var H=new g,V=new g,C=new f,R=new f;function B(t,r,o,i,n){let s,l,u=a(t=F(t,r),g.equalsEpsilon),d=u.length;if(d<2||o<=0)return new c;let m=.5*o;if(C.latitude=1/0,C.longitude=1/0,R.latitude=-1/0,R.longitude=-1/0,i===e.ROUNDED){let t=u[0];g.subtract(t,u[1],H),g.normalize(H,H),g.multiplyByScalar(H,m,H),g.add(t,H,V),r.cartesianToCartographic(V,I),s=I.latitude,l=I.longitude,C.latitude=Math.min(C.latitude,s),C.longitude=Math.min(C.longitude,l),R.latitude=Math.max(R.latitude,s),R.longitude=Math.max(R.longitude,l)}for(let t=0;t<d-1;++t)L(u[t],u[t+1],r,m,C,R);let h=u[d-1];g.subtract(h,u[d-2],H),g.normalize(H,H),g.multiplyByScalar(H,m,H),g.add(h,H,V),L(h,V,r,m,C,R),i===e.ROUNDED&&(r.cartesianToCartographic(V,I),s=I.latitude,l=I.longitude,C.latitude=Math.min(C.latitude,s),C.longitude=Math.min(C.longitude,l),R.latitude=Math.max(R.latitude,s),R.longitude=Math.max(R.longitude,l));let f=_(n)?n:new c;return f.north=R.latitude,f.south=C.latitude,f.east=R.longitude,f.west=C.longitude,f}function G(t){let r=(t=t??A.EMPTY_OBJECT).positions,i=t.width;b.defined("options.positions",r),b.defined("options.width",i);let a=t.height??0,n=t.extrudedHeight??a;this._positions=r,this._ellipsoid=p.clone(t.ellipsoid??p.default),this._vertexFormat=o.clone(t.vertexFormat??o.DEFAULT),this._width=i,this._height=Math.max(a,n),this._extrudedHeight=Math.min(a,n),this._cornerType=t.cornerType??e.ROUNDED,this._granularity=t.granularity??y.RADIANS_PER_DEGREE,this._shadowVolume=t.shadowVolume??!1,this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*g.packedLength+p.packedLength+o.packedLength+7}G.pack=function(t,e,r){b.defined("value",t),b.defined("array",e),r=r??0;let i=t._positions,a=i.length;e[r++]=a;for(let t=0;t<a;++t,r+=g.packedLength)g.pack(i[t],e,r);return p.pack(t._ellipsoid,e,r),r+=p.packedLength,o.pack(t._vertexFormat,e,r),r+=o.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=+!!t._shadowVolume,e[r]=t._offsetAttribute??-1,e};var z=p.clone(p.UNIT_SPHERE),U=new o,Y={positions:void 0,ellipsoid:z,vertexFormat:U,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};G.unpack=function(t,e,r){b.defined("array",t),e=e??0;let i=t[e++],a=Array(i);for(let r=0;r<i;++r,e+=g.packedLength)a[r]=g.unpack(t,e);let n=p.unpack(t,e,z);e+=p.packedLength;let s=o.unpack(t,e,U);e+=o.packedLength;let l=t[e++],u=t[e++],d=t[e++],m=t[e++],c=t[e++],h=1===t[e++],f=t[e];return _(r)?(r._positions=a,r._ellipsoid=p.clone(n,r._ellipsoid),r._vertexFormat=o.clone(s,r._vertexFormat),r._width=l,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=c,r._shadowVolume=h,r._offsetAttribute=-1===f?void 0:f,r):(Y.positions=a,Y.width=l,Y.height=u,Y.extrudedHeight=d,Y.cornerType=m,Y.granularity=c,Y.shadowVolume=h,Y.offsetAttribute=-1===f?void 0:f,new G(Y))},G.computeRectangle=function(t,r){let o=(t=t??A.EMPTY_OBJECT).positions,i=t.width;return b.defined("options.positions",o),b.defined("options.width",i),B(o,t.ellipsoid??p.default,i,t.cornerType??e.ROUNDED,r)},G.createGeometry=function(e){let s=e._positions,c=e._width,f=e._ellipsoid,p=a(s=F(s,f),g.equalsEpsilon);if(p.length<2||c<=0)return;let A=e._height,b=e._extrudedHeight,N=!y.equalsEpsilon(A,b,0,y.EPSILON2),E=e._vertexFormat,P={ellipsoid:f,positions:p,width:c,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0},D;if(N)P.height=A,P.extrudedHeight=b,P.shadowVolume=e._shadowVolume,P.offsetAttribute=e._offsetAttribute,D=function(e,a){let s,l,u,m,c=new o({position:a.position,normal:a.normal||a.bitangent||e.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),f=e.ellipsoid,p=j(t.computePositions(e),c,f),A=e.height,y=e.extrudedHeight,b=p.attributes,N=p.indices,E=b.position.values,F=E.length,P=new Float64Array(6*F),D=new Float64Array(F);D.set(E);let S=new Float64Array(4*F);S=x(E=i.scaleToGeodeticHeight(E,A,f),0,S),S=x(D=i.scaleToGeodeticHeight(D,y,f),2*F,S),P.set(E),P.set(D,F),P.set(S,2*F),b.position.values=P,b=function(e,r){if(!r.normal&&!r.tangent&&!r.bitangent&&!r.st)return e;let o=e.position.values,i,a;(r.normal||r.bitangent)&&(i=e.normal.values,a=e.bitangent.values);let n=e.position.values.length/18,s=3*n,l=2*n,u=2*s,d;if(r.normal||r.bitangent||r.tangent){let n=r.normal?new Float32Array(6*s):void 0,l=r.tangent?new Float32Array(6*s):void 0,m=r.bitangent?new Float32Array(6*s):void 0,c=w,h=v,f=T,p=k,A=M,y=O,b=u;for(d=0;d<s;d+=3){let e=b+u;c=g.fromArray(o,d,c),h=g.fromArray(o,d+s,h),f=g.fromArray(o,(d+3)%s,f),h=g.subtract(h,c,h),f=g.subtract(f,c,f),p=g.normalize(g.cross(h,f,p),p),r.normal&&(t.addAttribute(n,p,e),t.addAttribute(n,p,e+3),t.addAttribute(n,p,b),t.addAttribute(n,p,b+3)),(r.tangent||r.bitangent)&&(y=g.fromArray(i,d,y),r.bitangent&&(t.addAttribute(m,y,e),t.addAttribute(m,y,e+3),t.addAttribute(m,y,b),t.addAttribute(m,y,b+3)),r.tangent&&(A=g.normalize(g.cross(y,p,A),A),t.addAttribute(l,A,e),t.addAttribute(l,A,e+3),t.addAttribute(l,A,b),t.addAttribute(l,A,b+3))),b+=6}if(r.normal){for(n.set(i),d=0;d<s;d+=3)n[d+s]=-i[d],n[d+s+1]=-i[d+1],n[d+s+2]=-i[d+2];e.normal.values=n}else e.normal=void 0;if(r.bitangent?(m.set(a),m.set(a,s),e.bitangent.values=m):e.bitangent=void 0,r.tangent){let t=e.tangent.values;l.set(t),l.set(t,s),e.tangent.values=l}}if(r.st){let t=e.st.values,r=new Float32Array(6*l);r.set(t),r.set(t,l);let o=2*l;for(let e=0;e<2;e++){for(r[o++]=t[0],r[o++]=t[1],d=2;d<l;d+=2){let e=t[d],i=t[d+1];r[o++]=e,r[o++]=i,r[o++]=e,r[o++]=i}r[o++]=t[0],r[o++]=t[1]}e.st.values=r}return e}(b,a);let I,L=F/3;if(e.shadowVolume){let t=b.normal.values,e=new Float32Array(6*(F=t.length));for(I=0;I<F;I++)t[I]=-t[I];e.set(t,F),e=x(t,4*F,e),b.extrudeDirection=new d({componentDatatype:h.FLOAT,componentsPerAttribute:3,values:e}),a.normal||(b.normal=void 0)}if(_(e.offsetAttribute)){let t=new Uint8Array(6*L);if(e.offsetAttribute===r.TOP)t=t.fill(1,0,L).fill(1,2*L,4*L);else{let o=+(e.offsetAttribute!==r.NONE);t=t.fill(o)}b.applyOffset=new d({componentDatatype:h.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let H=N.length,V=L+L,C=n.createTypedArray(P.length/3,2*H+3*V);C.set(N);let R=H;for(I=0;I<H;I+=3){let t=N[I],e=N[I+1],r=N[I+2];C[R++]=r+L,C[R++]=e+L,C[R++]=t+L}for(I=0;I<V;I+=2)l=(s=I+V)+V,u=s+1,m=l+1,C[R++]=s,C[R++]=l,C[R++]=u,C[R++]=u,C[R++]=l,C[R++]=m;return{attributes:b,indices:C}}(P,E);else if((D=j(t.computePositions(P),E,f)).attributes.position.values=i.scaleToGeodeticHeight(D.attributes.position.values,A,f),_(e._offsetAttribute)){let t=+(e._offsetAttribute!==r.NONE),o=new Uint8Array(D.attributes.position.values.length/3).fill(t);D.attributes.applyOffset=new d({componentDatatype:h.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}let S=D.attributes,I=m.fromVertices(S.position.values,void 0,3);return E.position||(D.attributes.position.values=void 0),new u({attributes:S,indices:D.indices,primitiveType:l.TRIANGLES,boundingSphere:I,offsetAttribute:e._offsetAttribute})},G.createShadowVolume=function(t,e,r){let i=t._granularity,a=t._ellipsoid,n=e(i,a),s=r(i,a);return new G({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:a,granularity:i,extrudedHeight:n,height:s,vertexFormat:o.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(G.prototype,{rectangle:{get:function(){return _(this._rectangle)||(this._rectangle=B(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var W=function(t,e){return _(e)&&(t=G.unpack(t,e)),t._ellipsoid=p.clone(t._ellipsoid),G.createGeometry(t)};export{W as default};