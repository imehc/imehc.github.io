import{a as t}from"./chunk-AEXJAIC2.js";import{a as e}from"./chunk-UILVE4UW.js";import{a as o}from"./chunk-MCM3P7ZC.js";import{a as i}from"./chunk-3QPLNPJT.js";import{a as n}from"./chunk-UPV7RDUS.js";import"./chunk-NPKIHRIX.js";import"./chunk-MUKCYY2X.js";import{a as r}from"./chunk-MABAS5D2.js";import{a as a}from"./chunk-PXD6ATBI.js";import{a as s}from"./chunk-33M5C4LG.js";import"./chunk-X2JOWFTB.js";import{a as l,b as u}from"./chunk-TN2BIDXM.js";import"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import{a as c,b as h}from"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as p}from"./chunk-GSMLTRAL.js";import"./chunk-IUX576XK.js";import{c as g,d as m}from"./chunk-UIGT6VOJ.js";import{c as d}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import{h as f,j as y}from"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as _}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{a as P,b as w,c as T}from"./chunk-KCR7AORG.js";import{a as O,b as b,c as A}from"./chunk-QDJTHWTA.js";import{a as I}from"./chunk-2YWR3G22.js";import{a as E,b as x}from"./chunk-HTSQLHXI.js";import{e as v}from"./chunk-JDAHMWM5.js";function H(t,e){this.position=t,v(this.position)||(this.position=new w),this.tangentPlane=e,v(this.tangentPlane)||(this.tangentPlane=H.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(H.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=w.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(I.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=I.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=I.TWO_PI),t}}});var R=new P,L=new O;H.prototype.getLatitude=function(t){v(t)||(t=T.default),R.latitude=this.conformalLatitude,R.longitude=this.longitude,R.height=0;let e=this.ellipsoid.cartographicToCartesian(R,L);return t.cartesianToCartographic(e,R),R.latitude};var N=new c,k=new O,C=new O;H.fromCartesian=function(t,e){x.defined("cartesian",t);let o=I.signNotZero(t.z),i=H.NORTH_POLE_TANGENT_PLANE,n=H.SOUTH_POLE;o<0&&(i=H.SOUTH_POLE_TANGENT_PLANE,n=H.NORTH_POLE),N.origin=i.ellipsoid.scaleToGeocentricSurface(t,N.origin),N.direction=O.subtract(N.origin,n,k),O.normalize(N.direction,N.direction);let r=h.rayPlane(N,i.plane,C),a=O.subtract(r,n,r),s=O.dot(i.xAxis,a),l=o*O.dot(i.yAxis,a);return v(e)?(e.position=new w(s,l),e.tangentPlane=i,e):new H(new w(s,l),i)},H.fromCartesianArray=function(t,e){x.defined("cartesians",t);let o=t.length;v(e)?e.length=o:e=Array(o);for(let i=0;i<o;i++)e[i]=H.fromCartesian(t[i],e[i]);return e},H.clone=function(t,e){if(v(t))return v(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new H(t.position,t.tangentPlane)},H.HALF_UNIT_SPHERE=Object.freeze(new T(.5,.5,.5)),H.NORTH_POLE=Object.freeze(new O(0,0,.5)),H.SOUTH_POLE=Object.freeze(new O(0,0,-.5)),H.NORTH_POLE_TANGENT_PLANE=Object.freeze(new s(H.NORTH_POLE,H.HALF_UNIT_SPHERE)),H.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new s(H.SOUTH_POLE,H.HALF_UNIT_SPHERE));var j=new P,F=new P,S=new t,G=new O,M=new O,B=new O,U=new O,D=new O,V=new O,z=new O,W=new O,K=new O,X=new w,Y=new w,J=new O,Q=new f,Z=new b,q=new b;function $(t){let e=t.vertexFormat,o=t.geometry,i=t.shadowVolume,n=o.attributes.position.values,a=v(o.attributes.st)?o.attributes.st.values:void 0,s=n.length,l=t.wall,u=t.top||l,c=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||i){let r=t.boundingRectangle,h=t.rotationAxis,p=t.projectTo2d,g=t.ellipsoid,d=t.stRotation,y=t.perPositionHeight;X.x=r.x,X.y=r.y;let P=e.st?new Float32Array(s/3*2):void 0,T;e.normal&&(T=y&&u&&!l?o.attributes.normal.values:new Float32Array(s));let A=e.tangent?new Float32Array(s):void 0,E=e.bitangent?new Float32Array(s):void 0,x=i?new Float32Array(s):void 0,H=0,R=0,L=M,N=B,k=U,C=!0,S=Z,$=q;if(0!==d){let t=f.fromAxisAngle(h,d,Q);S=b.fromQuaternion(t,S),t=f.fromAxisAngle(h,-d,Q),$=b.fromQuaternion(t,$)}else S=b.clone(b.IDENTITY,S),$=b.clone(b.IDENTITY,$);let tt=0,te=0;u&&c&&(tt=s/2,te=s/3,s/=2);for(let o=0;o<s;o+=3){let h=O.fromArray(n,o,J);if(e.st&&!v(a)){let t=b.multiplyByVector(S,h,G),e=p([t=g.scaleToGeodeticSurface(t,t)],Y)[0];w.subtract(e,X,e);let o=I.clamp(e.x/r.width,0,1),i=I.clamp(e.y/r.height,0,1);c&&(P[H+te]=o,P[H+1+te]=i),u&&(P[H]=o,P[H+1]=i),H+=2}if(e.normal||e.tangent||e.bitangent||i){let r=R+1,a=R+2;if(l){if(o+3<s){let t=O.fromArray(n,o+3,D);if(C){let e=O.fromArray(n,o+s,V);y&&function(t,e,o,i){let n=i.cartesianToCartographic(t,j).height,r=i.cartesianToCartographic(e,F);r.height=n,i.cartographicToCartesian(r,e);let a=i.cartesianToCartographic(o,F);a.height=n-100,i.cartographicToCartesian(a,o)}(h,t,e,g),O.subtract(t,h,t),O.subtract(e,h,e),L=O.normalize(O.cross(e,t,L),L),C=!1}O.equalsEpsilon(t,h,I.EPSILON10)&&(C=!0)}(e.tangent||e.bitangent)&&(k=g.geodeticSurfaceNormal(h,k),e.tangent&&(N=O.normalize(O.cross(k,L,N),N)))}else L=g.geodeticSurfaceNormal(h,L),(e.tangent||e.bitangent)&&(y&&(z=O.fromArray(T,R,z),W=O.cross(O.UNIT_Z,z,W),W=O.normalize(b.multiplyByVector($,W,W),W),e.bitangent&&(K=O.normalize(O.cross(z,W,K),K))),N=O.cross(O.UNIT_Z,L,N),N=O.normalize(b.multiplyByVector($,N,N),N),e.bitangent&&(k=O.normalize(O.cross(L,N,k),k)));e.normal&&(t.wall?(T[R+tt]=L.x,T[r+tt]=L.y,T[a+tt]=L.z):c&&(T[R+tt]=-L.x,T[r+tt]=-L.y,T[a+tt]=-L.z),(u&&!y||l)&&(T[R]=L.x,T[r]=L.y,T[a]=L.z)),i&&(l&&(L=g.geodeticSurfaceNormal(h,L)),x[R+tt]=-L.x,x[r+tt]=-L.y,x[a+tt]=-L.z),e.tangent&&(t.wall?(A[R+tt]=N.x,A[r+tt]=N.y,A[a+tt]=N.z):c&&(A[R+tt]=-N.x,A[r+tt]=-N.y,A[a+tt]=-N.z),u&&(y?(A[R]=W.x,A[r]=W.y,A[a]=W.z):(A[R]=N.x,A[r]=N.y,A[a]=N.z))),e.bitangent&&(c&&(E[R+tt]=k.x,E[r+tt]=k.y,E[a+tt]=k.z),u&&(y?(E[R]=K.x,E[r]=K.y,E[a]=K.z):(E[R]=k.x,E[r]=k.y,E[a]=k.z))),R+=3}}e.st&&!v(a)&&(o.attributes.st=new m({componentDatatype:_.FLOAT,componentsPerAttribute:2,values:P})),e.normal&&(o.attributes.normal=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:T})),e.tangent&&(o.attributes.tangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:A})),e.bitangent&&(o.attributes.bitangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:E})),i&&(o.attributes.extrudeDirection=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:x}))}if(t.extrude&&v(t.offsetAttribute)){let e=n.length/3,i=new Uint8Array(e);if(t.offsetAttribute===r.TOP)u&&c||l?i=i.fill(1,0,e/2):u&&(i=i.fill(1));else{let e=+(t.offsetAttribute!==r.NONE);i=i.fill(e)}o.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return o}var tt=[];function te(t){if(x.typeOf.object("options",t),x.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),v(t.perPositionHeight)&&t.perPositionHeight&&v(t.height))throw new E("Cannot use both options.perPositionHeight and options.height");if(v(t.arcType)&&t.arcType!==o.GEODESIC&&t.arcType!==o.RHUMB)throw new E("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let i=t.polygonHierarchy,n=t.vertexFormat??a.DEFAULT,r=t.ellipsoid??T.default,s=t.granularity??I.RADIANS_PER_DEGREE,l=t.stRotation??0,u=t.textureCoordinates,c=t.perPositionHeight??!1,h=c&&v(t.extrudedHeight),p=t.height??0,g=t.extrudedHeight??p;if(!h){let t=Math.max(p,g);g=Math.min(p,g),p=t}this._vertexFormat=a.clone(n),this._ellipsoid=T.clone(r),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=g,this._closeTop=t.closeTop??!0,this._closeBottom=t.closeBottom??!0,this._polygonHierarchy=i,this._perPositionHeight=c,this._perPositionHeightExtrude=h,this._shadowVolume=t.shadowVolume??!1,this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=t.arcType??o.GEODESIC,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=e.computeHierarchyPackedLength(i,O)+T.packedLength+a.packedLength+(u?e.computeHierarchyPackedLength(u,w):1)+12}te.fromPositions=function(t){return t=t??A.EMPTY_OBJECT,x.defined("options.positions",t.positions),new te({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},te.pack=function(t,o,i){return x.typeOf.object("value",t),x.defined("array",o),i=i??0,i=e.packPolygonHierarchy(t._polygonHierarchy,o,i,O),T.pack(t._ellipsoid,o,i),i+=T.packedLength,a.pack(t._vertexFormat,o,i),i+=a.packedLength,o[i++]=t._height,o[i++]=t._extrudedHeight,o[i++]=t._granularity,o[i++]=t._stRotation,o[i++]=+!!t._perPositionHeightExtrude,o[i++]=+!!t._perPositionHeight,o[i++]=+!!t._closeTop,o[i++]=+!!t._closeBottom,o[i++]=+!!t._shadowVolume,o[i++]=t._offsetAttribute??-1,o[i++]=t._arcType,v(t._textureCoordinates)?i=e.packPolygonHierarchy(t._textureCoordinates,o,i,w):o[i++]=-1,o[i++]=t.packedLength,o};var to=T.clone(T.UNIT_SPHERE),ti=new a,tn={polygonHierarchy:{}};te.unpack=function(t,o,i){x.defined("array",t),o=o??0;let n=e.unpackPolygonHierarchy(t,o,O);o=n.startingIndex,delete n.startingIndex;let r=T.unpack(t,o,to);o+=T.packedLength;let s=a.unpack(t,o,ti);o+=a.packedLength;let l=t[o++],u=t[o++],c=t[o++],h=t[o++],p=1===t[o++],g=1===t[o++],m=1===t[o++],d=1===t[o++],f=1===t[o++],y=t[o++],_=t[o++],P=-1===t[o]?void 0:e.unpackPolygonHierarchy(t,o,w);v(P)?(o=P.startingIndex,delete P.startingIndex):o++;let b=t[o++];return v(i)||(i=new te(tn)),i._polygonHierarchy=n,i._ellipsoid=T.clone(r,i._ellipsoid),i._vertexFormat=a.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=u,i._granularity=c,i._stRotation=h,i._perPositionHeightExtrude=p,i._perPositionHeight=g,i._closeTop=m,i._closeBottom=d,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i._arcType=_,i._textureCoordinates=P,i.packedLength=b,i};var tr=new w,ta=new w,ts=new H;function tl(t,e,i,n,r,a){let s=t.longitude,l=s>=0?s:s+I.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),a.west=Math.min(a.west,s),a.east=Math.max(a.east,s);let u=t.getLatitude(i),c=u;if(a.south=Math.min(a.south,u),a.north=Math.max(a.north,u),n!==o.RHUMB){let o=w.subtract(e.position,t.position,tr),n=w.dot(e.position,o)/w.dot(o,o);if(n>0&&n<1){let t=w.add(e.position,w.multiplyByScalar(o,-n,o),ta),r=H.clone(e,ts);r.position=t;let s=r.getLatitude(i);a.south=Math.min(a.south,s),a.north=Math.max(a.north,s),Math.abs(u)>Math.abs(s)&&(c=s)}}let h=Math.sign(e.x*t.y-t.x*e.y);0!==h&&(h*=w.angleBetween(e.position,t.position)),c>=0&&(r.northAngle+=h),c<=0&&(r.southAngle+=h)}var tu=new H,tc=new H,th={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};te.computeRectangleFromPositions=function(t,e,o,i){if(x.defined("positions",t),v(i)||(i=new y),t.length<3)return i;i.west=1/0,i.east=-1/0,i.south=1/0,i.north=-1/0,th.northAngle=0,th.southAngle=0,th.westOverIdl=1/0,th.eastOverIdl=-1/0;let n=t.length,r=H.fromCartesian(t[0],tc);for(let a=1;a<n;a++){let n=H.fromCartesian(t[a],tu);tl(n,r,e,o,th,i),r=H.clone(n,r)}return tl(H.fromCartesian(t[0],tu),r,e,o,th,i),i.east-i.west>th.eastOverIdl-th.westOverIdl&&(i.west=th.westOverIdl,i.east=th.eastOverIdl,i.east>I.PI&&(i.east=i.east-I.TWO_PI),i.west>I.PI&&(i.west=i.west-I.TWO_PI)),I.equalsEpsilon(Math.abs(th.northAngle),I.TWO_PI,I.EPSILON10)&&(i.north=I.PI_OVER_TWO,i.east=I.PI,i.west=-I.PI),I.equalsEpsilon(Math.abs(th.southAngle),I.TWO_PI,I.EPSILON10)&&(i.south=-I.PI_OVER_TWO,i.east=I.PI,i.west=-I.PI),i};var tp=new H,tg=new P;te.createGeometry=function(o){let a=o._vertexFormat,c=o._ellipsoid,h=o._granularity,f=o._stRotation,y=o._polygonHierarchy,P=o._perPositionHeight,T=o._closeTop,O=o._closeBottom,b=o._arcType,A=o._textureCoordinates,E=v(A),x=y.positions;if(x.length<3)return;let R=o.rectangle,L=e.polygonsFromHierarchy(y,E,(t,e)=>{if(R.height>=I.PI||R.width>=I.PI){if(R.south<0&&R.north>0){v(e)||(e=[]);for(let o=0;o<t.length;++o){let i=c.cartesianToCartographic(t[o],tg);e[o]=new w(i.longitude/I.PI,i.latitude/I.PI_OVER_TWO)}return e.length=t.length,e}return H.fromCartesianArray(t,e)}return s.fromPoints(x,c).projectPointsOntoPlane(t,e)},!P,c,(t,o)=>!P&&(R.height>=I.PI_OVER_TWO||R.width>=2*I.PI_OVER_THREE)?e.splitPolygonsOnEquator(t,c,b,o):t),N=L.hierarchy,k=L.polygons,C=E?e.polygonsFromHierarchy(A,!0,function(t){return t},!1,c).polygons:void 0;if(0===N.length)return;let j=N[0].outerRing,F=function(o,i,n,r){if(i.height>=I.PI||i.width>=I.PI)return t.fromRectangle(i,void 0,S);let a=s.fromPoints(o,n);return e.computeBoundingRectangle(a.plane.normal,a.projectPointOntoPlane.bind(a),o,r,S)}(j,R,c,f),G=[],M=o._height,B=o._extrudedHeight,U=o._perPositionHeightExtrude||!I.equalsEpsilon(M,B,0,I.EPSILON2),D={perPositionHeight:P,vertexFormat:a,geometry:void 0,rotationAxis:(R.height>=I.PI||R.width>=I.PI?H.fromCartesian(j[0],tp).tangentPlane:s.fromPoints(j,c)).plane.normal,projectTo2d:function(t,e,o){if(t.height>=I.PI||t.width>=I.PI)return(e,i)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,tg);return v(i)||(i=new w),i.x=t.longitude/I.PI,i.y=t.latitude/I.PI_OVER_TWO,i}return H.fromCartesian(e,i)};let i=s.fromPoints(e,o);return(t,e)=>i.projectPointsOntoPlane(t,e)}(R,j,c),boundingRectangle:F,ellipsoid:c,stRotation:f,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:b},V;if(U)for(D.extrude=!0,D.top=T,D.bottom=O,D.shadowVolume=o._shadowVolume,D.offsetAttribute=o._offsetAttribute,V=0;V<k.length;V++){let t=function(t,o,n,r,a,c,h,g,m,d){let f={walls:[]},y;if(h||g){let a=e.createGeometryFromPositions(t,o,n,r,c,m,d),s=a.attributes.position.values,l=a.indices,u,_;if(h&&g){let t=s.concat(s);u=t.length/3,(_=p.createTypedArray(u,2*l.length)).set(l);let e=l.length,o=u/2;for(y=0;y<e;y+=3){let t=_[y]+o,i=_[y+1]+o,n=_[y+2]+o;_[y+e]=n,_[y+1+e]=i,_[y+2+e]=t}if(a.attributes.position.values=t,c&&m.normal){let e=a.attributes.normal.values;a.attributes.normal.values=new Float32Array(t.length),a.attributes.normal.values.set(e)}if(m.st&&v(n)){let t=a.attributes.st.values;a.attributes.st.values=new Float32Array(2*u),a.attributes.st.values=t.concat(t)}a.indices=_}else if(g){for(u=s.length/3,_=p.createTypedArray(u,l.length),y=0;y<l.length;y+=3)_[y]=l[y+2],_[y+1]=l[y+1],_[y+2]=l[y];a.indices=_}f.topAndBottom=new i({geometry:a})}let _=a.outerRing,P=s.fromPoints(_,t),w=P.projectPointsOntoPlane(_,tt),T=u.computeWindingOrder2D(w);T===l.CLOCKWISE&&(_=_.slice().reverse());let O=e.computeWallGeometry(_,n,t,r,c,d);f.walls.push(new i({geometry:O}));let b=a.holes;for(y=0;y<b.length;y++){let o=b[y];w=P.projectPointsOntoPlane(o,tt),(T=u.computeWindingOrder2D(w))===l.COUNTER_CLOCKWISE&&(o=o.slice().reverse()),O=e.computeWallGeometry(o,n,t,r,c,d),f.walls.push(new i({geometry:O}))}return f}(c,k[V],E?C[V]:void 0,h,N[V],P,T,O,a,b),o;T&&O?(o=t.topAndBottom,D.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,M,B,c,P)):T?((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,M,c,!P),D.geometry=o.geometry):O&&((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,B,c,!0),D.geometry=o.geometry),(T||O)&&(D.wall=!1,o.geometry=$(D),G.push(o));let n=t.walls;D.wall=!0;for(let t=0;t<n.length;t++){let o=n[t];D.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,M,B,c,P),o.geometry=$(D),G.push(o)}}else for(V=0;V<k.length;V++){let t=new i({geometry:e.createGeometryFromPositions(c,k[V],E?C[V]:void 0,h,P,a,b)});if(t.geometry.attributes.position.values=u.scaleToGeodeticHeight(t.geometry.attributes.position.values,M,c,!P),D.geometry=t.geometry,t.geometry=$(D),v(o._offsetAttribute)){let e=t.geometry.attributes.position.values.length,i=+(o._offsetAttribute!==r.NONE),n=new Uint8Array(e/3).fill(i);t.geometry.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}G.push(t)}let z=n.combineInstances(G)[0];z.attributes.position.values=new Float64Array(z.attributes.position.values),z.indices=p.createTypedArray(z.attributes.position.values.length/3,z.indices);let W=z.attributes,K=d.fromVertices(W.position.values);return a.position||delete W.position,new g({attributes:W,indices:z.indices,primitiveType:z.primitiveType,boundingSphere:K,offsetAttribute:o._offsetAttribute})},te.createShadowVolume=function(t,e,o){let i=t._granularity,n=t._ellipsoid,r=e(i,n),s=o(i,n);return new te({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:s,vertexFormat:a.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!v(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=te.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return v(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return g._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}});var tm=function(t,e){return v(e)&&(t=te.unpack(t,e)),t._ellipsoid=T.clone(t._ellipsoid),te.createGeometry(t)};export{tm as default};