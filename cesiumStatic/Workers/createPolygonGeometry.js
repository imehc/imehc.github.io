import{a as t}from"./chunk-WA4PTCEU.js";import{a as e}from"./chunk-LFYJT7PG.js";import{a as o}from"./chunk-XQCNGPKC.js";import{a as i}from"./chunk-SYTPJOV4.js";import{a as n}from"./chunk-YJI7JXLA.js";import"./chunk-DAX2P4DI.js";import"./chunk-RKB2XVMW.js";import{a as r}from"./chunk-IBQZCWHF.js";import{a as a}from"./chunk-ZXZD7KWX.js";import{a as s}from"./chunk-SI3KZUTO.js";import"./chunk-QM7HI6IF.js";import{a as l,b as u}from"./chunk-45FW5IBC.js";import"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import{a as c,b as h}from"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as p}from"./chunk-KSX6TRAS.js";import"./chunk-GMTHOMGW.js";import{c as g,d as m}from"./chunk-BELR52CD.js";import{c as d}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import{h as f,j as y}from"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as _}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{a as P,b as w,c as T}from"./chunk-ICY67TC6.js";import{a as O,b as b,c as A}from"./chunk-G2EMNOST.js";import{a as I}from"./chunk-4VFKVGYI.js";import{a as x,b as H}from"./chunk-3WJNS2B6.js";import{e as v}from"./chunk-XCN226AA.js";function E(t,e){this.position=t,v(this.position)||(this.position=new w),this.tangentPlane=e,v(this.tangentPlane)||(this.tangentPlane=E.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(E.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=w.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(I.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=I.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=I.TWO_PI),t}}});var N=new P,R=new O;E.prototype.getLatitude=function(t){v(t)||(t=T.default),N.latitude=this.conformalLatitude,N.longitude=this.longitude,N.height=0;let e=this.ellipsoid.cartographicToCartesian(N,R);return t.cartesianToCartographic(e,N),N.latitude};var C=new c,L=new O,k=new O;E.fromCartesian=function(t,e){H.defined("cartesian",t);let o=I.signNotZero(t.z),i=E.NORTH_POLE_TANGENT_PLANE,n=E.SOUTH_POLE;o<0&&(i=E.SOUTH_POLE_TANGENT_PLANE,n=E.NORTH_POLE),C.origin=i.ellipsoid.scaleToGeocentricSurface(t,C.origin),C.direction=O.subtract(C.origin,n,L),O.normalize(C.direction,C.direction);let r=h.rayPlane(C,i.plane,k),a=O.subtract(r,n,r),s=O.dot(i.xAxis,a),l=o*O.dot(i.yAxis,a);return v(e)?(e.position=new w(s,l),e.tangentPlane=i,e):new E(new w(s,l),i)},E.fromCartesianArray=function(t,e){H.defined("cartesians",t);let o=t.length;v(e)?e.length=o:e=Array(o);for(let i=0;i<o;i++)e[i]=E.fromCartesian(t[i],e[i]);return e},E.clone=function(t,e){if(v(t))return v(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new E(t.position,t.tangentPlane)},E.HALF_UNIT_SPHERE=Object.freeze(new T(.5,.5,.5)),E.NORTH_POLE=Object.freeze(new O(0,0,.5)),E.SOUTH_POLE=Object.freeze(new O(0,0,-.5)),E.NORTH_POLE_TANGENT_PLANE=Object.freeze(new s(E.NORTH_POLE,E.HALF_UNIT_SPHERE)),E.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new s(E.SOUTH_POLE,E.HALF_UNIT_SPHERE));var j=new P,F=new P,S=new t,B=new O,G=new O,M=new O,V=new O,W=new O,D=new O,z=new O,U=new O,Y=new O,K=new w,X=new w,Q=new O,Z=new f,J=new b,q=new b;function $(t){let e=t.vertexFormat,o=t.geometry,i=t.shadowVolume,n=o.attributes.position.values,a=v(o.attributes.st)?o.attributes.st.values:void 0,s=n.length,l=t.wall,u=t.top||l,c=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||i){let r=t.boundingRectangle,h=t.rotationAxis,p=t.projectTo2d,g=t.ellipsoid,d=t.stRotation,y=t.perPositionHeight;K.x=r.x,K.y=r.y;let P=e.st?new Float32Array(s/3*2):void 0,T;e.normal&&(T=y&&u&&!l?o.attributes.normal.values:new Float32Array(s));let A=e.tangent?new Float32Array(s):void 0,x=e.bitangent?new Float32Array(s):void 0,H=i?new Float32Array(s):void 0,E=0,N=0,R=G,C=M,L=V,k=!0,S=J,$=q;if(0!==d){let t=f.fromAxisAngle(h,d,Z);S=b.fromQuaternion(t,S),t=f.fromAxisAngle(h,-d,Z),$=b.fromQuaternion(t,$)}else S=b.clone(b.IDENTITY,S),$=b.clone(b.IDENTITY,$);let tt=0,te=0;u&&c&&(tt=s/2,te=s/3,s/=2);for(let o=0;o<s;o+=3){let h=O.fromArray(n,o,Q);if(e.st&&!v(a)){let t=b.multiplyByVector(S,h,B),e=p([t=g.scaleToGeodeticSurface(t,t)],X)[0];w.subtract(e,K,e);let o=I.clamp(e.x/r.width,0,1),i=I.clamp(e.y/r.height,0,1);c&&(P[E+te]=o,P[E+1+te]=i),u&&(P[E]=o,P[E+1]=i),E+=2}if(e.normal||e.tangent||e.bitangent||i){let r=N+1,a=N+2;if(l){if(o+3<s){let t=O.fromArray(n,o+3,W);if(k){let e=O.fromArray(n,o+s,D);y&&function(t,e,o,i){let n=i.cartesianToCartographic(t,j).height,r=i.cartesianToCartographic(e,F);r.height=n,i.cartographicToCartesian(r,e);let a=i.cartesianToCartographic(o,F);a.height=n-100,i.cartographicToCartesian(a,o)}(h,t,e,g),O.subtract(t,h,t),O.subtract(e,h,e),R=O.normalize(O.cross(e,t,R),R),k=!1}O.equalsEpsilon(t,h,I.EPSILON10)&&(k=!0)}(e.tangent||e.bitangent)&&(L=g.geodeticSurfaceNormal(h,L),e.tangent&&(C=O.normalize(O.cross(L,R,C),C)))}else R=g.geodeticSurfaceNormal(h,R),(e.tangent||e.bitangent)&&(y&&(z=O.fromArray(T,N,z),U=O.cross(O.UNIT_Z,z,U),U=O.normalize(b.multiplyByVector($,U,U),U),e.bitangent&&(Y=O.normalize(O.cross(z,U,Y),Y))),C=O.cross(O.UNIT_Z,R,C),C=O.normalize(b.multiplyByVector($,C,C),C),e.bitangent&&(L=O.normalize(O.cross(R,C,L),L)));e.normal&&(t.wall?(T[N+tt]=R.x,T[r+tt]=R.y,T[a+tt]=R.z):c&&(T[N+tt]=-R.x,T[r+tt]=-R.y,T[a+tt]=-R.z),(u&&!y||l)&&(T[N]=R.x,T[r]=R.y,T[a]=R.z)),i&&(l&&(R=g.geodeticSurfaceNormal(h,R)),H[N+tt]=-R.x,H[r+tt]=-R.y,H[a+tt]=-R.z),e.tangent&&(t.wall?(A[N+tt]=C.x,A[r+tt]=C.y,A[a+tt]=C.z):c&&(A[N+tt]=-C.x,A[r+tt]=-C.y,A[a+tt]=-C.z),u&&(y?(A[N]=U.x,A[r]=U.y,A[a]=U.z):(A[N]=C.x,A[r]=C.y,A[a]=C.z))),e.bitangent&&(c&&(x[N+tt]=L.x,x[r+tt]=L.y,x[a+tt]=L.z),u&&(y?(x[N]=Y.x,x[r]=Y.y,x[a]=Y.z):(x[N]=L.x,x[r]=L.y,x[a]=L.z))),N+=3}}e.st&&!v(a)&&(o.attributes.st=new m({componentDatatype:_.FLOAT,componentsPerAttribute:2,values:P})),e.normal&&(o.attributes.normal=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:T})),e.tangent&&(o.attributes.tangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:A})),e.bitangent&&(o.attributes.bitangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:x})),i&&(o.attributes.extrudeDirection=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:H}))}if(t.extrude&&v(t.offsetAttribute)){let e=n.length/3,i=new Uint8Array(e);if(t.offsetAttribute===r.TOP)u&&c||l?i=i.fill(1,0,e/2):u&&(i=i.fill(1));else{let e=+(t.offsetAttribute!==r.NONE);i=i.fill(e)}o.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return o}var tt=[];function te(t){if(H.typeOf.object("options",t),H.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),v(t.perPositionHeight)&&t.perPositionHeight&&v(t.height))throw new x("Cannot use both options.perPositionHeight and options.height");if(v(t.arcType)&&t.arcType!==o.GEODESIC&&t.arcType!==o.RHUMB)throw new x("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let i=t.polygonHierarchy,n=t.vertexFormat??a.DEFAULT,r=t.ellipsoid??T.default,s=t.granularity??I.RADIANS_PER_DEGREE,l=t.stRotation??0,u=t.textureCoordinates,c=t.perPositionHeight??!1,h=c&&v(t.extrudedHeight),p=t.height??0,g=t.extrudedHeight??p;if(!h){let t=Math.max(p,g);g=Math.min(p,g),p=t}this._vertexFormat=a.clone(n),this._ellipsoid=T.clone(r),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=g,this._closeTop=t.closeTop??!0,this._closeBottom=t.closeBottom??!0,this._polygonHierarchy=i,this._perPositionHeight=c,this._perPositionHeightExtrude=h,this._shadowVolume=t.shadowVolume??!1,this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=t.arcType??o.GEODESIC,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=e.computeHierarchyPackedLength(i,O)+T.packedLength+a.packedLength+(u?e.computeHierarchyPackedLength(u,w):1)+12}te.fromPositions=function(t){return t=t??A.EMPTY_OBJECT,H.defined("options.positions",t.positions),new te({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},te.pack=function(t,o,i){return H.typeOf.object("value",t),H.defined("array",o),i=i??0,i=e.packPolygonHierarchy(t._polygonHierarchy,o,i,O),T.pack(t._ellipsoid,o,i),i+=T.packedLength,a.pack(t._vertexFormat,o,i),i+=a.packedLength,o[i++]=t._height,o[i++]=t._extrudedHeight,o[i++]=t._granularity,o[i++]=t._stRotation,o[i++]=+!!t._perPositionHeightExtrude,o[i++]=+!!t._perPositionHeight,o[i++]=+!!t._closeTop,o[i++]=+!!t._closeBottom,o[i++]=+!!t._shadowVolume,o[i++]=t._offsetAttribute??-1,o[i++]=t._arcType,v(t._textureCoordinates)?i=e.packPolygonHierarchy(t._textureCoordinates,o,i,w):o[i++]=-1,o[i++]=t.packedLength,o};var to=T.clone(T.UNIT_SPHERE),ti=new a,tn={polygonHierarchy:{}};te.unpack=function(t,o,i){H.defined("array",t),o=o??0;let n=e.unpackPolygonHierarchy(t,o,O);o=n.startingIndex,delete n.startingIndex;let r=T.unpack(t,o,to);o+=T.packedLength;let s=a.unpack(t,o,ti);o+=a.packedLength;let l=t[o++],u=t[o++],c=t[o++],h=t[o++],p=1===t[o++],g=1===t[o++],m=1===t[o++],d=1===t[o++],f=1===t[o++],y=t[o++],_=t[o++],P=-1===t[o]?void 0:e.unpackPolygonHierarchy(t,o,w);v(P)?(o=P.startingIndex,delete P.startingIndex):o++;let b=t[o++];return v(i)||(i=new te(tn)),i._polygonHierarchy=n,i._ellipsoid=T.clone(r,i._ellipsoid),i._vertexFormat=a.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=u,i._granularity=c,i._stRotation=h,i._perPositionHeightExtrude=p,i._perPositionHeight=g,i._closeTop=m,i._closeBottom=d,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i._arcType=_,i._textureCoordinates=P,i.packedLength=b,i};var tr=new w,ta=new w,ts=new E;function tl(t,e,i,n,r,a){let s=t.longitude,l=s>=0?s:s+I.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),a.west=Math.min(a.west,s),a.east=Math.max(a.east,s);let u=t.getLatitude(i),c=u;if(a.south=Math.min(a.south,u),a.north=Math.max(a.north,u),n!==o.RHUMB){let o=w.subtract(e.position,t.position,tr),n=w.dot(e.position,o)/w.dot(o,o);if(n>0&&n<1){let t=w.add(e.position,w.multiplyByScalar(o,-n,o),ta),r=E.clone(e,ts);r.position=t;let s=r.getLatitude(i);a.south=Math.min(a.south,s),a.north=Math.max(a.north,s),Math.abs(u)>Math.abs(s)&&(c=s)}}let h=Math.sign(e.x*t.y-t.x*e.y);0!==h&&(h*=w.angleBetween(e.position,t.position)),c>=0&&(r.northAngle+=h),c<=0&&(r.southAngle+=h)}var tu=new E,tc=new E,th={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};te.computeRectangleFromPositions=function(t,e,o,i){if(H.defined("positions",t),v(i)||(i=new y),t.length<3)return i;i.west=1/0,i.east=-1/0,i.south=1/0,i.north=-1/0,th.northAngle=0,th.southAngle=0,th.westOverIdl=1/0,th.eastOverIdl=-1/0;let n=t.length,r=E.fromCartesian(t[0],tc);for(let a=1;a<n;a++){let n=E.fromCartesian(t[a],tu);tl(n,r,e,o,th,i),r=E.clone(n,r)}return tl(E.fromCartesian(t[0],tu),r,e,o,th,i),i.east-i.west>th.eastOverIdl-th.westOverIdl&&(i.west=th.westOverIdl,i.east=th.eastOverIdl,i.east>I.PI&&(i.east=i.east-I.TWO_PI),i.west>I.PI&&(i.west=i.west-I.TWO_PI)),I.equalsEpsilon(Math.abs(th.northAngle),I.TWO_PI,I.EPSILON10)&&(i.north=I.PI_OVER_TWO,i.east=I.PI,i.west=-I.PI),I.equalsEpsilon(Math.abs(th.southAngle),I.TWO_PI,I.EPSILON10)&&(i.south=-I.PI_OVER_TWO,i.east=I.PI,i.west=-I.PI),i};var tp=new E,tg=new P;te.createGeometry=function(o){let a=o._vertexFormat,c=o._ellipsoid,h=o._granularity,f=o._stRotation,y=o._polygonHierarchy,P=o._perPositionHeight,T=o._closeTop,O=o._closeBottom,b=o._arcType,A=o._textureCoordinates,x=v(A),H=y.positions;if(H.length<3)return;let N=o.rectangle,R=e.polygonsFromHierarchy(y,x,(t,e)=>{if(N.height>=I.PI||N.width>=I.PI){if(N.south<0&&N.north>0){v(e)||(e=[]);for(let o=0;o<t.length;++o){let i=c.cartesianToCartographic(t[o],tg);e[o]=new w(i.longitude/I.PI,i.latitude/I.PI_OVER_TWO)}return e.length=t.length,e}return E.fromCartesianArray(t,e)}return s.fromPoints(H,c).projectPointsOntoPlane(t,e)},!P,c,(t,o)=>!P&&(N.height>=I.PI_OVER_TWO||N.width>=2*I.PI_OVER_THREE)?e.splitPolygonsOnEquator(t,c,b,o):t),C=R.hierarchy,L=R.polygons,k=x?e.polygonsFromHierarchy(A,!0,function(t){return t},!1,c).polygons:void 0;if(0===C.length)return;let j=C[0].outerRing,F=function(o,i,n,r){if(i.height>=I.PI||i.width>=I.PI)return t.fromRectangle(i,void 0,S);let a=s.fromPoints(o,n);return e.computeBoundingRectangle(a.plane.normal,a.projectPointOntoPlane.bind(a),o,r,S)}(j,N,c,f),B=[],G=o._height,M=o._extrudedHeight,V=o._perPositionHeightExtrude||!I.equalsEpsilon(G,M,0,I.EPSILON2),W={perPositionHeight:P,vertexFormat:a,geometry:void 0,rotationAxis:(N.height>=I.PI||N.width>=I.PI?E.fromCartesian(j[0],tp).tangentPlane:s.fromPoints(j,c)).plane.normal,projectTo2d:function(t,e,o){if(t.height>=I.PI||t.width>=I.PI)return(e,i)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,tg);return v(i)||(i=new w),i.x=t.longitude/I.PI,i.y=t.latitude/I.PI_OVER_TWO,i}return E.fromCartesian(e,i)};let i=s.fromPoints(e,o);return(t,e)=>i.projectPointsOntoPlane(t,e)}(N,j,c),boundingRectangle:F,ellipsoid:c,stRotation:f,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:b},D;if(V)for(W.extrude=!0,W.top=T,W.bottom=O,W.shadowVolume=o._shadowVolume,W.offsetAttribute=o._offsetAttribute,D=0;D<L.length;D++){let t=function(t,o,n,r,a,c,h,g,m,d){let f={walls:[]},y;if(h||g){let a=e.createGeometryFromPositions(t,o,n,r,c,m,d),s=a.attributes.position.values,l=a.indices,u,_;if(h&&g){let t=s.concat(s);u=t.length/3,(_=p.createTypedArray(u,2*l.length)).set(l);let e=l.length,o=u/2;for(y=0;y<e;y+=3){let t=_[y]+o,i=_[y+1]+o,n=_[y+2]+o;_[y+e]=n,_[y+1+e]=i,_[y+2+e]=t}if(a.attributes.position.values=t,c&&m.normal){let e=a.attributes.normal.values;a.attributes.normal.values=new Float32Array(t.length),a.attributes.normal.values.set(e)}if(m.st&&v(n)){let t=a.attributes.st.values;a.attributes.st.values=new Float32Array(2*u),a.attributes.st.values=t.concat(t)}a.indices=_}else if(g){for(u=s.length/3,_=p.createTypedArray(u,l.length),y=0;y<l.length;y+=3)_[y]=l[y+2],_[y+1]=l[y+1],_[y+2]=l[y];a.indices=_}f.topAndBottom=new i({geometry:a})}let _=a.outerRing,P=s.fromPoints(_,t),w=P.projectPointsOntoPlane(_,tt),T=u.computeWindingOrder2D(w);T===l.CLOCKWISE&&(_=_.slice().reverse());let O=e.computeWallGeometry(_,n,t,r,c,d);f.walls.push(new i({geometry:O}));let b=a.holes;for(y=0;y<b.length;y++){let o=b[y];w=P.projectPointsOntoPlane(o,tt),(T=u.computeWindingOrder2D(w))===l.COUNTER_CLOCKWISE&&(o=o.slice().reverse()),O=e.computeWallGeometry(o,n,t,r,c,d),f.walls.push(new i({geometry:O}))}return f}(c,L[D],x?k[D]:void 0,h,C[D],P,T,O,a,b),o;T&&O?(o=t.topAndBottom,W.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,G,M,c,P)):T?((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,G,c,!P),W.geometry=o.geometry):O&&((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,M,c,!0),W.geometry=o.geometry),(T||O)&&(W.wall=!1,o.geometry=$(W),B.push(o));let n=t.walls;W.wall=!0;for(let t=0;t<n.length;t++){let o=n[t];W.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,G,M,c,P),o.geometry=$(W),B.push(o)}}else for(D=0;D<L.length;D++){let t=new i({geometry:e.createGeometryFromPositions(c,L[D],x?k[D]:void 0,h,P,a,b)});if(t.geometry.attributes.position.values=u.scaleToGeodeticHeight(t.geometry.attributes.position.values,G,c,!P),W.geometry=t.geometry,t.geometry=$(W),v(o._offsetAttribute)){let e=t.geometry.attributes.position.values.length,i=+(o._offsetAttribute!==r.NONE),n=new Uint8Array(e/3).fill(i);t.geometry.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}B.push(t)}let z=n.combineInstances(B)[0];z.attributes.position.values=new Float64Array(z.attributes.position.values),z.indices=p.createTypedArray(z.attributes.position.values.length/3,z.indices);let U=z.attributes,Y=d.fromVertices(U.position.values);return a.position||delete U.position,new g({attributes:U,indices:z.indices,primitiveType:z.primitiveType,boundingSphere:Y,offsetAttribute:o._offsetAttribute})},te.createShadowVolume=function(t,e,o){let i=t._granularity,n=t._ellipsoid,r=e(i,n),s=o(i,n);return new te({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:s,vertexFormat:a.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!v(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=te.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return v(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return g._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}});var tm=function(t,e){return v(e)&&(t=te.unpack(t,e)),t._ellipsoid=T.clone(t._ellipsoid),te.createGeometry(t)};export{tm as default};