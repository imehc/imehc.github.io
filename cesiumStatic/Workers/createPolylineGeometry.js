import{a as e}from"./chunk-U27UHDI4.js";import{a as t}from"./chunk-MCM3P7ZC.js";import{a as r}from"./chunk-2A2JFXXO.js";import"./chunk-TULFNR3P.js";import{a as o}from"./chunk-PXD6ATBI.js";import{a as n}from"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as a}from"./chunk-GSMLTRAL.js";import{a as i}from"./chunk-IUX576XK.js";import{a as s,b as l,c as c,d as p}from"./chunk-UIGT6VOJ.js";import{c as h}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as u}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{c as m}from"./chunk-KCR7AORG.js";import{a as d,c as f}from"./chunk-QDJTHWTA.js";import{a as k}from"./chunk-2YWR3G22.js";import{a as g}from"./chunk-HTSQLHXI.js";import{e as y}from"./chunk-JDAHMWM5.js";var w=[];function _(r){let n=(r=r??f.EMPTY_OBJECT).positions,a=r.colors,i=r.width??1,s=r.colorsPerVertex??!1;if(!y(n)||n.length<2)throw new g("At least two positions are required.");if("number"!=typeof i)throw new g("width must be a number");if(y(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new g("colors has an invalid length.");this._positions=n,this._colors=a,this._width=i,this._colorsPerVertex=s,this._vertexFormat=o.clone(r.vertexFormat??o.DEFAULT),this._arcType=r.arcType??t.GEODESIC,this._granularity=r.granularity??k.RADIANS_PER_DEGREE,this._ellipsoid=m.clone(r.ellipsoid??m.default),this._workerName="createPolylineGeometry";let l=1+n.length*d.packedLength;l+=y(a)?1+a.length*e.packedLength:1,this.packedLength=l+m.packedLength+o.packedLength+4}_.pack=function(t,r,n){if(!y(t))throw new g("value is required");if(!y(r))throw new g("array is required");n=n??0;let a,i=t._positions,s=i.length;for(r[n++]=s,a=0;a<s;++a,n+=d.packedLength)d.pack(i[a],r,n);let l=t._colors;for(s=y(l)?l.length:0,r[n++]=s,a=0;a<s;++a,n+=e.packedLength)e.pack(l[a],r,n);return m.pack(t._ellipsoid,r,n),n+=m.packedLength,o.pack(t._vertexFormat,r,n),n+=o.packedLength,r[n++]=t._width,r[n++]=+!!t._colorsPerVertex,r[n++]=t._arcType,r[n]=t._granularity,r};var A=m.clone(m.UNIT_SPHERE),E=new o,P={positions:void 0,colors:void 0,ellipsoid:A,vertexFormat:E,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(t,r,n){if(!y(t))throw new g("array is required");r=r??0;let a,i=t[r++],s=Array(i);for(a=0;a<i;++a,r+=d.packedLength)s[a]=d.unpack(t,r);let l=(i=t[r++])>0?Array(i):void 0;for(a=0;a<i;++a,r+=e.packedLength)l[a]=e.unpack(t,r);let c=m.unpack(t,r,A);r+=m.packedLength;let p=o.unpack(t,r,E);r+=o.packedLength;let h=t[r++],u=1===t[r++],f=t[r++],k=t[r];return y(n)?(n._positions=s,n._colors=l,n._ellipsoid=m.clone(c,n._ellipsoid),n._vertexFormat=o.clone(p,n._vertexFormat),n._width=h,n._colorsPerVertex=u,n._arcType=f,n._granularity=k,n):(P.positions=s,P.colors=l,P.width=h,P.colorsPerVertex=u,P.arcType=f,P.granularity=k,new _(P))};var v=new d,L=new d,T=new d,j=new d;_.createGeometry=function(o){let m=o._width,f=o._vertexFormat,g=o._colors,_=o._colorsPerVertex,A=o._arcType,E=o._granularity,P=o._ellipsoid,F,D,b,x=[],O=n(o._positions,d.equalsEpsilon,!1,x);if(y(g)&&x.length>0){let e=0,t=x[0];g=g.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=x[++e],!1)})}let I=O.length;if(I<2||m<=0)return;if(A===t.GEODESIC||A===t.RHUMB){let o,n;A===t.GEODESIC?(o=k.chordLength(E,P.maximumRadius),n=r.numberOfPoints):(o=E,n=r.numberOfPointsRhumbLine);let a=r.extractHeights(O,P);if(y(g)){let t=1;for(F=0;F<I-1;++F)t+=n(O[F],O[F+1],o);let r=Array(t),a=0;for(F=0;F<I-1;++F){let i=O[F],s=O[F+1],l=g[F],c=n(i,s,o);if(_&&F<t){let t=function(t,r,o,n,a){w.length=a;let i,s=o.red,l=o.green,c=o.blue,p=o.alpha,h=n.red,u=n.green,m=n.blue,d=n.alpha;if(e.equals(o,n)){for(i=0;i<a;i++)w[i]=e.clone(o);return w}let f=(h-s)/a,k=(u-l)/a,g=(m-c)/a,y=(d-p)/a;for(i=0;i<a;i++)w[i]=new e(s+i*f,l+i*k,c+i*g,p+i*y);return w}(0,0,l,g[F+1],c),o=t.length;for(D=0;D<o;++D)r[a++]=t[D]}else for(D=0;D<c;++D)r[a++]=e.clone(l)}r[a]=e.clone(g[g.length-1]),g=r,w.length=0}O=A===t.GEODESIC?r.generateCartesianArc({positions:O,minDistance:o,ellipsoid:P,height:a}):r.generateCartesianRhumbArc({positions:O,granularity:o,ellipsoid:P,height:a})}let G=4*(I=O.length)-4,R=new Float64Array(3*G),B=new Float64Array(3*G),S=new Float64Array(3*G),U=new Float32Array(2*G),C=f.st?new Float32Array(2*G):void 0,H=y(g)?new Uint8Array(4*G):void 0,M=0,N=0,V=0,K=0,X;for(D=0;D<I;++D){let t,r;0===D?(X=v,d.subtract(O[0],O[1],X),d.add(O[0],X,X)):X=O[D-1],d.clone(X,T),d.clone(O[D],L),D===I-1?(X=v,d.subtract(O[I-1],O[I-2],X),d.add(O[I-1],X,X)):X=O[D+1],d.clone(X,j),y(H)&&(t=0===D||_?g[D]:g[D-1],D!==I-1&&(r=g[D]));let o=2*(0===D),n=D===I-1?2:4;for(b=o;b<n;++b){d.pack(L,R,M),d.pack(T,B,M),d.pack(j,S,M),M+=3;let o=b-2<0?-1:1;if(U[N++]=b%2*2-1,U[N++]=o*m,f.st&&(C[V++]=D/(I-1),C[V++]=Math.max(U[N-2],0)),y(H)){let o=b<2?t:r;H[K++]=e.floatToByte(o.red),H[K++]=e.floatToByte(o.green),H[K++]=e.floatToByte(o.blue),H[K++]=e.floatToByte(o.alpha)}}}let J=new i;J.position=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:R}),J.prevPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:B}),J.nextPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:S}),J.expandAndWidth=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:U}),f.st&&(J.st=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:C})),y(H)&&(J.color=new p({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:4,values:H,normalize:!0}));let q=a.createTypedArray(G,6*I-6),Q=0,W=0,Y=I-1;for(D=0;D<Y;++D)q[W++]=Q,q[W++]=Q+2,q[W++]=Q+1,q[W++]=Q+1,q[W++]=Q+2,q[W++]=Q+3,Q+=4;return new c({attributes:J,indices:q,primitiveType:l.TRIANGLES,boundingSphere:h.fromPoints(O),geometryType:s.POLYLINES})};var F=function(e,t){return y(t)&&(e=_.unpack(e,t)),e._ellipsoid=m.clone(e._ellipsoid),_.createGeometry(e)};export{F as default};