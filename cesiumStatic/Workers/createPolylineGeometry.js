import{a as e}from"./chunk-MHP75ZQC.js";import{a as t}from"./chunk-XQCNGPKC.js";import{a as r}from"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import{a as o}from"./chunk-ZXZD7KWX.js";import{a as n}from"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as a}from"./chunk-KSX6TRAS.js";import{a as i}from"./chunk-GMTHOMGW.js";import{a as s,b as l,c as c,d as p}from"./chunk-BELR52CD.js";import{c as h}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as u}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{c as m}from"./chunk-ICY67TC6.js";import{a as d,c as f}from"./chunk-G2EMNOST.js";import{a as k}from"./chunk-4VFKVGYI.js";import{a as g}from"./chunk-3WJNS2B6.js";import{e as y}from"./chunk-XCN226AA.js";var w=[];function _(r){let n=(r=r??f.EMPTY_OBJECT).positions,a=r.colors,i=r.width??1,s=r.colorsPerVertex??!1;if(!y(n)||n.length<2)throw new g("At least two positions are required.");if("number"!=typeof i)throw new g("width must be a number");if(y(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new g("colors has an invalid length.");this._positions=n,this._colors=a,this._width=i,this._colorsPerVertex=s,this._vertexFormat=o.clone(r.vertexFormat??o.DEFAULT),this._arcType=r.arcType??t.GEODESIC,this._granularity=r.granularity??k.RADIANS_PER_DEGREE,this._ellipsoid=m.clone(r.ellipsoid??m.default),this._workerName="createPolylineGeometry";let l=1+n.length*d.packedLength;l+=y(a)?1+a.length*e.packedLength:1,this.packedLength=l+m.packedLength+o.packedLength+4}_.pack=function(t,r,n){if(!y(t))throw new g("value is required");if(!y(r))throw new g("array is required");n=n??0;let a,i=t._positions,s=i.length;for(r[n++]=s,a=0;a<s;++a,n+=d.packedLength)d.pack(i[a],r,n);let l=t._colors;for(s=y(l)?l.length:0,r[n++]=s,a=0;a<s;++a,n+=e.packedLength)e.pack(l[a],r,n);return m.pack(t._ellipsoid,r,n),n+=m.packedLength,o.pack(t._vertexFormat,r,n),n+=o.packedLength,r[n++]=t._width,r[n++]=+!!t._colorsPerVertex,r[n++]=t._arcType,r[n]=t._granularity,r};var v=m.clone(m.UNIT_SPHERE),A=new o,T={positions:void 0,colors:void 0,ellipsoid:v,vertexFormat:A,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(t,r,n){if(!y(t))throw new g("array is required");r=r??0;let a,i=t[r++],s=Array(i);for(a=0;a<i;++a,r+=d.packedLength)s[a]=d.unpack(t,r);let l=(i=t[r++])>0?Array(i):void 0;for(a=0;a<i;++a,r+=e.packedLength)l[a]=e.unpack(t,r);let c=m.unpack(t,r,v);r+=m.packedLength;let p=o.unpack(t,r,A);r+=o.packedLength;let h=t[r++],u=1===t[r++],f=t[r++],k=t[r];return y(n)?(n._positions=s,n._colors=l,n._ellipsoid=m.clone(c,n._ellipsoid),n._vertexFormat=o.clone(p,n._vertexFormat),n._width=h,n._colorsPerVertex=u,n._arcType=f,n._granularity=k,n):(T.positions=s,T.colors=l,T.width=h,T.colorsPerVertex=u,T.arcType=f,T.granularity=k,new _(T))};var L=new d,E=new d,P=new d,j=new d;_.createGeometry=function(o){let m=o._width,f=o._vertexFormat,g=o._colors,_=o._colorsPerVertex,v=o._arcType,A=o._granularity,T=o._ellipsoid,D,b,x,C=[],F=n(o._positions,d.equalsEpsilon,!1,C);if(y(g)&&C.length>0){let e=0,t=C[0];g=g.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=C[++e],!1)})}let N=F.length;if(N<2||m<=0)return;if(v===t.GEODESIC||v===t.RHUMB){let o,n;v===t.GEODESIC?(o=k.chordLength(A,T.maximumRadius),n=r.numberOfPoints):(o=A,n=r.numberOfPointsRhumbLine);let a=r.extractHeights(F,T);if(y(g)){let t=1;for(D=0;D<N-1;++D)t+=n(F[D],F[D+1],o);let r=Array(t),a=0;for(D=0;D<N-1;++D){let i=F[D],s=F[D+1],l=g[D],c=n(i,s,o);if(_&&D<t){let t=function(t,r,o,n,a){w.length=a;let i,s=o.red,l=o.green,c=o.blue,p=o.alpha,h=n.red,u=n.green,m=n.blue,d=n.alpha;if(e.equals(o,n)){for(i=0;i<a;i++)w[i]=e.clone(o);return w}let f=(h-s)/a,k=(u-l)/a,g=(m-c)/a,y=(d-p)/a;for(i=0;i<a;i++)w[i]=new e(s+i*f,l+i*k,c+i*g,p+i*y);return w}(0,0,l,g[D+1],c),o=t.length;for(b=0;b<o;++b)r[a++]=t[b]}else for(b=0;b<c;++b)r[a++]=e.clone(l)}r[a]=e.clone(g[g.length-1]),g=r,w.length=0}F=v===t.GEODESIC?r.generateCartesianArc({positions:F,minDistance:o,ellipsoid:T,height:a}):r.generateCartesianRhumbArc({positions:F,granularity:o,ellipsoid:T,height:a})}let O=4*(N=F.length)-4,S=new Float64Array(3*O),B=new Float64Array(3*O),G=new Float64Array(3*O),I=new Float32Array(2*O),V=f.st?new Float32Array(2*O):void 0,R=y(g)?new Uint8Array(4*O):void 0,H=0,M=0,U=0,Y=0,W;for(b=0;b<N;++b){let t,r;0===b?(W=L,d.subtract(F[0],F[1],W),d.add(F[0],W,W)):W=F[b-1],d.clone(W,P),d.clone(F[b],E),b===N-1?(W=L,d.subtract(F[N-1],F[N-2],W),d.add(F[N-1],W,W)):W=F[b+1],d.clone(W,j),y(R)&&(t=0===b||_?g[b]:g[b-1],b!==N-1&&(r=g[b]));let o=2*(0===b),n=b===N-1?2:4;for(x=o;x<n;++x){d.pack(E,S,H),d.pack(P,B,H),d.pack(j,G,H),H+=3;let o=x-2<0?-1:1;if(I[M++]=x%2*2-1,I[M++]=o*m,f.st&&(V[U++]=b/(N-1),V[U++]=Math.max(I[M-2],0)),y(R)){let o=x<2?t:r;R[Y++]=e.floatToByte(o.red),R[Y++]=e.floatToByte(o.green),R[Y++]=e.floatToByte(o.blue),R[Y++]=e.floatToByte(o.alpha)}}}let X=new i;X.position=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:S}),X.prevPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:B}),X.nextPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:G}),X.expandAndWidth=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:I}),f.st&&(X.st=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:V})),y(R)&&(X.color=new p({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:4,values:R,normalize:!0}));let q=a.createTypedArray(O,6*N-6),K=0,Q=0,Z=N-1;for(b=0;b<Z;++b)q[Q++]=K,q[Q++]=K+2,q[Q++]=K+1,q[Q++]=K+1,q[Q++]=K+2,q[Q++]=K+3,K+=4;return new c({attributes:X,indices:q,primitiveType:l.TRIANGLES,boundingSphere:h.fromPoints(F),geometryType:s.POLYLINES})};var D=function(e,t){return y(t)&&(e=_.unpack(e,t)),e._ellipsoid=m.clone(e._ellipsoid),_.createGeometry(e)};export{D as default};