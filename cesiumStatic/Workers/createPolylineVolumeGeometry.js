import{a as e}from"./chunk-AEXJAIC2.js";import{a as t}from"./chunk-UPV7RDUS.js";import"./chunk-NPKIHRIX.js";import"./chunk-MUKCYY2X.js";import{a as n,b as o,c as r}from"./chunk-MRH6LWHV.js";import"./chunk-2A2JFXXO.js";import"./chunk-TULFNR3P.js";import{a as i}from"./chunk-PXD6ATBI.js";import"./chunk-33M5C4LG.js";import"./chunk-X2JOWFTB.js";import{a as a,b as s}from"./chunk-TN2BIDXM.js";import{a as p}from"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as c}from"./chunk-GSMLTRAL.js";import{a as l}from"./chunk-IUX576XK.js";import{b as u,c as h,d as m}from"./chunk-UIGT6VOJ.js";import{c as k}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as g}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{b as f,c as d}from"./chunk-KCR7AORG.js";import{a as y,c as j}from"./chunk-QDJTHWTA.js";import{a as _}from"./chunk-2YWR3G22.js";import{a as L}from"./chunk-HTSQLHXI.js";import{e as v}from"./chunk-JDAHMWM5.js";function P(e){let t=(e=e??j.EMPTY_OBJECT).polylinePositions,o=e.shapePositions;if(!v(t))throw new L("options.polylinePositions is required.");if(!v(o))throw new L("options.shapePositions is required.");this._positions=t,this._shape=o,this._ellipsoid=d.clone(e.ellipsoid??d.default),this._cornerType=e.cornerType??n.ROUNDED,this._vertexFormat=i.clone(e.vertexFormat??i.DEFAULT),this._granularity=e.granularity??_.RADIANS_PER_DEGREE,this._workerName="createPolylineVolumeGeometry";let r=1+t.length*y.packedLength;r+=1+o.length*f.packedLength,this.packedLength=r+d.packedLength+i.packedLength+2}P.pack=function(e,t,n){if(!v(e))throw new L("value is required");if(!v(t))throw new L("array is required");n=n??0;let o,r=e._positions,a=r.length;for(t[n++]=a,o=0;o<a;++o,n+=y.packedLength)y.pack(r[o],t,n);let s=e._shape;for(a=s.length,t[n++]=a,o=0;o<a;++o,n+=f.packedLength)f.pack(s[o],t,n);return d.pack(e._ellipsoid,t,n),n+=d.packedLength,i.pack(e._vertexFormat,t,n),n+=i.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};var T=d.clone(d.UNIT_SPHERE),A=new i,E={polylinePositions:void 0,shapePositions:void 0,ellipsoid:T,vertexFormat:A,cornerType:void 0,granularity:void 0};P.unpack=function(e,t,n){if(!v(e))throw new L("array is required");t=t??0;let o,r=e[t++],a=Array(r);for(o=0;o<r;++o,t+=y.packedLength)a[o]=y.unpack(e,t);let s=Array(r=e[t++]);for(o=0;o<r;++o,t+=f.packedLength)s[o]=f.unpack(e,t);let p=d.unpack(e,t,T);t+=d.packedLength;let c=i.unpack(e,t,A);t+=i.packedLength;let l=e[t++],u=e[t];return v(n)?(n._positions=a,n._shape=s,n._ellipsoid=d.clone(p,n._ellipsoid),n._vertexFormat=i.clone(c,n._vertexFormat),n._cornerType=l,n._granularity=u,n):(E.polylinePositions=a,E.shapePositions=s,E.cornerType=l,E.granularity=u,new P(E))};var F=new e;P.createGeometry=function(n){let i=p(n._positions,y.equalsEpsilon),f=n._shape;if(f=r.removeDuplicatesFromShape(f),i.length<2||f.length<3)return;s.computeWindingOrder2D(f)===a.CLOCKWISE&&f.reverse();let d=e.fromPoints(f,F);return function(e,n,r,i){let a=new l;i.position&&(a.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:e}));let p=n.length,f=e.length/3,d=(f-2*p)/(2*p),y=s.triangulate(n),j=(d-1)*p*6+2*y.length,_=c.createTypedArray(f,j),L,v,P,T,A,E,F=2*p,w=0;for(L=0;L<d-1;L++){for(v=0;v<p-1;v++)E=(P=2*v+L*p*2)+F,A=(T=P+1)+F,_[w++]=T,_[w++]=P,_[w++]=A,_[w++]=A,_[w++]=P,_[w++]=E;A=(T=(P=2*p-2+L*p*2)+1)+F,E=P+F,_[w++]=T,_[w++]=P,_[w++]=A,_[w++]=A,_[w++]=P,_[w++]=E}if(i.st||i.tangent||i.bitangent){let e=new Float32Array(2*f),t=1/(d-1),o=1/r.height,i=r.height/2,s,c,l=0;for(L=0;L<d;L++){for(s=L*t,c=o*(n[0].y+i),e[l++]=s,e[l++]=c,v=1;v<p;v++)c=o*(n[v].y+i),e[l++]=s,e[l++]=c,e[l++]=s,e[l++]=c;c=o*(n[0].y+i),e[l++]=s,e[l++]=c}for(v=0;v<p;v++)s=0,c=o*(n[v].y+i),e[l++]=s,e[l++]=c;for(v=0;v<p;v++)s=(d-1)*t,c=o*(n[v].y+i),e[l++]=s,e[l++]=c;a.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}let b=f-2*p;for(L=0;L<y.length;L+=3){let e=y[L]+b,t=y[L+1]+b,n=y[L+2]+b;_[w++]=e,_[w++]=t,_[w++]=n,_[w++]=n+p,_[w++]=t+p,_[w++]=e+p}let I=new h({attributes:a,indices:_,boundingSphere:k.fromVertices(e),primitiveType:u.TRIANGLES});if(i.normal&&(I=t.computeNormal(I)),i.tangent||i.bitangent){try{I=t.computeTangentAndBitangent(I)}catch{o("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(I.attributes.tangent=void 0),i.bitangent||(I.attributes.bitangent=void 0),i.st||(I.attributes.st=void 0)}return I}(r.computePositions(i,f,d,n,!0),f,d,n._vertexFormat)};var w=function(e,t){return v(t)&&(e=P.unpack(e,t)),e._ellipsoid=d.clone(e._ellipsoid),P.createGeometry(e)};export{w as default};