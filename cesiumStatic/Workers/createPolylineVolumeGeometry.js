import{a as e}from"./chunk-WA4PTCEU.js";import{a as t}from"./chunk-YJI7JXLA.js";import"./chunk-DAX2P4DI.js";import"./chunk-RKB2XVMW.js";import{a as n,b as o,c as r}from"./chunk-KSAXP2ON.js";import"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import{a as i}from"./chunk-ZXZD7KWX.js";import"./chunk-SI3KZUTO.js";import"./chunk-QM7HI6IF.js";import{a as a,b as s}from"./chunk-45FW5IBC.js";import{a as p}from"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as c}from"./chunk-KSX6TRAS.js";import{a as l}from"./chunk-GMTHOMGW.js";import{b as u,c as h,d as m}from"./chunk-BELR52CD.js";import{c as k}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as g}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{b as f,c as d}from"./chunk-ICY67TC6.js";import{a as y,c as j}from"./chunk-G2EMNOST.js";import{a as _}from"./chunk-4VFKVGYI.js";import{a as v}from"./chunk-3WJNS2B6.js";import{e as T}from"./chunk-XCN226AA.js";function L(e){let t=(e=e??j.EMPTY_OBJECT).polylinePositions,o=e.shapePositions;if(!T(t))throw new v("options.polylinePositions is required.");if(!T(o))throw new v("options.shapePositions is required.");this._positions=t,this._shape=o,this._ellipsoid=d.clone(e.ellipsoid??d.default),this._cornerType=e.cornerType??n.ROUNDED,this._vertexFormat=i.clone(e.vertexFormat??i.DEFAULT),this._granularity=e.granularity??_.RADIANS_PER_DEGREE,this._workerName="createPolylineVolumeGeometry";let r=1+t.length*y.packedLength;r+=1+o.length*f.packedLength,this.packedLength=r+d.packedLength+i.packedLength+2}L.pack=function(e,t,n){if(!T(e))throw new v("value is required");if(!T(t))throw new v("array is required");n=n??0;let o,r=e._positions,a=r.length;for(t[n++]=a,o=0;o<a;++o,n+=y.packedLength)y.pack(r[o],t,n);let s=e._shape;for(a=s.length,t[n++]=a,o=0;o<a;++o,n+=f.packedLength)f.pack(s[o],t,n);return d.pack(e._ellipsoid,t,n),n+=d.packedLength,i.pack(e._vertexFormat,t,n),n+=i.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};var P=d.clone(d.UNIT_SPHERE),A=new i,w={polylinePositions:void 0,shapePositions:void 0,ellipsoid:P,vertexFormat:A,cornerType:void 0,granularity:void 0};L.unpack=function(e,t,n){if(!T(e))throw new v("array is required");t=t??0;let o,r=e[t++],a=Array(r);for(o=0;o<r;++o,t+=y.packedLength)a[o]=y.unpack(e,t);let s=Array(r=e[t++]);for(o=0;o<r;++o,t+=f.packedLength)s[o]=f.unpack(e,t);let p=d.unpack(e,t,P);t+=d.packedLength;let c=i.unpack(e,t,A);t+=i.packedLength;let l=e[t++],u=e[t];return T(n)?(n._positions=a,n._shape=s,n._ellipsoid=d.clone(p,n._ellipsoid),n._vertexFormat=i.clone(c,n._vertexFormat),n._cornerType=l,n._granularity=u,n):(w.polylinePositions=a,w.shapePositions=s,w.cornerType=l,w.granularity=u,new L(w))};var b=new e;L.createGeometry=function(n){let i=p(n._positions,y.equalsEpsilon),f=n._shape;if(f=r.removeDuplicatesFromShape(f),i.length<2||f.length<3)return;s.computeWindingOrder2D(f)===a.CLOCKWISE&&f.reverse();let d=e.fromPoints(f,b);return function(e,n,r,i){let a=new l;i.position&&(a.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:e}));let p=n.length,f=e.length/3,d=(f-2*p)/(2*p),y=s.triangulate(n),j=(d-1)*p*6+2*y.length,_=c.createTypedArray(f,j),v,T,L,P,A,w,b=2*p,D=0;for(v=0;v<d-1;v++){for(T=0;T<p-1;T++)w=(L=2*T+v*p*2)+b,A=(P=L+1)+b,_[D++]=P,_[D++]=L,_[D++]=A,_[D++]=A,_[D++]=L,_[D++]=w;A=(P=(L=2*p-2+v*p*2)+1)+b,w=L+b,_[D++]=P,_[D++]=L,_[D++]=A,_[D++]=A,_[D++]=L,_[D++]=w}if(i.st||i.tangent||i.bitangent){let e=new Float32Array(2*f),t=1/(d-1),o=1/r.height,i=r.height/2,s,c,l=0;for(v=0;v<d;v++){for(s=v*t,c=o*(n[0].y+i),e[l++]=s,e[l++]=c,T=1;T<p;T++)c=o*(n[T].y+i),e[l++]=s,e[l++]=c,e[l++]=s,e[l++]=c;c=o*(n[0].y+i),e[l++]=s,e[l++]=c}for(T=0;T<p;T++)s=0,c=o*(n[T].y+i),e[l++]=s,e[l++]=c;for(T=0;T<p;T++)s=(d-1)*t,c=o*(n[T].y+i),e[l++]=s,e[l++]=c;a.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}let E=f-2*p;for(v=0;v<y.length;v+=3){let e=y[v]+E,t=y[v+1]+E,n=y[v+2]+E;_[D++]=e,_[D++]=t,_[D++]=n,_[D++]=n+p,_[D++]=t+p,_[D++]=e+p}let F=new h({attributes:a,indices:_,boundingSphere:k.fromVertices(e),primitiveType:u.TRIANGLES});if(i.normal&&(F=t.computeNormal(F)),i.tangent||i.bitangent){try{F=t.computeTangentAndBitangent(F)}catch{o("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(F.attributes.tangent=void 0),i.bitangent||(F.attributes.bitangent=void 0),i.st||(F.attributes.st=void 0)}return F}(r.computePositions(i,f,d,n,!0),f,d,n._vertexFormat)};var D=function(e,t){return T(t)&&(e=L.unpack(e,t)),e._ellipsoid=d.clone(e._ellipsoid),L.createGeometry(e)};export{D as default};