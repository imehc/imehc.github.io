import{a as t}from"./chunk-R47RPQGH.js";import{a as e}from"./chunk-SYTPJOV4.js";import{a as n}from"./chunk-YJI7JXLA.js";import"./chunk-DAX2P4DI.js";import"./chunk-RKB2XVMW.js";import{a as o}from"./chunk-IBQZCWHF.js";import{a as a}from"./chunk-ZXZD7KWX.js";import{b as r}from"./chunk-45FW5IBC.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as i}from"./chunk-KSX6TRAS.js";import{a as s}from"./chunk-GMTHOMGW.js";import{b as l,c as u,d as c}from"./chunk-BELR52CD.js";import{c as m}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import{h as p,j as h,k as g}from"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as f}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{a as d,b as _,c as y}from"./chunk-ICY67TC6.js";import{a as b,b as w,c as A}from"./chunk-G2EMNOST.js";import{a as v}from"./chunk-4VFKVGYI.js";import{a as x,b as k}from"./chunk-3WJNS2B6.js";import{e as E}from"./chunk-XCN226AA.js";var F=new b,P=new b,R=new b,T=new b,N=new h,L=new _,O=new m,D=new m;function j(t,e){let n=new u({attributes:new s,primitiveType:l.TRIANGLES});return n.attributes.position=new c({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}var I=new b,H=new b;function S(e,n){let o=e._vertexFormat,a=e._ellipsoid,r=n.height,s=n.width,l=n.northCap,u=n.southCap,m=0,p=r,h=r,g=0;l&&(m=1,h-=1,g+=1),u&&(p-=1,h-=1,g+=1),g+=s*h;let d=o.position?new Float64Array(3*g):void 0,_=o.st?new Float32Array(2*g):void 0,y=0,A=0,v=Number.MAX_VALUE,x=Number.MAX_VALUE,k=-Number.MAX_VALUE,E=-Number.MAX_VALUE;for(let e=m;e<p;++e)for(let r=0;r<s;++r)t.computePosition(n,a,o.st,e,r,F,L),d[y++]=F.x,d[y++]=F.y,d[y++]=F.z,o.st&&(_[A++]=L.x,_[A++]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),E=Math.max(E,L.y));if(l&&(t.computePosition(n,a,o.st,0,0,F,L),d[y++]=F.x,d[y++]=F.y,d[y++]=F.z,o.st&&(_[A++]=L.x,_[A++]=L.y,v=L.x,x=L.y,k=L.x,E=L.y)),u&&(t.computePosition(n,a,o.st,r-1,0,F,L),d[y++]=F.x,d[y++]=F.y,d[y]=F.z,o.st&&(_[A++]=L.x,_[A]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),E=Math.max(E,L.y))),o.st&&(v<0||x<0||k>1||E>1))for(let t=0;t<_.length;t+=2)_[t]=(_[t]-v)/(k-v),_[t+1]=(_[t+1]-x)/(E-x);let N=function(t,e,n,o){let a=t.length,r=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0,l=0,u=P;if(e.normal||e.tangent||e.bitangent)for(let c=0;c<a;c+=3){let a=b.fromArray(t,c,F),m=l+1,p=l+2;u=n.geodeticSurfaceNormal(a,u),(e.tangent||e.bitangent)&&(b.cross(b.UNIT_Z,u,R),w.multiplyByVector(o,R,R),b.normalize(R,R),e.bitangent&&b.normalize(b.cross(u,R,T),T)),e.normal&&(r[l]=u.x,r[m]=u.y,r[p]=u.z),e.tangent&&(i[l]=R.x,i[m]=R.y,i[p]=R.z),e.bitangent&&(s[l]=T.x,s[m]=T.y,s[p]=T.z),l+=3}return j(e,{positions:t,normals:r,tangents:i,bitangents:s})}(d,o,a,n.tangentRotationMatrix),O=6*(s-1)*(h-1);l&&(O+=3*(s-1)),u&&(O+=3*(s-1));let D=i.createTypedArray(g,O),I=0,H=0,S;for(S=0;S<h-1;++S){for(let t=0;t<s-1;++t){let t=I,e=t+s,n=e+1,o=t+1;D[H++]=t,D[H++]=e,D[H++]=o,D[H++]=o,D[H++]=e,D[H++]=n,++I}++I}if(l||u){let t,e,n=g-1,o=g-1;if(l&&u&&(n=g-2),I=0,l)for(S=0;S<s-1;S++)e=(t=I)+1,D[H++]=n,D[H++]=t,D[H++]=e,++I;if(u)for(I=(h-1)*s,S=0;S<s-1;S++)e=(t=I)+1,D[H++]=t,D[H++]=o,D[H++]=e,++I}return N.indices=D,o.st&&(N.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:_})),N}function M(t,e,n,o,a){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n+2],t[e++]=a[n],t[e++]=a[n+1],t[e]=a[n+2],t}function C(t,e,n,o){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n],t[e]=o[n+1],t}var V=new a,B=[new b,new b,new b,new b],G=new d,z=new d;function U(e,n,o,a,r){if(0===o)return h.clone(e,r);let i=t.computeOptions(e,n,o,0,N,G),s=i.height,l=i.width;return t.computePosition(i,a,!1,0,0,B[0]),t.computePosition(i,a,!1,0,l-1,B[1]),t.computePosition(i,a,!1,s-1,0,B[2]),t.computePosition(i,a,!1,s-1,l-1,B[3]),h.fromCartesianArray(B,a,r)}function Y(t){let e=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",e),h._validate(e),e.north<e.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let n=t.height??0,o=t.extrudedHeight??n;this._rectangle=h.clone(e),this._granularity=t.granularity??v.RADIANS_PER_DEGREE,this._ellipsoid=y.clone(t.ellipsoid??y.default),this._surfaceHeight=Math.max(n,o),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._vertexFormat=a.clone(t.vertexFormat??a.DEFAULT),this._extrudedHeight=Math.min(n,o),this._shadowVolume=t.shadowVolume??!1,this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}Y.packedLength=h.packedLength+y.packedLength+a.packedLength+7,Y.pack=function(t,e,n){return k.typeOf.object("value",t),k.defined("array",e),n=n??0,h.pack(t._rectangle,e,n),n+=h.packedLength,y.pack(t._ellipsoid,e,n),n+=y.packedLength,a.pack(t._vertexFormat,e,n),n+=a.packedLength,e[n++]=t._granularity,e[n++]=t._surfaceHeight,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._extrudedHeight,e[n++]=+!!t._shadowVolume,e[n]=t._offsetAttribute??-1,e};var X=new h,W=y.clone(y.UNIT_SPHERE),q={rectangle:X,ellipsoid:W,vertexFormat:V,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Y.unpack=function(t,e,n){k.defined("array",t),e=e??0;let o=h.unpack(t,e,X);e+=h.packedLength;let r=y.unpack(t,e,W);e+=y.packedLength;let i=a.unpack(t,e,V);e+=a.packedLength;let s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=t[e++],p=1===t[e++],g=t[e];return E(n)?(n._rectangle=h.clone(o,n._rectangle),n._ellipsoid=y.clone(r,n._ellipsoid),n._vertexFormat=a.clone(i,n._vertexFormat),n._granularity=s,n._surfaceHeight=l,n._rotation=u,n._stRotation=c,n._extrudedHeight=m,n._shadowVolume=p,n._offsetAttribute=-1===g?void 0:g,n):(q.granularity=s,q.height=l,q.rotation=u,q.stRotation=c,q.extrudedHeight=m,q.shadowVolume=p,q.offsetAttribute=-1===g?void 0:g,new Y(q))},Y.computeRectangle=function(t,e){let n=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",n),h._validate(n),n.north<n.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let o=t.granularity??v.RADIANS_PER_DEGREE,a=t.ellipsoid??y.default;return U(n,o,t.rotation??0,a,e)};var J=new w,K=new p,Q=new d;Y.createGeometry=function(s){let l,g;if(v.equalsEpsilon(s._rectangle.north,s._rectangle.south,v.EPSILON10)||v.equalsEpsilon(s._rectangle.east,s._rectangle.west,v.EPSILON10))return;let d=s._rectangle,_=s._ellipsoid,y=s._rotation,A=s._stRotation,x=s._vertexFormat,k=t.computeOptions(d,s._granularity,y,A,N,G,z);if(0!==A||0!==y){let t=h.center(d,Q),e=_.geodeticSurfaceNormalCartographic(t,I);p.fromAxisAngle(e,-A,K),w.fromQuaternion(K,J)}else w.clone(w.IDENTITY,J);let L=s._surfaceHeight,B=s._extrudedHeight,U=!v.equalsEpsilon(L,B,0,v.EPSILON2);if(k.lonScalar=1/s._rectangle.width,k.latScalar=1/s._rectangle.height,k.tangentRotationMatrix=J,d=s._rectangle,U){l=function(t,s){let l=t._shadowVolume,u=t._offsetAttribute,m=t._vertexFormat,p=t._extrudedHeight,h=t._surfaceHeight,g=t._ellipsoid,d=s.height,_=s.width,y;if(l){let e=a.clone(m,V);e.normal=!0,t._vertexFormat=e}let w=S(t,s);l&&(t._vertexFormat=m);let A=r.scaleToGeodeticHeight(w.attributes.position.values,h,g,!1),x=(A=new Float64Array(A)).length,k=2*x,N=new Float64Array(k);N.set(A);let L=r.scaleToGeodeticHeight(w.attributes.position.values,p,g);N.set(L,x),w.attributes.position.values=N;let O=m.normal?new Float32Array(k):void 0,D=m.tangent?new Float32Array(k):void 0,B=m.bitangent?new Float32Array(k):void 0,G=m.st?new Float32Array(k/3*2):void 0,z,U;if(m.normal){for(U=w.attributes.normal.values,O.set(U),y=0;y<x;y++)U[y]=-U[y];O.set(U,x),w.attributes.normal.values=O}if(l){U=w.attributes.normal.values,m.normal||(w.attributes.normal=void 0);let t=new Float32Array(k);for(y=0;y<x;y++)U[y]=-U[y];t.set(U,x),w.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:t})}let Y,X=E(u);if(X){let t=x/3*2,e=new Uint8Array(t);u===o.TOP?e=e.fill(1,0,t/2):(Y=+(u!==o.NONE),e=e.fill(Y)),w.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(m.tangent){let t=w.attributes.tangent.values;for(D.set(t),y=0;y<x;y++)t[y]=-t[y];D.set(t,x),w.attributes.tangent.values=D}if(m.bitangent){let t=w.attributes.bitangent.values;B.set(t),B.set(t,x),w.attributes.bitangent.values=B}m.st&&(z=w.attributes.st.values,G.set(z),G.set(z,x/3*2),w.attributes.st.values=G);let W=w.indices,q=W.length,J=x/3,K=i.createTypedArray(k/3,2*q);for(K.set(W),y=0;y<q;y+=3)K[y+q]=W[y+2]+J,K[y+1+q]=W[y+1]+J,K[y+2+q]=W[y]+J;w.indices=K;let Q=s.northCap,Z=s.southCap,$=d,tt=2,te=0,tn=4,to=4;Q&&(tt-=1,$-=1,te+=1,tn-=2,to-=1),Z&&(tt-=1,$-=1,te+=1,tn-=2,to-=1);let ta=((te+=tt*_+2*$-tn)+to)*2,tr=new Float64Array(3*ta),ti=l?new Float32Array(3*ta):void 0,ts=X?new Uint8Array(ta):void 0,tl=m.st?new Float32Array(2*ta):void 0,tu=u===o.TOP;X&&!tu&&(Y=+(u===o.ALL),ts=ts.fill(Y));let tc=0,tm=0,tp=0,th=0,tg=_*$,tf;for(y=0;y<tg;y+=_)tr=M(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1);if(Z){let t=Q?tg+1:tg;for(tf=3*t,y=0;y<2;y++)tr=M(tr,tc,tf,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*t,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1)}else for(y=tg-_;y<tg;y++)tr=M(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1);for(y=tg-1;y>0;y-=_)tr=M(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1);if(Q)for(tf=3*tg,y=0;y<2;y++)tr=M(tr,tc,tf,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*tg,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1);else for(y=_-1;y>=0;y--)tr=M(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=C(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=U[tf],ti[tp++]=U[tf+1],ti[tp++]=U[tf+2]),tu&&(ts[th++]=1,th+=1);let td=function(t,e,n){let o=t.length,a=e.normal?new Float32Array(o):void 0,r=e.tangent?new Float32Array(o):void 0,i=e.bitangent?new Float32Array(o):void 0,s=0,l=0,u=0,c=!0,m=T,p=R,h=P;if(e.normal||e.tangent||e.bitangent)for(let g=0;g<o;g+=6){let f=b.fromArray(t,g,F),d=b.fromArray(t,(g+6)%o,I);if(c){let e=b.fromArray(t,(g+3)%o,H);b.subtract(d,f,d),b.subtract(e,f,e),h=b.normalize(b.cross(e,d,h),h),c=!1}b.equalsEpsilon(d,f,v.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(f,m),e.tangent&&(p=b.normalize(b.cross(m,h,p),p))),e.normal&&(a[s++]=h.x,a[s++]=h.y,a[s++]=h.z,a[s++]=h.x,a[s++]=h.y,a[s++]=h.z),e.tangent&&(r[l++]=p.x,r[l++]=p.y,r[l++]=p.z,r[l++]=p.x,r[l++]=p.y,r[l++]=p.z),e.bitangent&&(i[u++]=m.x,i[u++]=m.y,i[u++]=m.z,i[u++]=m.x,i[u++]=m.y,i[u++]=m.z)}return j(e,{positions:t,normals:a,tangents:r,bitangents:i})}(tr,m,g);m.st&&(td.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:tl})),l&&(td.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:ti})),X&&(td.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:ts}));let t_=i.createTypedArray(ta,6*te),ty,tb,tw,tA;x=tr.length/3;let tv=0;for(y=0;y<x-1;y+=2){tA=((ty=y)+2)%x;let t=b.fromArray(tr,3*ty,I),e=b.fromArray(tr,3*tA,H);b.equalsEpsilon(t,e,v.EPSILON10)||(tw=((tb=(ty+1)%x)+2)%x,t_[tv++]=ty,t_[tv++]=tb,t_[tv++]=tA,t_[tv++]=tA,t_[tv++]=tb,t_[tv++]=tw)}return td.indices=t_,(td=n.combineInstances([new e({geometry:w}),new e({geometry:td})]))[0]}(s,k);let t=m.fromRectangle3D(d,_,L,D),u=m.fromRectangle3D(d,_,B,O);g=m.union(t,u)}else{if((l=S(s,k)).attributes.position.values=r.scaleToGeodeticHeight(l.attributes.position.values,L,_,!1),E(s._offsetAttribute)){let t=l.attributes.position.values.length,e=+(s._offsetAttribute!==o.NONE),n=new Uint8Array(t/3).fill(e);l.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}g=m.fromRectangle3D(d,_,L)}return x.position||delete l.attributes.position,new u({attributes:l.attributes,indices:l.indices,primitiveType:l.primitiveType,boundingSphere:g,offsetAttribute:s._offsetAttribute})},Y.createShadowVolume=function(t,e,n){let o=t._granularity,r=t._ellipsoid,i=e(o,r),s=n(o,r);return new Y({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:o,extrudedHeight:s,height:i,vertexFormat:a.POSITION_ONLY,shadowVolume:!0})};var Z=new h,$=[new _,new _,new _],tt=new g,te=new d;Object.defineProperties(Y.prototype,{rectangle:{get:function(){return E(this._rotatedRectangle)||(this._rotatedRectangle=U(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return E(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=h.clone(t._rectangle,Z),n=t._granularity,o=t._ellipsoid,a=U(e,n,t._rotation-t._stRotation,o,Z);$[0].x=a.west,$[0].y=a.south,$[1].x=a.west,$[1].y=a.north,$[2].x=a.east,$[2].y=a.south;let r=t.rectangle,i=g.fromRotation(t._stRotation,tt),s=h.center(r,te);for(let t=0;t<3;++t){let e=$[t];e.x-=s.longitude,e.y-=s.latitude,g.multiplyByVector(i,e,e),e.x+=s.longitude,e.y+=s.latitude,e.x=(e.x-r.west)/r.width,e.y=(e.y-r.south)/r.height}let l=$[0],u=$[1],c=$[2],m=Array(6);return _.pack(l,m),_.pack(u,m,2),_.pack(c,m,4),m}(this)),this._textureCoordinateRotationPoints}}});var tn=function(t,e){return E(e)&&(t=Y.unpack(t,e)),t._ellipsoid=y.clone(t._ellipsoid),t._rectangle=h.clone(t._rectangle),Y.createGeometry(t)};export{tn as default};