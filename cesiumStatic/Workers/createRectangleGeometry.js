import{a as t}from"./chunk-4UTHD2VO.js";import{a as e}from"./chunk-3QPLNPJT.js";import{a as n}from"./chunk-UPV7RDUS.js";import"./chunk-NPKIHRIX.js";import"./chunk-MUKCYY2X.js";import{a as o}from"./chunk-MABAS5D2.js";import{a as a}from"./chunk-PXD6ATBI.js";import{b as r}from"./chunk-TN2BIDXM.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as i}from"./chunk-GSMLTRAL.js";import{a as s}from"./chunk-IUX576XK.js";import{b as l,c as u,d as c}from"./chunk-UIGT6VOJ.js";import{c as m}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import{h as p,j as h,k as g}from"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as f}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{a as d,b as _,c as y}from"./chunk-KCR7AORG.js";import{a as b,b as w,c as A}from"./chunk-QDJTHWTA.js";import{a as v}from"./chunk-2YWR3G22.js";import{a as x,b as k}from"./chunk-HTSQLHXI.js";import{e as P}from"./chunk-JDAHMWM5.js";var E=new b,R=new b,F=new b,T=new b,O=new h,L=new _,N=new m,D=new m;function j(t,e){let n=new u({attributes:new s,primitiveType:l.TRIANGLES});return n.attributes.position=new c({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}var I=new b,H=new b;function M(e,n){let o=e._vertexFormat,a=e._ellipsoid,r=n.height,s=n.width,l=n.northCap,u=n.southCap,m=0,p=r,h=r,g=0;l&&(m=1,h-=1,g+=1),u&&(p-=1,h-=1,g+=1),g+=s*h;let d=o.position?new Float64Array(3*g):void 0,_=o.st?new Float32Array(2*g):void 0,y=0,A=0,v=Number.MAX_VALUE,x=Number.MAX_VALUE,k=-Number.MAX_VALUE,P=-Number.MAX_VALUE;for(let e=m;e<p;++e)for(let r=0;r<s;++r)t.computePosition(n,a,o.st,e,r,E,L),d[y++]=E.x,d[y++]=E.y,d[y++]=E.z,o.st&&(_[A++]=L.x,_[A++]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),P=Math.max(P,L.y));if(l&&(t.computePosition(n,a,o.st,0,0,E,L),d[y++]=E.x,d[y++]=E.y,d[y++]=E.z,o.st&&(_[A++]=L.x,_[A++]=L.y,v=L.x,x=L.y,k=L.x,P=L.y)),u&&(t.computePosition(n,a,o.st,r-1,0,E,L),d[y++]=E.x,d[y++]=E.y,d[y]=E.z,o.st&&(_[A++]=L.x,_[A]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),P=Math.max(P,L.y))),o.st&&(v<0||x<0||k>1||P>1))for(let t=0;t<_.length;t+=2)_[t]=(_[t]-v)/(k-v),_[t+1]=(_[t+1]-x)/(P-x);let O=function(t,e,n,o){let a=t.length,r=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0,l=0,u=R;if(e.normal||e.tangent||e.bitangent)for(let c=0;c<a;c+=3){let a=b.fromArray(t,c,E),m=l+1,p=l+2;u=n.geodeticSurfaceNormal(a,u),(e.tangent||e.bitangent)&&(b.cross(b.UNIT_Z,u,F),w.multiplyByVector(o,F,F),b.normalize(F,F),e.bitangent&&b.normalize(b.cross(u,F,T),T)),e.normal&&(r[l]=u.x,r[m]=u.y,r[p]=u.z),e.tangent&&(i[l]=F.x,i[m]=F.y,i[p]=F.z),e.bitangent&&(s[l]=T.x,s[m]=T.y,s[p]=T.z),l+=3}return j(e,{positions:t,normals:r,tangents:i,bitangents:s})}(d,o,a,n.tangentRotationMatrix),N=6*(s-1)*(h-1);l&&(N+=3*(s-1)),u&&(N+=3*(s-1));let D=i.createTypedArray(g,N),I=0,H=0,M;for(M=0;M<h-1;++M){for(let t=0;t<s-1;++t){let t=I,e=t+s,n=e+1,o=t+1;D[H++]=t,D[H++]=e,D[H++]=o,D[H++]=o,D[H++]=e,D[H++]=n,++I}++I}if(l||u){let t,e,n=g-1,o=g-1;if(l&&u&&(n=g-2),I=0,l)for(M=0;M<s-1;M++)e=(t=I)+1,D[H++]=n,D[H++]=t,D[H++]=e,++I;if(u)for(I=(h-1)*s,M=0;M<s-1;M++)e=(t=I)+1,D[H++]=t,D[H++]=o,D[H++]=e,++I}return O.indices=D,o.st&&(O.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:_})),O}function S(t,e,n,o,a){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n+2],t[e++]=a[n],t[e++]=a[n+1],t[e]=a[n+2],t}function G(t,e,n,o){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n],t[e]=o[n+1],t}var U=new a,V=[new b,new b,new b,new b],C=new d,z=new d;function B(e,n,o,a,r){if(0===o)return h.clone(e,r);let i=t.computeOptions(e,n,o,0,O,C),s=i.height,l=i.width;return t.computePosition(i,a,!1,0,0,V[0]),t.computePosition(i,a,!1,0,l-1,V[1]),t.computePosition(i,a,!1,s-1,0,V[2]),t.computePosition(i,a,!1,s-1,l-1,V[3]),h.fromCartesianArray(V,a,r)}function X(t){let e=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",e),h._validate(e),e.north<e.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let n=t.height??0,o=t.extrudedHeight??n;this._rectangle=h.clone(e),this._granularity=t.granularity??v.RADIANS_PER_DEGREE,this._ellipsoid=y.clone(t.ellipsoid??y.default),this._surfaceHeight=Math.max(n,o),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._vertexFormat=a.clone(t.vertexFormat??a.DEFAULT),this._extrudedHeight=Math.min(n,o),this._shadowVolume=t.shadowVolume??!1,this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}X.packedLength=h.packedLength+y.packedLength+a.packedLength+7,X.pack=function(t,e,n){return k.typeOf.object("value",t),k.defined("array",e),n=n??0,h.pack(t._rectangle,e,n),n+=h.packedLength,y.pack(t._ellipsoid,e,n),n+=y.packedLength,a.pack(t._vertexFormat,e,n),n+=a.packedLength,e[n++]=t._granularity,e[n++]=t._surfaceHeight,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._extrudedHeight,e[n++]=+!!t._shadowVolume,e[n]=t._offsetAttribute??-1,e};var Y=new h,K=y.clone(y.UNIT_SPHERE),J={rectangle:Y,ellipsoid:K,vertexFormat:U,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};X.unpack=function(t,e,n){k.defined("array",t),e=e??0;let o=h.unpack(t,e,Y);e+=h.packedLength;let r=y.unpack(t,e,K);e+=y.packedLength;let i=a.unpack(t,e,U);e+=a.packedLength;let s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=t[e++],p=1===t[e++],g=t[e];return P(n)?(n._rectangle=h.clone(o,n._rectangle),n._ellipsoid=y.clone(r,n._ellipsoid),n._vertexFormat=a.clone(i,n._vertexFormat),n._granularity=s,n._surfaceHeight=l,n._rotation=u,n._stRotation=c,n._extrudedHeight=m,n._shadowVolume=p,n._offsetAttribute=-1===g?void 0:g,n):(J.granularity=s,J.height=l,J.rotation=u,J.stRotation=c,J.extrudedHeight=m,J.shadowVolume=p,J.offsetAttribute=-1===g?void 0:g,new X(J))},X.computeRectangle=function(t,e){let n=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",n),h._validate(n),n.north<n.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let o=t.granularity??v.RADIANS_PER_DEGREE,a=t.ellipsoid??y.default;return B(n,o,t.rotation??0,a,e)};var Q=new w,q=new p,W=new d;X.createGeometry=function(s){let l,g;if(v.equalsEpsilon(s._rectangle.north,s._rectangle.south,v.EPSILON10)||v.equalsEpsilon(s._rectangle.east,s._rectangle.west,v.EPSILON10))return;let d=s._rectangle,_=s._ellipsoid,y=s._rotation,A=s._stRotation,x=s._vertexFormat,k=t.computeOptions(d,s._granularity,y,A,O,C,z);if(0!==A||0!==y){let t=h.center(d,W),e=_.geodeticSurfaceNormalCartographic(t,I);p.fromAxisAngle(e,-A,q),w.fromQuaternion(q,Q)}else w.clone(w.IDENTITY,Q);let L=s._surfaceHeight,V=s._extrudedHeight,B=!v.equalsEpsilon(L,V,0,v.EPSILON2);if(k.lonScalar=1/s._rectangle.width,k.latScalar=1/s._rectangle.height,k.tangentRotationMatrix=Q,d=s._rectangle,B){l=function(t,s){let l=t._shadowVolume,u=t._offsetAttribute,m=t._vertexFormat,p=t._extrudedHeight,h=t._surfaceHeight,g=t._ellipsoid,d=s.height,_=s.width,y;if(l){let e=a.clone(m,U);e.normal=!0,t._vertexFormat=e}let w=M(t,s);l&&(t._vertexFormat=m);let A=r.scaleToGeodeticHeight(w.attributes.position.values,h,g,!1),x=(A=new Float64Array(A)).length,k=2*x,O=new Float64Array(k);O.set(A);let L=r.scaleToGeodeticHeight(w.attributes.position.values,p,g);O.set(L,x),w.attributes.position.values=O;let N=m.normal?new Float32Array(k):void 0,D=m.tangent?new Float32Array(k):void 0,V=m.bitangent?new Float32Array(k):void 0,C=m.st?new Float32Array(k/3*2):void 0,z,B;if(m.normal){for(B=w.attributes.normal.values,N.set(B),y=0;y<x;y++)B[y]=-B[y];N.set(B,x),w.attributes.normal.values=N}if(l){B=w.attributes.normal.values,m.normal||(w.attributes.normal=void 0);let t=new Float32Array(k);for(y=0;y<x;y++)B[y]=-B[y];t.set(B,x),w.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:t})}let X,Y=P(u);if(Y){let t=x/3*2,e=new Uint8Array(t);u===o.TOP?e=e.fill(1,0,t/2):(X=+(u!==o.NONE),e=e.fill(X)),w.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(m.tangent){let t=w.attributes.tangent.values;for(D.set(t),y=0;y<x;y++)t[y]=-t[y];D.set(t,x),w.attributes.tangent.values=D}if(m.bitangent){let t=w.attributes.bitangent.values;V.set(t),V.set(t,x),w.attributes.bitangent.values=V}m.st&&(z=w.attributes.st.values,C.set(z),C.set(z,x/3*2),w.attributes.st.values=C);let K=w.indices,J=K.length,Q=x/3,q=i.createTypedArray(k/3,2*J);for(q.set(K),y=0;y<J;y+=3)q[y+J]=K[y+2]+Q,q[y+1+J]=K[y+1]+Q,q[y+2+J]=K[y]+Q;w.indices=q;let W=s.northCap,Z=s.southCap,$=d,tt=2,te=0,tn=4,to=4;W&&(tt-=1,$-=1,te+=1,tn-=2,to-=1),Z&&(tt-=1,$-=1,te+=1,tn-=2,to-=1);let ta=((te+=tt*_+2*$-tn)+to)*2,tr=new Float64Array(3*ta),ti=l?new Float32Array(3*ta):void 0,ts=Y?new Uint8Array(ta):void 0,tl=m.st?new Float32Array(2*ta):void 0,tu=u===o.TOP;Y&&!tu&&(X=+(u===o.ALL),ts=ts.fill(X));let tc=0,tm=0,tp=0,th=0,tg=_*$,tf;for(y=0;y<tg;y+=_)tr=S(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(Z){let t=W?tg+1:tg;for(tf=3*t,y=0;y<2;y++)tr=S(tr,tc,tf,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*t,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1)}else for(y=tg-_;y<tg;y++)tr=S(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);for(y=tg-1;y>0;y-=_)tr=S(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(W)for(tf=3*tg,y=0;y<2;y++)tr=S(tr,tc,tf,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*tg,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);else for(y=_-1;y>=0;y--)tr=S(tr,tc,tf=3*y,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*y,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);let td=function(t,e,n){let o=t.length,a=e.normal?new Float32Array(o):void 0,r=e.tangent?new Float32Array(o):void 0,i=e.bitangent?new Float32Array(o):void 0,s=0,l=0,u=0,c=!0,m=T,p=F,h=R;if(e.normal||e.tangent||e.bitangent)for(let g=0;g<o;g+=6){let f=b.fromArray(t,g,E),d=b.fromArray(t,(g+6)%o,I);if(c){let e=b.fromArray(t,(g+3)%o,H);b.subtract(d,f,d),b.subtract(e,f,e),h=b.normalize(b.cross(e,d,h),h),c=!1}b.equalsEpsilon(d,f,v.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(f,m),e.tangent&&(p=b.normalize(b.cross(m,h,p),p))),e.normal&&(a[s++]=h.x,a[s++]=h.y,a[s++]=h.z,a[s++]=h.x,a[s++]=h.y,a[s++]=h.z),e.tangent&&(r[l++]=p.x,r[l++]=p.y,r[l++]=p.z,r[l++]=p.x,r[l++]=p.y,r[l++]=p.z),e.bitangent&&(i[u++]=m.x,i[u++]=m.y,i[u++]=m.z,i[u++]=m.x,i[u++]=m.y,i[u++]=m.z)}return j(e,{positions:t,normals:a,tangents:r,bitangents:i})}(tr,m,g);m.st&&(td.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:tl})),l&&(td.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:ti})),Y&&(td.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:ts}));let t_=i.createTypedArray(ta,6*te),ty,tb,tw,tA;x=tr.length/3;let tv=0;for(y=0;y<x-1;y+=2){tA=((ty=y)+2)%x;let t=b.fromArray(tr,3*ty,I),e=b.fromArray(tr,3*tA,H);b.equalsEpsilon(t,e,v.EPSILON10)||(tw=((tb=(ty+1)%x)+2)%x,t_[tv++]=ty,t_[tv++]=tb,t_[tv++]=tA,t_[tv++]=tA,t_[tv++]=tb,t_[tv++]=tw)}return td.indices=t_,(td=n.combineInstances([new e({geometry:w}),new e({geometry:td})]))[0]}(s,k);let t=m.fromRectangle3D(d,_,L,D),u=m.fromRectangle3D(d,_,V,N);g=m.union(t,u)}else{if((l=M(s,k)).attributes.position.values=r.scaleToGeodeticHeight(l.attributes.position.values,L,_,!1),P(s._offsetAttribute)){let t=l.attributes.position.values.length,e=+(s._offsetAttribute!==o.NONE),n=new Uint8Array(t/3).fill(e);l.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}g=m.fromRectangle3D(d,_,L)}return x.position||delete l.attributes.position,new u({attributes:l.attributes,indices:l.indices,primitiveType:l.primitiveType,boundingSphere:g,offsetAttribute:s._offsetAttribute})},X.createShadowVolume=function(t,e,n){let o=t._granularity,r=t._ellipsoid,i=e(o,r),s=n(o,r);return new X({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:o,extrudedHeight:s,height:i,vertexFormat:a.POSITION_ONLY,shadowVolume:!0})};var Z=new h,$=[new _,new _,new _],tt=new g,te=new d;Object.defineProperties(X.prototype,{rectangle:{get:function(){return P(this._rotatedRectangle)||(this._rotatedRectangle=B(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return P(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=h.clone(t._rectangle,Z),n=t._granularity,o=t._ellipsoid,a=B(e,n,t._rotation-t._stRotation,o,Z);$[0].x=a.west,$[0].y=a.south,$[1].x=a.west,$[1].y=a.north,$[2].x=a.east,$[2].y=a.south;let r=t.rectangle,i=g.fromRotation(t._stRotation,tt),s=h.center(r,te);for(let t=0;t<3;++t){let e=$[t];e.x-=s.longitude,e.y-=s.latitude,g.multiplyByVector(i,e,e),e.x+=s.longitude,e.y+=s.latitude,e.x=(e.x-r.west)/r.width,e.y=(e.y-r.south)/r.height}let l=$[0],u=$[1],c=$[2],m=Array(6);return _.pack(l,m),_.pack(u,m,2),_.pack(c,m,4),m}(this)),this._textureCoordinateRotationPoints}}});var tn=function(t,e){return P(e)&&(t=X.unpack(t,e)),t._ellipsoid=y.clone(t._ellipsoid),t._rectangle=h.clone(t._rectangle),X.createGeometry(t)};export{tn as default};