import{a as e}from"./chunk-U27UHDI4.js";import{a as t}from"./chunk-MCM3P7ZC.js";import{a as o}from"./chunk-2A2JFXXO.js";import"./chunk-TULFNR3P.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as r}from"./chunk-GSMLTRAL.js";import{a as a}from"./chunk-IUX576XK.js";import{b as n,c as i,d as l}from"./chunk-UIGT6VOJ.js";import{c as s}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as c}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{c as p}from"./chunk-KCR7AORG.js";import{a as h,c as u}from"./chunk-QDJTHWTA.js";import{a as f}from"./chunk-2YWR3G22.js";import{a as m}from"./chunk-HTSQLHXI.js";import{e as y}from"./chunk-JDAHMWM5.js";function g(o){let r=(o=o??u.EMPTY_OBJECT).positions,a=o.colors,n=o.colorsPerVertex??!1;if(!y(r)||r.length<2)throw new m("At least two positions are required.");if(y(a)&&(n&&a.length<r.length||!n&&a.length<r.length-1))throw new m("colors has an invalid length.");this._positions=r,this._colors=a,this._colorsPerVertex=n,this._arcType=o.arcType??t.GEODESIC,this._granularity=o.granularity??f.RADIANS_PER_DEGREE,this._ellipsoid=o.ellipsoid??p.default,this._workerName="createSimplePolylineGeometry";let i=1+r.length*h.packedLength;i+=y(a)?1+a.length*e.packedLength:1,this.packedLength=i+p.packedLength+3}g.pack=function(t,o,r){if(!y(t))throw new m("value is required");if(!y(o))throw new m("array is required");r=r??0;let a,n=t._positions,i=n.length;for(o[r++]=i,a=0;a<i;++a,r+=h.packedLength)h.pack(n[a],o,r);let l=t._colors;for(i=y(l)?l.length:0,o[r++]=i,a=0;a<i;++a,r+=e.packedLength)e.pack(l[a],o,r);return p.pack(t._ellipsoid,o,r),r+=p.packedLength,o[r++]=+!!t._colorsPerVertex,o[r++]=t._arcType,o[r]=t._granularity,o},g.unpack=function(t,o,r){if(!y(t))throw new m("array is required");o=o??0;let a,n=t[o++],i=Array(n);for(a=0;a<n;++a,o+=h.packedLength)i[a]=h.unpack(t,o);let l=(n=t[o++])>0?Array(n):void 0;for(a=0;a<n;++a,o+=e.packedLength)l[a]=e.unpack(t,o);let s=p.unpack(t,o);o+=p.packedLength;let c=1===t[o++],u=t[o++],f=t[o];return y(r)?(r._positions=i,r._colors=l,r._ellipsoid=s,r._colorsPerVertex=c,r._arcType=u,r._granularity=f,r):new g({positions:i,colors:l,ellipsoid:s,colorsPerVertex:c,arcType:u,granularity:f})};var d=[,,],k=[,,],T={positions:d,height:k,ellipsoid:void 0,minDistance:void 0,granularity:void 0};g.createGeometry=function(p){let u=p._positions,m=p._colors,g=p._colorsPerVertex,_=p._arcType,B=p._granularity,w=p._ellipsoid,E=f.chordLength(B,w.maximumRadius),j=y(m)&&!g,P,A=u.length,L,b,G,I,O=0;if(_===t.GEODESIC||_===t.RHUMB){let r,a,n;_===t.GEODESIC?(r=f.chordLength(B,w.maximumRadius),a=o.numberOfPoints,n=o.generateArc):(r=B,a=o.numberOfPointsRhumbLine,n=o.generateRhumbArc);let i=o.extractHeights(u,w);if(_===t.GEODESIC?T.minDistance=E:T.granularity=B,T.ellipsoid=w,j){let t=0;for(P=0;P<A-1;P++)t+=a(u[P],u[P+1],r)+1;L=new Float64Array(3*t),G=new Uint8Array(4*t),T.positions=d,T.height=k;let o=0;for(P=0;P<A-1;++P){d[0]=u[P],d[1]=u[P+1],k[0]=i[P],k[1]=i[P+1];let t=n(T);if(y(m)){let r=t.length/3;I=m[P];for(let t=0;t<r;++t)G[o++]=e.floatToByte(I.red),G[o++]=e.floatToByte(I.green),G[o++]=e.floatToByte(I.blue),G[o++]=e.floatToByte(I.alpha)}L.set(t,O),O+=t.length}}else if(T.positions=u,T.height=i,L=new Float64Array(n(T)),y(m)){for(G=new Uint8Array(L.length/3*4),P=0;P<A-1;++P)O=function(t,r,a,n,i,l,s){let c=o.numberOfPoints(t,r,i),p,h=a.red,u=a.green,f=a.blue,m=a.alpha,y=n.red,g=n.green,d=n.blue,k=n.alpha;if(e.equals(a,n)){for(p=0;p<c;p++)l[s++]=e.floatToByte(h),l[s++]=e.floatToByte(u),l[s++]=e.floatToByte(f),l[s++]=e.floatToByte(m);return s}let T=(y-h)/c,_=(g-u)/c,B=(d-f)/c,w=(k-m)/c,E=s;for(p=0;p<c;p++)l[E++]=e.floatToByte(h+p*T),l[E++]=e.floatToByte(u+p*_),l[E++]=e.floatToByte(f+p*B),l[E++]=e.floatToByte(m+p*w);return E}(u[P],u[P+1],m[P],m[P+1],E,G,O);let t=m[A-1];G[O++]=e.floatToByte(t.red),G[O++]=e.floatToByte(t.green),G[O++]=e.floatToByte(t.blue),G[O++]=e.floatToByte(t.alpha)}}else{L=new Float64Array(3*(b=j?2*A-2:A)),G=y(m)?new Uint8Array(4*b):void 0;let t=0,o=0;for(P=0;P<A;++P){let r=u[P];if(j&&P>0&&(h.pack(r,L,t),t+=3,I=m[P-1],G[o++]=e.floatToByte(I.red),G[o++]=e.floatToByte(I.green),G[o++]=e.floatToByte(I.blue),G[o++]=e.floatToByte(I.alpha)),j&&P===A-1)break;h.pack(r,L,t),t+=3,y(m)&&(I=m[P],G[o++]=e.floatToByte(I.red),G[o++]=e.floatToByte(I.green),G[o++]=e.floatToByte(I.blue),G[o++]=e.floatToByte(I.alpha))}}let D=new a;D.position=new l({componentDatatype:c.DOUBLE,componentsPerAttribute:3,values:L}),y(m)&&(D.color=new l({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:4,values:G,normalize:!0}));let R=((b=L.length/3)-1)*2,S=r.createTypedArray(b,R),v=0;for(P=0;P<b-1;++P)S[v++]=P,S[v++]=P+1;return new i({attributes:D,indices:S,primitiveType:n.LINES,boundingSphere:s.fromPoints(u)})};var _=function(e,t){return y(t)&&(e=g.unpack(e,t)),e._ellipsoid=p.clone(e._ellipsoid),g.createGeometry(e)};export{_ as default};