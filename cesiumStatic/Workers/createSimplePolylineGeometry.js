import{a as e}from"./chunk-MHP75ZQC.js";import{a as t}from"./chunk-XQCNGPKC.js";import{a as o}from"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as r}from"./chunk-KSX6TRAS.js";import{a as a}from"./chunk-GMTHOMGW.js";import{b as n,c as i,d as l}from"./chunk-BELR52CD.js";import{c as s}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as c}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{c as p}from"./chunk-ICY67TC6.js";import{a as h,c as u}from"./chunk-G2EMNOST.js";import{a as f}from"./chunk-4VFKVGYI.js";import{a as m}from"./chunk-3WJNS2B6.js";import{e as y}from"./chunk-XCN226AA.js";function g(o){let r=(o=o??u.EMPTY_OBJECT).positions,a=o.colors,n=o.colorsPerVertex??!1;if(!y(r)||r.length<2)throw new m("At least two positions are required.");if(y(a)&&(n&&a.length<r.length||!n&&a.length<r.length-1))throw new m("colors has an invalid length.");this._positions=r,this._colors=a,this._colorsPerVertex=n,this._arcType=o.arcType??t.GEODESIC,this._granularity=o.granularity??f.RADIANS_PER_DEGREE,this._ellipsoid=o.ellipsoid??p.default,this._workerName="createSimplePolylineGeometry";let i=1+r.length*h.packedLength;i+=y(a)?1+a.length*e.packedLength:1,this.packedLength=i+p.packedLength+3}g.pack=function(t,o,r){if(!y(t))throw new m("value is required");if(!y(o))throw new m("array is required");r=r??0;let a,n=t._positions,i=n.length;for(o[r++]=i,a=0;a<i;++a,r+=h.packedLength)h.pack(n[a],o,r);let l=t._colors;for(i=y(l)?l.length:0,o[r++]=i,a=0;a<i;++a,r+=e.packedLength)e.pack(l[a],o,r);return p.pack(t._ellipsoid,o,r),r+=p.packedLength,o[r++]=+!!t._colorsPerVertex,o[r++]=t._arcType,o[r]=t._granularity,o},g.unpack=function(t,o,r){if(!y(t))throw new m("array is required");o=o??0;let a,n=t[o++],i=Array(n);for(a=0;a<n;++a,o+=h.packedLength)i[a]=h.unpack(t,o);let l=(n=t[o++])>0?Array(n):void 0;for(a=0;a<n;++a,o+=e.packedLength)l[a]=e.unpack(t,o);let s=p.unpack(t,o);o+=p.packedLength;let c=1===t[o++],u=t[o++],f=t[o];return y(r)?(r._positions=i,r._colors=l,r._ellipsoid=s,r._colorsPerVertex=c,r._arcType=u,r._granularity=f,r):new g({positions:i,colors:l,ellipsoid:s,colorsPerVertex:c,arcType:u,granularity:f})};var d=[,,],k=[,,],T={positions:d,height:k,ellipsoid:void 0,minDistance:void 0,granularity:void 0};g.createGeometry=function(p){let u=p._positions,m=p._colors,g=p._colorsPerVertex,B=p._arcType,_=p._granularity,w=p._ellipsoid,j=f.chordLength(_,w.maximumRadius),E=y(m)&&!g,A,L=u.length,P,b,C,D,S=0;if(B===t.GEODESIC||B===t.RHUMB){let r,a,n;B===t.GEODESIC?(r=f.chordLength(_,w.maximumRadius),a=o.numberOfPoints,n=o.generateArc):(r=_,a=o.numberOfPointsRhumbLine,n=o.generateRhumbArc);let i=o.extractHeights(u,w);if(B===t.GEODESIC?T.minDistance=j:T.granularity=_,T.ellipsoid=w,E){let t=0;for(A=0;A<L-1;A++)t+=a(u[A],u[A+1],r)+1;P=new Float64Array(3*t),C=new Uint8Array(4*t),T.positions=d,T.height=k;let o=0;for(A=0;A<L-1;++A){d[0]=u[A],d[1]=u[A+1],k[0]=i[A],k[1]=i[A+1];let t=n(T);if(y(m)){let r=t.length/3;D=m[A];for(let t=0;t<r;++t)C[o++]=e.floatToByte(D.red),C[o++]=e.floatToByte(D.green),C[o++]=e.floatToByte(D.blue),C[o++]=e.floatToByte(D.alpha)}P.set(t,S),S+=t.length}}else if(T.positions=u,T.height=i,P=new Float64Array(n(T)),y(m)){for(C=new Uint8Array(P.length/3*4),A=0;A<L-1;++A)S=function(t,r,a,n,i,l,s){let c=o.numberOfPoints(t,r,i),p,h=a.red,u=a.green,f=a.blue,m=a.alpha,y=n.red,g=n.green,d=n.blue,k=n.alpha;if(e.equals(a,n)){for(p=0;p<c;p++)l[s++]=e.floatToByte(h),l[s++]=e.floatToByte(u),l[s++]=e.floatToByte(f),l[s++]=e.floatToByte(m);return s}let T=(y-h)/c,B=(g-u)/c,_=(d-f)/c,w=(k-m)/c,j=s;for(p=0;p<c;p++)l[j++]=e.floatToByte(h+p*T),l[j++]=e.floatToByte(u+p*B),l[j++]=e.floatToByte(f+p*_),l[j++]=e.floatToByte(m+p*w);return j}(u[A],u[A+1],m[A],m[A+1],j,C,S);let t=m[L-1];C[S++]=e.floatToByte(t.red),C[S++]=e.floatToByte(t.green),C[S++]=e.floatToByte(t.blue),C[S++]=e.floatToByte(t.alpha)}}else{P=new Float64Array(3*(b=E?2*L-2:L)),C=y(m)?new Uint8Array(4*b):void 0;let t=0,o=0;for(A=0;A<L;++A){let r=u[A];if(E&&A>0&&(h.pack(r,P,t),t+=3,D=m[A-1],C[o++]=e.floatToByte(D.red),C[o++]=e.floatToByte(D.green),C[o++]=e.floatToByte(D.blue),C[o++]=e.floatToByte(D.alpha)),E&&A===L-1)break;h.pack(r,P,t),t+=3,y(m)&&(D=m[A],C[o++]=e.floatToByte(D.red),C[o++]=e.floatToByte(D.green),C[o++]=e.floatToByte(D.blue),C[o++]=e.floatToByte(D.alpha))}}let G=new a;G.position=new l({componentDatatype:c.DOUBLE,componentsPerAttribute:3,values:P}),y(m)&&(G.color=new l({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:4,values:C,normalize:!0}));let N=((b=P.length/3)-1)*2,I=r.createTypedArray(b,N),O=0;for(A=0;A<b-1;++A)I[O++]=A,I[O++]=A+1;return new i({attributes:G,indices:I,primitiveType:n.LINES,boundingSphere:s.fromPoints(u)})};var B=function(e,t){return y(t)&&(e=g.unpack(e,t)),e._ellipsoid=p.clone(e._ellipsoid),g.createGeometry(e)};export{B as default};