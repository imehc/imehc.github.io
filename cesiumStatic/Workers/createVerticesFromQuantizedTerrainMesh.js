import{a as t}from"./chunk-YMJY54J4.js";import{a as e,c as i}from"./chunk-OUPSOZ4F.js";import{a as n}from"./chunk-ILB4KG4E.js";import{a as r}from"./chunk-VJHOZLST.js";import"./chunk-NPKIHRIX.js";import{a as o}from"./chunk-X2JOWFTB.js";import{a as a}from"./chunk-GSMLTRAL.js";import"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import{i as s,j as c}from"./chunk-IB27QQGF.js";import{b as h}from"./chunk-RGFEE67W.js";import"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{a as u,b as l,c as m}from"./chunk-KCR7AORG.js";import{a as d}from"./chunk-QDJTHWTA.js";import{a as g}from"./chunk-2YWR3G22.js";import"./chunk-HTSQLHXI.js";import{e as p}from"./chunk-JDAHMWM5.js";var f=new d,y=new d,I=new d,k=new u,T=new l;function S(t,e,i,n,r,o,a,s,c){let u=1/0,l=r.north,m=r.south,p=r.east,y=r.west;p<y&&(p+=g.TWO_PI);let I=t.length;for(let r=0;r<I;++r){let I=t[r],T=i[I],S=n[I];k.longitude=g.lerp(y,p,S.x),k.latitude=g.lerp(m,l,S.y),k.height=T-e;let x=o.cartographicToCartesian(k,f);h.multiplyByPoint(a,x,x),d.minimumByComponent(x,s,s),d.maximumByComponent(x,c,c),u=Math.min(u,k.height)}return u}function x(t,e,i,n,o,a,s,c,h,u,l,m,d,y){let I=p(s),S=h.north,x=h.south,w=h.east,M=h.west;w<M&&(w+=g.TWO_PI);let j=i.length;for(let h=0;h<j;++h){let p,j,H=i[h],A=o[H],C=a[H];k.longitude=g.lerp(M,w,C.x)+d,k.latitude=g.lerp(x,S,C.y)+y,k.height=A-u;let P=c.cartographicToCartesian(k,f);if(I){let t=2*H;T.x=s[t],T.y=s[t+1]}n.hasWebMercatorT&&(p=(r.geodeticLatitudeToMercatorAngle(k.latitude)-l)*m),n.hasGeodeticSurfaceNormals&&(j=c.geodeticSurfaceNormal(P)),e=n.encode(t,e,P,C,k.height,T,p,j)}}function w(t,e){let i;return"function"==typeof t.slice&&"function"!=typeof(i=t.slice()).sort&&(i=void 0),p(i)||(i=Array.prototype.slice.call(t)),i.sort(e),i}var M=n(function(n,u){let M=n.quantizedVertices,j=M.length/3,H=n.octEncodedNormals,A=n.westIndices.length+n.eastIndices.length+n.southIndices.length+n.northIndices.length,C=n.includeWebMercatorT,P=n.exaggeration,b=n.exaggerationRelativeHeight,W=1!==P,O=c.clone(n.rectangle),N=O.west,B=O.south,L=O.east,v=O.north,E=m.clone(n.ellipsoid),F=n.minimumHeight,G=n.maximumHeight,J=n.relativeToCenter,R=s.eastNorthUpToFixedFrame(J,E),K=h.inverseTransformation(R,new h),Q,X;C&&(Q=r.geodeticLatitudeToMercatorAngle(B),X=1/(r.geodeticLatitudeToMercatorAngle(v)-Q));let Y=M.subarray(0,j),Z=M.subarray(j,2*j),z=M.subarray(2*j,3*j),U=p(H),V=Array(j),D=Array(j),_=Array(j),q=C?Array(j):[],$=W?Array(j):[];y.x=1/0,y.y=1/0,y.z=1/0,I.x=-1/0,I.y=-1/0,I.z=-1/0;let tt=1/0,te=-1/0,ti=1/0,tn=-1/0;for(let t=0;t<j;++t){let e=Y[t],i=Z[t],n=e/32767,o=i/32767,a=g.lerp(F,G,z[t]/32767);k.longitude=g.lerp(N,L,n),k.latitude=g.lerp(B,v,o),k.height=a,tt=Math.min(k.longitude,tt),te=Math.max(k.longitude,te),ti=Math.min(k.latitude,ti),tn=Math.max(k.latitude,tn);let s=E.cartographicToCartesian(k);V[t]=new l(n,o),D[t]=a,_[t]=s,C&&(q[t]=(r.geodeticLatitudeToMercatorAngle(k.latitude)-Q)*X),W&&($[t]=E.geodeticSurfaceNormal(s)),h.multiplyByPoint(K,s,f),d.minimumByComponent(f,y,y),d.maximumByComponent(f,I,I)}let tr=w(n.westIndices,function(t,e){return V[t].y-V[e].y}),to=w(n.eastIndices,function(t,e){return V[e].y-V[t].y}),ta=w(n.southIndices,function(t,e){return V[e].x-V[t].x}),ts=w(n.northIndices,function(t,e){return V[t].x-V[e].x}),tc;F<0&&(tc=new e(E).computeHorizonCullingPointPossiblyUnderEllipsoid(J,_,F));let th=F;th=Math.min(th=Math.min(th=Math.min(th=Math.min(th,S(n.westIndices,n.westSkirtHeight,D,V,O,E,K,y,I)),S(n.southIndices,n.southSkirtHeight,D,V,O,E,K,y,I)),S(n.eastIndices,n.eastSkirtHeight,D,V,O,E,K,y,I)),S(n.northIndices,n.northSkirtHeight,D,V,O,E,K,y,I));let tu=new o(y,I,J),tl=new i(J,tu,th,G,R,U,C,W,P,b),tm=tl.stride,td=new Float32Array(j*tm+A*tm),tg=0;for(let t=0;t<j;++t){if(U){let e=2*t;T.x=H[e],T.y=H[e+1]}tg=tl.encode(td,tg,_[t],V[t],D[t],T,q[t],$[t])}let tp=Math.max(0,(A-4)*2),tf=n.indices.length+3*tp,ty=a.createTypedArray(j+A,tf);ty.set(n.indices,0);let tI=(te-tt)*1e-4,tk=(tn-ti)*1e-4,tT=j*tm;return x(td,tT,tr,tl,D,V,H,E,O,n.westSkirtHeight,Q,X,-tI,0),x(td,tT+=n.westIndices.length*tm,ta,tl,D,V,H,E,O,n.southSkirtHeight,Q,X,0,-tk),x(td,tT+=n.southIndices.length*tm,to,tl,D,V,H,E,O,n.eastSkirtHeight,Q,X,tI,0),x(td,tT+=n.eastIndices.length*tm,ts,tl,D,V,H,E,O,n.northSkirtHeight,Q,X,0,tk),t.addSkirtIndices(tr,ta,to,ts,j,ty,n.indices.length),u.push(td.buffer,ty.buffer),{vertices:td.buffer,indices:ty.buffer,westIndicesSouthToNorth:tr,southIndicesEastToWest:ta,eastIndicesNorthToSouth:to,northIndicesWestToEast:ts,vertexStride:tm,center:J,minimumHeight:F,maximumHeight:G,occludeePointInScaledSpace:tc,encoding:tl,indexCountWithoutSkirts:n.indices.length}});export{M as default};