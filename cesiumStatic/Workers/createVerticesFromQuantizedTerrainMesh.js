import{a as t}from"./chunk-XGRCBY5T.js";import{a as e,c as i}from"./chunk-33IJ66H2.js";import{a as n}from"./chunk-ITDFUUP5.js";import{a as r}from"./chunk-VSMOUEKV.js";import"./chunk-DAX2P4DI.js";import{a as o}from"./chunk-QM7HI6IF.js";import{a as a}from"./chunk-KSX6TRAS.js";import"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import{i as s,j as c}from"./chunk-4NDD6KRQ.js";import{b as h}from"./chunk-5ELDAYCN.js";import"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{a as u,b as l,c as m}from"./chunk-ICY67TC6.js";import{a as d}from"./chunk-G2EMNOST.js";import{a as g}from"./chunk-4VFKVGYI.js";import"./chunk-3WJNS2B6.js";import{e as p}from"./chunk-XCN226AA.js";var f=new d,y=new d,I=new d,k=new u,T=new l;function S(t,e,i,n,r,o,a,s,c){let u=1/0,l=r.north,m=r.south,p=r.east,y=r.west;p<y&&(p+=g.TWO_PI);let I=t.length;for(let r=0;r<I;++r){let I=t[r],T=i[I],S=n[I];k.longitude=g.lerp(y,p,S.x),k.latitude=g.lerp(m,l,S.y),k.height=T-e;let x=o.cartographicToCartesian(k,f);h.multiplyByPoint(a,x,x),d.minimumByComponent(x,s,s),d.maximumByComponent(x,c,c),u=Math.min(u,k.height)}return u}function x(t,e,i,n,o,a,s,c,h,u,l,m,d,y){let I=p(s),S=h.north,x=h.south,w=h.east,H=h.west;w<H&&(w+=g.TWO_PI);let j=i.length;for(let h=0;h<j;++h){let p,j,M=i[h],A=o[M],C=a[M];k.longitude=g.lerp(H,w,C.x)+d,k.latitude=g.lerp(x,S,C.y)+y,k.height=A-u;let N=c.cartographicToCartesian(k,f);if(I){let t=2*M;T.x=s[t],T.y=s[t+1]}n.hasWebMercatorT&&(p=(r.geodeticLatitudeToMercatorAngle(k.latitude)-l)*m),n.hasGeodeticSurfaceNormals&&(j=c.geodeticSurfaceNormal(N)),e=n.encode(t,e,N,C,k.height,T,p,j)}}function w(t,e){let i;return"function"==typeof t.slice&&"function"!=typeof(i=t.slice()).sort&&(i=void 0),p(i)||(i=Array.prototype.slice.call(t)),i.sort(e),i}var H=n(function(n,u){let H=n.quantizedVertices,j=H.length/3,M=n.octEncodedNormals,A=n.westIndices.length+n.eastIndices.length+n.southIndices.length+n.northIndices.length,C=n.includeWebMercatorT,N=n.exaggeration,b=n.exaggerationRelativeHeight,B=1!==N,P=c.clone(n.rectangle),W=P.west,v=P.south,E=P.east,F=P.north,L=m.clone(n.ellipsoid),V=n.minimumHeight,D=n.maximumHeight,U=n.relativeToCenter,z=s.eastNorthUpToFixedFrame(U,L),G=h.inverseTransformation(z,new h),K,O;C&&(K=r.geodeticLatitudeToMercatorAngle(v),O=1/(r.geodeticLatitudeToMercatorAngle(F)-K));let R=H.subarray(0,j),X=H.subarray(j,2*j),Y=H.subarray(2*j,3*j),J=p(M),Q=Array(j),_=Array(j),q=Array(j),Z=C?Array(j):[],$=B?Array(j):[];y.x=1/0,y.y=1/0,y.z=1/0,I.x=-1/0,I.y=-1/0,I.z=-1/0;let tt=1/0,te=-1/0,ti=1/0,tn=-1/0;for(let t=0;t<j;++t){let e=R[t],i=X[t],n=e/32767,o=i/32767,a=g.lerp(V,D,Y[t]/32767);k.longitude=g.lerp(W,E,n),k.latitude=g.lerp(v,F,o),k.height=a,tt=Math.min(k.longitude,tt),te=Math.max(k.longitude,te),ti=Math.min(k.latitude,ti),tn=Math.max(k.latitude,tn);let s=L.cartographicToCartesian(k);Q[t]=new l(n,o),_[t]=a,q[t]=s,C&&(Z[t]=(r.geodeticLatitudeToMercatorAngle(k.latitude)-K)*O),B&&($[t]=L.geodeticSurfaceNormal(s)),h.multiplyByPoint(G,s,f),d.minimumByComponent(f,y,y),d.maximumByComponent(f,I,I)}let tr=w(n.westIndices,function(t,e){return Q[t].y-Q[e].y}),to=w(n.eastIndices,function(t,e){return Q[e].y-Q[t].y}),ta=w(n.southIndices,function(t,e){return Q[e].x-Q[t].x}),ts=w(n.northIndices,function(t,e){return Q[t].x-Q[e].x}),tc;V<0&&(tc=new e(L).computeHorizonCullingPointPossiblyUnderEllipsoid(U,q,V));let th=V;th=Math.min(th=Math.min(th=Math.min(th=Math.min(th,S(n.westIndices,n.westSkirtHeight,_,Q,P,L,G,y,I)),S(n.southIndices,n.southSkirtHeight,_,Q,P,L,G,y,I)),S(n.eastIndices,n.eastSkirtHeight,_,Q,P,L,G,y,I)),S(n.northIndices,n.northSkirtHeight,_,Q,P,L,G,y,I));let tu=new o(y,I,U),tl=new i(U,tu,th,D,z,J,C,B,N,b),tm=tl.stride,td=new Float32Array(j*tm+A*tm),tg=0;for(let t=0;t<j;++t){if(J){let e=2*t;T.x=M[e],T.y=M[e+1]}tg=tl.encode(td,tg,q[t],Q[t],_[t],T,Z[t],$[t])}let tp=Math.max(0,(A-4)*2),tf=n.indices.length+3*tp,ty=a.createTypedArray(j+A,tf);ty.set(n.indices,0);let tI=(te-tt)*1e-4,tk=(tn-ti)*1e-4,tT=j*tm;return x(td,tT,tr,tl,_,Q,M,L,P,n.westSkirtHeight,K,O,-tI,0),x(td,tT+=n.westIndices.length*tm,ta,tl,_,Q,M,L,P,n.southSkirtHeight,K,O,0,-tk),x(td,tT+=n.southIndices.length*tm,to,tl,_,Q,M,L,P,n.eastSkirtHeight,K,O,tI,0),x(td,tT+=n.eastIndices.length*tm,ts,tl,_,Q,M,L,P,n.northSkirtHeight,K,O,0,tk),t.addSkirtIndices(tr,ta,to,ts,j,ty,n.indices.length),u.push(td.buffer,ty.buffer),{vertices:td.buffer,indices:ty.buffer,westIndicesSouthToNorth:tr,southIndicesEastToWest:ta,eastIndicesNorthToSouth:to,northIndicesWestToEast:ts,vertexStride:tm,center:U,minimumHeight:V,maximumHeight:D,occludeePointInScaledSpace:tc,encoding:tl,indexCountWithoutSkirts:n.indices.length}});export{H as default};