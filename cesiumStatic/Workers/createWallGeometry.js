import{a as t}from"./chunk-DQOJTVZF.js";import"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import{a as e}from"./chunk-ZXZD7KWX.js";import"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as i}from"./chunk-KSX6TRAS.js";import{a as n}from"./chunk-GMTHOMGW.js";import{b as o,c as r,d as a}from"./chunk-BELR52CD.js";import{c as s}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as m}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{c as l}from"./chunk-ICY67TC6.js";import{a as p,c as u}from"./chunk-G2EMNOST.js";import{a as h}from"./chunk-4VFKVGYI.js";import{a as c}from"./chunk-3WJNS2B6.js";import{e as g}from"./chunk-XCN226AA.js";var f=new p,d=new p,k=new p,y=new p,w=new p,_=new p,A=new p;function v(t){let i=(t=t??u.EMPTY_OBJECT).positions,n=t.maximumHeights,o=t.minimumHeights;if(!g(i))throw new c("options.positions is required.");if(g(n)&&n.length!==i.length)throw new c("options.positions and options.maximumHeights must have the same length.");if(g(o)&&o.length!==i.length)throw new c("options.positions and options.minimumHeights must have the same length.");let r=t.vertexFormat??e.DEFAULT,a=t.granularity??h.RADIANS_PER_DEGREE,s=t.ellipsoid??l.default;this._positions=i,this._minimumHeights=o,this._maximumHeights=n,this._vertexFormat=e.clone(r),this._granularity=a,this._ellipsoid=l.clone(s),this._workerName="createWallGeometry";let m=1+i.length*p.packedLength+2;g(o)&&(m+=o.length),g(n)&&(m+=n.length),this.packedLength=m+l.packedLength+e.packedLength+1}v.pack=function(t,i,n){if(!g(t))throw new c("value is required");if(!g(i))throw new c("array is required");n=n??0;let o,r=t._positions,a=r.length;for(i[n++]=a,o=0;o<a;++o,n+=p.packedLength)p.pack(r[o],i,n);let s=t._minimumHeights;if(a=g(s)?s.length:0,i[n++]=a,g(s))for(o=0;o<a;++o)i[n++]=s[o];let m=t._maximumHeights;if(a=g(m)?m.length:0,i[n++]=a,g(m))for(o=0;o<a;++o)i[n++]=m[o];return l.pack(t._ellipsoid,i,n),n+=l.packedLength,e.pack(t._vertexFormat,i,n),i[n+=e.packedLength]=t._granularity,i};var H=l.clone(l.UNIT_SPHERE),x=new e,L={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:H,vertexFormat:x,granularity:void 0};v.unpack=function(t,i,n){let o,r;if(!g(t))throw new c("array is required");i=i??0;let a,s=t[i++],m=Array(s);for(a=0;a<s;++a,i+=p.packedLength)m[a]=p.unpack(t,i);if((s=t[i++])>0)for(o=Array(s),a=0;a<s;++a)o[a]=t[i++];if((s=t[i++])>0)for(r=Array(s),a=0;a<s;++a)r[a]=t[i++];let u=l.unpack(t,i,H);i+=l.packedLength;let h=e.unpack(t,i,x),f=t[i+=e.packedLength];return g(n)?(n._positions=m,n._minimumHeights=o,n._maximumHeights=r,n._ellipsoid=l.clone(u,n._ellipsoid),n._vertexFormat=e.clone(h,n._vertexFormat),n._granularity=f,n):(L.positions=m,L.minimumHeights=o,L.maximumHeights=r,L.granularity=f,new v(L))},v.fromConstantHeights=function(t){let e=(t=t??u.EMPTY_OBJECT).positions;if(!g(e))throw new c("options.positions is required.");let i,n,o=t.minimumHeight,r=t.maximumHeight,a=g(o),s=g(r);if(a||s){let t=e.length;i=a?Array(t):void 0,n=s?Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),s&&(n[e]=r)}return new v({positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},v.createGeometry=function(e){let l=e._positions,u=e._minimumHeights,c=e._maximumHeights,v=e._vertexFormat,H=e._granularity,x=e._ellipsoid,L=t.computePositions(x,l,c,u,H,!0);if(!g(L))return;let j=L.bottomPositions,F=L.topPositions,T=L.numCorners,E=F.length,b=2*E,P=v.position?new Float64Array(b):void 0,D=v.normal?new Float32Array(b):void 0,N=v.tangent?new Float32Array(b):void 0,O=v.bitangent?new Float32Array(b):void 0,S=v.st?new Float32Array(b/3*2):void 0,C=0,z=0,I=0,G=0,B=0,M=A,R=_,V=w,Y=!0,q,W=0,X=1/((E/=3)-T-1);for(q=0;q<E;++q){let t=3*q,e=p.fromArray(F,t,f),i=p.fromArray(j,t,d);if(v.position&&(P[C++]=i.x,P[C++]=i.y,P[C++]=i.z,P[C++]=e.x,P[C++]=e.y,P[C++]=e.z),v.st&&(S[B++]=W,S[B++]=0,S[B++]=W,S[B++]=1),v.normal||v.tangent||v.bitangent){let i=p.clone(p.ZERO,y),n=p.subtract(e,x.geodeticSurfaceNormal(e,d),d);if(q+1<E&&(i=p.fromArray(F,t+3,y)),Y){let t=p.subtract(i,e,k),o=p.subtract(n,e,f);M=p.normalize(p.cross(o,t,M),M),Y=!1}p.equalsEpsilon(e,i,h.EPSILON10)?Y=!0:(W+=X,v.tangent&&(R=p.normalize(p.subtract(i,e,R),R)),v.bitangent&&(V=p.normalize(p.cross(M,R,V),V))),v.normal&&(D[z++]=M.x,D[z++]=M.y,D[z++]=M.z,D[z++]=M.x,D[z++]=M.y,D[z++]=M.z),v.tangent&&(N[G++]=R.x,N[G++]=R.y,N[G++]=R.z,N[G++]=R.x,N[G++]=R.y,N[G++]=R.z),v.bitangent&&(O[I++]=V.x,O[I++]=V.y,O[I++]=V.z,O[I++]=V.x,O[I++]=V.y,O[I++]=V.z)}}let J=new n;v.position&&(J.position=new a({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:P})),v.normal&&(J.normal=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:D})),v.tangent&&(J.tangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:N})),v.bitangent&&(J.bitangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:O})),v.st&&(J.st=new a({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:S}));let K=b/3;b-=6*(T+1);let Z=i.createTypedArray(K,b),U=0;for(q=0;q<K-2;q+=2){let t=q,e=q+2,i=p.fromArray(P,3*t,f),n=p.fromArray(P,3*e,d);if(p.equalsEpsilon(i,n,h.EPSILON10))continue;let o=q+1,r=q+3;Z[U++]=o,Z[U++]=t,Z[U++]=r,Z[U++]=r,Z[U++]=t,Z[U++]=e}return new r({attributes:J,indices:Z,primitiveType:o.TRIANGLES,boundingSphere:new s.fromVertices(P)})};var j=function(t,e){return g(e)&&(t=v.unpack(t,e)),t._ellipsoid=l.clone(t._ellipsoid),v.createGeometry(t)};export{j as default};