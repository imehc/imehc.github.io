import{a as t}from"./chunk-MOQBM3XJ.js";import"./chunk-2A2JFXXO.js";import"./chunk-TULFNR3P.js";import{a as e}from"./chunk-PXD6ATBI.js";import"./chunk-KF74ULE7.js";import"./chunk-4EHG4BFI.js";import"./chunk-KIJM7B3H.js";import"./chunk-P44F6KLE.js";import{a as i}from"./chunk-GSMLTRAL.js";import{a as n}from"./chunk-IUX576XK.js";import{b as o,c as r,d as a}from"./chunk-UIGT6VOJ.js";import{c as s}from"./chunk-XO2FNJZK.js";import"./chunk-CM5O7VPK.js";import"./chunk-IB27QQGF.js";import"./chunk-RGFEE67W.js";import{a as m}from"./chunk-KXT7EZPS.js";import"./chunk-ZIOQOCPQ.js";import"./chunk-SY2GINYP.js";import{c as l}from"./chunk-KCR7AORG.js";import{a as p,c as u}from"./chunk-QDJTHWTA.js";import{a as h}from"./chunk-2YWR3G22.js";import{a as c}from"./chunk-HTSQLHXI.js";import{e as g}from"./chunk-JDAHMWM5.js";var f=new p,d=new p,k=new p,y=new p,w=new p,A=new p,_=new p;function v(t){let i=(t=t??u.EMPTY_OBJECT).positions,n=t.maximumHeights,o=t.minimumHeights;if(!g(i))throw new c("options.positions is required.");if(g(n)&&n.length!==i.length)throw new c("options.positions and options.maximumHeights must have the same length.");if(g(o)&&o.length!==i.length)throw new c("options.positions and options.minimumHeights must have the same length.");let r=t.vertexFormat??e.DEFAULT,a=t.granularity??h.RADIANS_PER_DEGREE,s=t.ellipsoid??l.default;this._positions=i,this._minimumHeights=o,this._maximumHeights=n,this._vertexFormat=e.clone(r),this._granularity=a,this._ellipsoid=l.clone(s),this._workerName="createWallGeometry";let m=1+i.length*p.packedLength+2;g(o)&&(m+=o.length),g(n)&&(m+=n.length),this.packedLength=m+l.packedLength+e.packedLength+1}v.pack=function(t,i,n){if(!g(t))throw new c("value is required");if(!g(i))throw new c("array is required");n=n??0;let o,r=t._positions,a=r.length;for(i[n++]=a,o=0;o<a;++o,n+=p.packedLength)p.pack(r[o],i,n);let s=t._minimumHeights;if(a=g(s)?s.length:0,i[n++]=a,g(s))for(o=0;o<a;++o)i[n++]=s[o];let m=t._maximumHeights;if(a=g(m)?m.length:0,i[n++]=a,g(m))for(o=0;o<a;++o)i[n++]=m[o];return l.pack(t._ellipsoid,i,n),n+=l.packedLength,e.pack(t._vertexFormat,i,n),i[n+=e.packedLength]=t._granularity,i};var x=l.clone(l.UNIT_SPHERE),H=new e,F={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:x,vertexFormat:H,granularity:void 0};v.unpack=function(t,i,n){let o,r;if(!g(t))throw new c("array is required");i=i??0;let a,s=t[i++],m=Array(s);for(a=0;a<s;++a,i+=p.packedLength)m[a]=p.unpack(t,i);if((s=t[i++])>0)for(o=Array(s),a=0;a<s;++a)o[a]=t[i++];if((s=t[i++])>0)for(r=Array(s),a=0;a<s;++a)r[a]=t[i++];let u=l.unpack(t,i,x);i+=l.packedLength;let h=e.unpack(t,i,H),f=t[i+=e.packedLength];return g(n)?(n._positions=m,n._minimumHeights=o,n._maximumHeights=r,n._ellipsoid=l.clone(u,n._ellipsoid),n._vertexFormat=e.clone(h,n._vertexFormat),n._granularity=f,n):(F.positions=m,F.minimumHeights=o,F.maximumHeights=r,F.granularity=f,new v(F))},v.fromConstantHeights=function(t){let e=(t=t??u.EMPTY_OBJECT).positions;if(!g(e))throw new c("options.positions is required.");let i,n,o=t.minimumHeight,r=t.maximumHeight,a=g(o),s=g(r);if(a||s){let t=e.length;i=a?Array(t):void 0,n=s?Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),s&&(n[e]=r)}return new v({positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},v.createGeometry=function(e){let l=e._positions,u=e._minimumHeights,c=e._maximumHeights,v=e._vertexFormat,x=e._granularity,H=e._ellipsoid,F=t.computePositions(H,l,c,u,x,!0);if(!g(F))return;let L=F.bottomPositions,E=F.topPositions,j=F.numCorners,P=E.length,T=2*P,b=v.position?new Float64Array(T):void 0,O=v.normal?new Float32Array(T):void 0,I=v.tangent?new Float32Array(T):void 0,G=v.bitangent?new Float32Array(T):void 0,D=v.st?new Float32Array(T/3*2):void 0,R=0,z=0,S=0,N=0,J=0,M=_,X=A,B=w,K=!0,q,C=0,Q=1/((P/=3)-j-1);for(q=0;q<P;++q){let t=3*q,e=p.fromArray(E,t,f),i=p.fromArray(L,t,d);if(v.position&&(b[R++]=i.x,b[R++]=i.y,b[R++]=i.z,b[R++]=e.x,b[R++]=e.y,b[R++]=e.z),v.st&&(D[J++]=C,D[J++]=0,D[J++]=C,D[J++]=1),v.normal||v.tangent||v.bitangent){let i=p.clone(p.ZERO,y),n=p.subtract(e,H.geodeticSurfaceNormal(e,d),d);if(q+1<P&&(i=p.fromArray(E,t+3,y)),K){let t=p.subtract(i,e,k),o=p.subtract(n,e,f);M=p.normalize(p.cross(o,t,M),M),K=!1}p.equalsEpsilon(e,i,h.EPSILON10)?K=!0:(C+=Q,v.tangent&&(X=p.normalize(p.subtract(i,e,X),X)),v.bitangent&&(B=p.normalize(p.cross(M,X,B),B))),v.normal&&(O[z++]=M.x,O[z++]=M.y,O[z++]=M.z,O[z++]=M.x,O[z++]=M.y,O[z++]=M.z),v.tangent&&(I[N++]=X.x,I[N++]=X.y,I[N++]=X.z,I[N++]=X.x,I[N++]=X.y,I[N++]=X.z),v.bitangent&&(G[S++]=B.x,G[S++]=B.y,G[S++]=B.z,G[S++]=B.x,G[S++]=B.y,G[S++]=B.z)}}let U=new n;v.position&&(U.position=new a({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:b})),v.normal&&(U.normal=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:O})),v.tangent&&(U.tangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:I})),v.bitangent&&(U.bitangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:G})),v.st&&(U.st=new a({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:D}));let W=T/3;T-=6*(j+1);let Y=i.createTypedArray(W,T),Z=0;for(q=0;q<W-2;q+=2){let t=q,e=q+2,i=p.fromArray(b,3*t,f),n=p.fromArray(b,3*e,d);if(p.equalsEpsilon(i,n,h.EPSILON10))continue;let o=q+1,r=q+3;Y[Z++]=o,Y[Z++]=t,Y[Z++]=r,Y[Z++]=r,Y[Z++]=t,Y[Z++]=e}return new r({attributes:U,indices:Y,primitiveType:o.TRIANGLES,boundingSphere:new s.fromVertices(b)})};var L=function(t,e){return g(e)&&(t=v.unpack(t,e)),t._ellipsoid=l.clone(t._ellipsoid),v.createGeometry(t)};export{L as default};