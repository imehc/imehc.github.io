import{a as i}from"./chunk-DQOJTVZF.js";import"./chunk-JZMSTCXO.js";import"./chunk-YX3VGNCD.js";import"./chunk-YM5K5MQ6.js";import"./chunk-6L5NM26F.js";import"./chunk-SPC72PTY.js";import"./chunk-HVWI7BO6.js";import{a as t}from"./chunk-KSX6TRAS.js";import{a as e}from"./chunk-GMTHOMGW.js";import{b as o,c as n,d as r}from"./chunk-BELR52CD.js";import{c as s}from"./chunk-BNHFHP3L.js";import"./chunk-4UHVCH4T.js";import"./chunk-4NDD6KRQ.js";import"./chunk-5ELDAYCN.js";import{a as m}from"./chunk-N6BI774S.js";import"./chunk-TI35VBH7.js";import"./chunk-6WLI3422.js";import{c as a}from"./chunk-ICY67TC6.js";import{a as h,c as u}from"./chunk-G2EMNOST.js";import{a as p}from"./chunk-4VFKVGYI.js";import{a as l}from"./chunk-3WJNS2B6.js";import{e as c}from"./chunk-XCN226AA.js";var g=new h,f=new h;function d(i){let t=(i=i??u.EMPTY_OBJECT).positions,e=i.maximumHeights,o=i.minimumHeights;if(!c(t))throw new l("options.positions is required.");if(c(e)&&e.length!==t.length)throw new l("options.positions and options.maximumHeights must have the same length.");if(c(o)&&o.length!==t.length)throw new l("options.positions and options.minimumHeights must have the same length.");let n=i.granularity??p.RADIANS_PER_DEGREE,r=i.ellipsoid??a.default;this._positions=t,this._minimumHeights=o,this._maximumHeights=e,this._granularity=n,this._ellipsoid=a.clone(r),this._workerName="createWallOutlineGeometry";let s=1+t.length*h.packedLength+2;c(o)&&(s+=o.length),c(e)&&(s+=e.length),this.packedLength=s+a.packedLength+1}d.pack=function(i,t,e){if(!c(i))throw new l("value is required");if(!c(t))throw new l("array is required");e=e??0;let o,n=i._positions,r=n.length;for(t[e++]=r,o=0;o<r;++o,e+=h.packedLength)h.pack(n[o],t,e);let s=i._minimumHeights;if(r=c(s)?s.length:0,t[e++]=r,c(s))for(o=0;o<r;++o)t[e++]=s[o];let m=i._maximumHeights;if(r=c(m)?m.length:0,t[e++]=r,c(m))for(o=0;o<r;++o)t[e++]=m[o];return a.pack(i._ellipsoid,t,e),t[e+=a.packedLength]=i._granularity,t};var k=a.clone(a.UNIT_SPHERE),H={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:k,granularity:void 0};d.unpack=function(i,t,e){let o,n;if(!c(i))throw new l("array is required");t=t??0;let r,s=i[t++],m=Array(s);for(r=0;r<s;++r,t+=h.packedLength)m[r]=h.unpack(i,t);if((s=i[t++])>0)for(o=Array(s),r=0;r<s;++r)o[r]=i[t++];if((s=i[t++])>0)for(n=Array(s),r=0;r<s;++r)n[r]=i[t++];let u=a.unpack(i,t,k),p=i[t+=a.packedLength];return c(e)?(e._positions=m,e._minimumHeights=o,e._maximumHeights=n,e._ellipsoid=a.clone(u,e._ellipsoid),e._granularity=p,e):(H.positions=m,H.minimumHeights=o,H.maximumHeights=n,H.granularity=p,new d(H))},d.fromConstantHeights=function(i){let t=(i=i??u.EMPTY_OBJECT).positions;if(!c(t))throw new l("options.positions is required.");let e,o,n=i.minimumHeight,r=i.maximumHeight,s=c(n),m=c(r);if(s||m){let i=t.length;e=s?Array(i):void 0,o=m?Array(i):void 0;for(let t=0;t<i;++t)s&&(e[t]=n),m&&(o[t]=r)}return new d({positions:t,maximumHeights:o,minimumHeights:e,ellipsoid:i.ellipsoid})},d.createGeometry=function(a){let u,l=a._positions,d=a._minimumHeights,k=a._maximumHeights,H=a._granularity,_=a._ellipsoid,y=i.computePositions(_,l,k,d,H,!1);if(!c(y))return;let w=y.bottomPositions,j=y.topPositions,A=j.length,E=2*A,T=new Float64Array(E),L=0;for(A/=3,u=0;u<A;++u){let i=3*u,t=h.fromArray(j,i,g),e=h.fromArray(w,i,f);T[L++]=e.x,T[L++]=e.y,T[L++]=e.z,T[L++]=t.x,T[L++]=t.y,T[L++]=t.z}let v=new e({position:new r({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:T})}),N=E/3;E=2*N-4+N;let x=t.createTypedArray(N,E),C=0;for(u=0;u<N-2;u+=2){let i=u,t=u+2,e=h.fromArray(T,3*i,g),o=h.fromArray(T,3*t,f);if(h.equalsEpsilon(e,o,p.EPSILON10))continue;let n=u+1,r=u+3;x[C++]=n,x[C++]=i,x[C++]=n,x[C++]=r,x[C++]=i,x[C++]=t}return x[C++]=N-2,x[C++]=N-1,new n({attributes:v,indices:x,primitiveType:o.LINES,boundingSphere:new s.fromVertices(T)})};var _=function(i,t){return c(t)&&(i=d.unpack(i,t)),i._ellipsoid=a.clone(i._ellipsoid),d.createGeometry(i)};export{_ as default};